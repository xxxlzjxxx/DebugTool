KPrescaler)
{
  /* Check the parameters */
  assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));

  *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
  
}

/**
  * @brief  Enables or disables the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it.   
  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
  *            @arg RCC_AHB1Periph_CRC:         CRC clock
  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
  *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
  }
}

/**
  * @brief  Enables or disables the AHB2 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it. 
  * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
  *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
  *            @arg RCC_AHB2Periph_HASH:   HASH clock
  *            @arg RCC_AHB2Periph_RNG:    RNG clock
  *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
  }
}

/**
  * @brief  Enables or disables the AHB3 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it. 
  * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
  *          This parameter must be: RCC_AHB3Periph_FSMC
  *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
  }
}

/**
  * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it. 
  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
  *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
  *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
  *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
  *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
  *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
  *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
  *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
  *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
  *            @arg RCC_APB1Periph_WWDG:   WWDG clock
  *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
  *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
  *            @arg RCC_APB1Periph_USART2: USART2 clock
  *            @arg RCC_APB1Periph_USART3: USART3 clock
  *            @arg RCC_APB1Periph_UART4:  UART4 clock
  *            @arg RCC_APB1Periph_UART5:  UART5 clock
  *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
  *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
  *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
  *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
  *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
  *            @arg RCC_APB1Periph_PWR:    PWR clock
  *            @arg RCC_APB1Periph_DAC:    DAC clock
  *            @arg RCC_APB1Periph_UART7:  UART7 clock
  *            @arg RCC_APB1Periph_UART8:  UART8 clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}

/**
  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it.
  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
  *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
  *            @arg RCC_APB2Periph_USART1: USART1 clock
  *            @arg RCC_APB2Periph_USART6: USART6 clock
  *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
  *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
  *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
  *            @arg RCC_APB2Periph_SDIO:   SDIO clock
  *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
  *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
  *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
  *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
  *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
  *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
  *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
  *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
  *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices) 
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}

/**
  * @brief  Forces or releases AHB1 peripheral reset.
  * @param  RCC_AHB1Periph: specifies the AHB1 peripheral to reset.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB1Periph_GPIOA:   GPIOA clock
  *            @arg RCC_AHB1Periph_GPIOB:   GPIOB clock 
  *            @arg RCC_AHB1Periph_GPIOC:   GPIOC clock
  *            @arg RCC_AHB1Periph_GPIOD:   GPIOD clock
  *            @arg RCC_AHB1Periph_GPIOE:   GPIOE clock
  *            @arg RCC_AHB1Periph_GPIOF:   GPIOF clock
  *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOI:   GPIOI clock
  *            @arg RCC_AHB1Periph_GPIOJ:   GPIOJ clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_AHB1Periph_GPIOK:   GPIOK clock (STM32F42xxx/43xxxdevices)   
  *            @arg RCC_AHB1Periph_CRC:     CRC clock
  *            @arg RCC_AHB1Periph_DMA1:    DMA1 clock
  *            @arg RCC_AHB1Periph_DMA2:    DMA2 clock
  *            @arg RCC_AHB1Periph_DMA2D:   DMA2D clock (STM32F429xx/439xx devices)   
  *            @arg RCC_AHB1Periph_ETH_MAC: Ethernet MAC clock
  *            @arg RCC_AHB1Periph_OTG_HS:  USB OTG HS clock
  *                  
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
  }
}

/**
  * @brief  Forces or releases AHB2 peripheral reset.
  * @param  RCC_AHB2Periph: specifies the AHB2 peripheral to reset.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
  *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
  *            @arg RCC_AHB2Periph_HASH:   HASH clock
  *            @arg RCC_AHB2Periph_RNG:    RNG clock
  *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
  }
}

/**
  * @brief  Forces or releases AHB3 peripheral reset.
  * @param  RCC_AHB3Periph: specifies the AHB3 peripheral to reset.
  *          This parameter must be: RCC_AHB3Periph_FSMC
  *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
  }
}

/**
  * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
  * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
  *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
  *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
  *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
  *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
  *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
  *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
  *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
  *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
  *            @arg RCC_APB1Periph_WWDG:   WWDG clock
  *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
  *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
  *            @arg RCC_APB1Periph_USART2: USART2 clock
  *            @arg RCC_APB1Periph_USART3: USART3 clock
  *            @arg RCC_APB1Periph_UART4:  UART4 clock
  *            @arg RCC_APB1Periph_UART5:  UART5 clock
  *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
  *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
  *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
  *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
  *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
  *            @arg RCC_APB1Periph_PWR:    PWR clock
  *            @arg RCC_APB1Periph_DAC:    DAC clock
  *            @arg RCC_APB1Periph_UART7:  UART7 clock
  *            @arg RCC_APB1Periph_UART8:  UART8 clock  
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
  }
}

/**
  * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
  * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
  *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
  *            @arg RCC_APB2Periph_USART1: USART1 clock
  *            @arg RCC_APB2Periph_USART6: USART6 clock
  *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
  *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
  *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
  *            @arg RCC_APB2Periph_SDIO:   SDIO clock
  *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
  *            @arg RCC_APB2Periph_SPI4:   SPI4 clock  
  *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
  *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
  *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
  *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
  *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
  *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
  *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
  * @param  NewState: new state of the specified peripheral reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
  }
}

/**
  * @brief  Enables or disables the AHB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)   
  *            @arg RCC_AHB1Periph_CRC:         CRC clock
  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices) 
  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
  }
}

/**
  * @brief  Enables or disables the AHB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *           power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
  *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
  *            @arg RCC_AHB2Periph_HASH:   HASH clock
  *            @arg RCC_AHB2Periph_RNG:    RNG clock
  *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock  
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
  }
}

/**
  * @brief  Enables or disables the AHB3 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
  *          This parameter must be: RCC_AHB3Periph_FSMC
  *                                  or RCC_AHB3Periph_FMC (STM32F429x/439x devices) 
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
  }
}

/**
  * @brief  Enables or disables the APB1 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
  *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
  *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
  *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
  *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
  *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
  *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
  *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
  *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
  *            @arg RCC_APB1Periph_WWDG:   WWDG clock
  *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
  *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
  *            @arg RCC_APB1Periph_USART2: USART2 clock
  *            @arg RCC_APB1Periph_USART3: USART3 clock
  *            @arg RCC_APB1Periph_UART4:  UART4 clock
  *            @arg RCC_APB1Periph_UART5:  UART5 clock
  *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
  *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
  *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
  *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
  *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
  *            @arg RCC_APB1Periph_PWR:    PWR clock
  *            @arg RCC_APB1Periph_DAC:    DAC clock
  *            @arg RCC_APB1Periph_UART7:  UART7 clock
  *            @arg RCC_APB1Periph_UART8:  UART8 clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
  }
}

/**
  * @brief  Enables or disables the APB2 peripheral clock during Low Power (Sleep) mode.
  * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
  *         power consumption.
  * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
  * @note   By default, all peripheral clocks are enabled during SLEEP mode.
  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
  *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
  *            @arg RCC_APB2Periph_USART1: USART1 clock
  *            @arg RCC_APB2Periph_USART6: USART6 clock
  *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
  *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
  *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
  *            @arg RCC_APB2Periph_SDIO:   SDIO clock
  *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
  *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
  *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
  *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
  *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
  *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
  *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
  *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
  *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
  }
}

/**
  * @brief Configures the External Low Speed oscillator mode (LSE mode).
  * @note This mode is only available for STM32F411xx devices.
  * @param  Mode: specifies the LSE mode.
  *          This parameter can be one of the following values:
  *            @arg RCC_LSE_LOWPOWER_MODE:  LSE oscillator in low power mode.
  *            @arg RCC_LSE_HIGHDRIVE_MODE: LSE oscillator in High Drive mode.
  * @retval None
  */
void RCC_LSEModeConfig(uint8_t Mode)
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE_MODE(Mode));
  
  if(Mode == RCC_LSE_HIGHDRIVE_MODE)
  {
    SET_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
  }
  else
  {
    CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEMOD);
  }
}

/**
  * @}
  */

/** @defgroup RCC_Group4 Interrupts and flags management functions
 *  @brief   Interrupts and flags management functions 
 *
@verbatim   
 ===============================================================================
                ##### Interrupts and flags management functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the specified RCC interrupts.
  * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_IT_LSIRDY: LSI ready interrupt
  *            @arg RCC_IT_LSERDY: LSE ready interrupt
  *            @arg RCC_IT_HSIRDY: HSI ready interrupt
  *            @arg RCC_IT_HSERDY: HSE ready interrupt
  *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt
  *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)
  * @param  NewState: new state of the specified RCC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
  }
}

/**
  * @brief  Checks whether the specified RCC flag is set or not.
  * @param  RCC_FLAG: specifies the flag to check.
  *          This parameter can be one of the following values:
  *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
  *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
  *            @arg RCC_FLAG_PLLRDY: main PLL clock ready
  *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready
  *            @arg RCC_FLAG_PLLSAIRDY: PLLSAI clock ready (only for STM32F42xxx/43xxx devices)
  *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
  *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
  *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset
  *            @arg RCC_FLAG_PINRST: Pin reset
  *            @arg RCC_FLAG_PORRST: POR/PDR reset
  *            @arg RCC_FLAG_SFTRST: Software reset
  *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
  *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
  *            @arg RCC_FLAG_LPWRRST: Low Power reset
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
  uint32_t tmp = 0;
  uint32_t statusreg = 0;
  FlagStatus bitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}

/**
  * @brief  Clears the RCC reset flags.
  *         The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,  RCC_FLAG_SFTRST,
  *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
  * @param  None
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
}

/**
  * @brief  Checks whether the specified RCC interrupt has occurred or not.
  * @param  RCC_IT: specifies the RCC interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg RCC_IT_LSIRDY: LSI ready interrupt
  *            @arg RCC_IT_LSERDY: LSE ready interrupt
  *            @arg RCC_IT_HSIRDY: HSI ready interrupt
  *            @arg RCC_IT_HSERDY: HSE ready interrupt
  *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt           
  *            @arg RCC_IT_PLLSAIRDY: PLLSAI clock ready interrupt (only for STM32F42xxx/43xxx devices)    
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval The new state of RCC_IT (SET or RESET).
  */
ITStatus RCC_GetITStatus(uint8_t RCC_IT)
{
  ITStatus bitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}

/**
  * @brief  Clears the RCC's interrupt pending bits.
  * @param  RCC_IT: specifies the interrupt pending bit to clear.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_IT_LSIRDY: LSI ready interrupt
  *            @arg RCC_IT_LSERDY: LSE ready interrupt
  *            @arg RCC_IT_HSIRDY: HSI ready interrupt
  *            @arg RCC_IT_HSERDY: HSE ready interrupt
  *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
  *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
  *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)   
  *            @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval None
  */
void RCC_ClearITPendingBit(uint8_t RCC_IT)
{
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
}

/**
  * @}
  */ 

/**
  * @}
  */ 

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
  ******************************************************************************
  * @file    stm32f4xx_rng.c
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief This file provides firmware functions to manage the following 
  *          functionalities of the Random Number Generator (RNG) peripheral:           
  *           + Initialization and Configuration 
  *           + Get 32 bit Random number      
  *           + Interrupts and flags management       
  *         
@verbatim
                                 
 ===================================================================      
                 ##### How to use this driver #####
 ===================================================================          
 [..]
   (#) Enable The RNG controller clock using 
       RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, ENABLE) function.
                
   (#) Activate the RNG peripheral using RNG_Cmd() function.
            
   (#) Wait until the 32 bit Random number Generator contains a valid  random data
      (using polling/interrupt mode). For more details, refer to "Interrupts and 
      flags management functions" module description.
             
   (#) Get the 32 bit Random number using RNG_GetRandomNumber() function
            
   (#) To get another 32 bit Random number, go to step 3.       
         
                
@endverbatim
  *         
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************  
  */

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_rng.h"
#include "stm32f4xx_rcc.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @defgroup RNG 
  * @brief RNG driver modules
  * @{
  */ 

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/** @defgroup RNG_Private_Functions
  * @{
  */ 

/** @defgroup RNG_Group1 Initialization and Configuration functions
 *  @brief    Initialization and Configuration functions 
 *
@verbatim    
 ===============================================================================
             ##### Initialization and Configuration functions #####
 ===============================================================================  
 [..] This section provides functions allowing to 
   (+) Initialize the RNG peripheral
   (+) Enable or disable the RNG peripheral
   
@endverbatim
  * @{
  */

/**
  * @brief  De-initializes the RNG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void RNG_DeInit(void)
{
  /* Enable RNG reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, ENABLE);

  /* Release RNG from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, DISABLE);
}

/**
  * @brief  Enables or disables the RNG peripheral.
  * @param  NewState: new state of the RNG peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RNG_Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the RNG */
    RNG->CR |= RNG_CR_RNGEN;
  }
  else
  {
    /* Disable the RNG */
    RNG->CR &= ~RNG_CR_RNGEN;
  }
}
/**
  * @}
  */

/** @defgroup RNG_Group2 Get 32 bit Random number function
 *  @brief    Get 32 bit Random number function 
 *

@verbatim    
 ===============================================================================
                 ##### Get 32 bit Random number function #####
 ===============================================================================  
 [..] This section provides a function allowing to get the 32 bit Random number  
  
   (@)  Before to call this function you have to wait till DRDY flag is set,
        using RNG_GetFlagStatus(RNG_FLAG_DRDY) function. 
   
@endverbatim
  * @{
  */


/**
  * @brief  Returns a 32-bit random number.
  *   
  * @note   Before to call this function you have to wait till DRDY (data ready)
  *         flag is set, using RNG_GetFlagStatus(RNG_FLAG_DRDY) function.
  * @note   Each time the the Random number data is read (using RNG_GetRandomNumber()
  *         function), the RNG_FLAG_DRDY flag is automatically cleared.
  * @note   In the case of a seed error, the generation of random numbers is 
  *         interrupted for as long as the SECS bit is '1'. If a number is 
  *         available in the RNG_DR register, it must not be used because it may 
  *         not have enough entropy. In this case, it is recommended to clear the 
  *         SEIS bit(using RNG_ClearFlag(RNG_FLAG_SECS) function), then disable 
  *         and enable the RNG peripheral (using RNG_Cmd() function) to 
  *         reinitialize and restart the RNG.
  * @note   In the case of a clock error, the RNG is no more able to generate 
  *         random numbers because the PLL48CLK clock is not correct. User have 
  *         to check that the clock controller is correctly configured to provide
  *         the RNG clock and clear the CEIS bit (using RNG_ClearFlag(RNG_FLAG_CECS) 
  *         function) . The clock error has no impact on the previously generated 
  *         random numbers, and the RNG_DR register contents can be used.
  *         
  * @param  None
  * @retval 32-bit random number.
  */
uint32_t RNG_GetRandomNumber(void)
{
  /* Return the 32 bit random number from the DR register */
  return RNG->DR;
}


/**
  * @}
  */

/** @defgroup RNG_Group3 Interrupts and flags management functions
 *  @brief   Interrupts and flags management functions
 *
@verbatim   
 ===============================================================================
             ##### Interrupts and flags management functions #####
 ===============================================================================  

 [..] This section provides functions allowing to configure the RNG Interrupts and 
      to get the status and clear flags and Interrupts pending bits.
  
 [..] The RNG provides 3 Interrupts sources and 3 Flags:
  
 *** Flags : ***
 ===============
 [..] 
    (#) RNG_FLAG_DRDY :  In the case of the RNG_DR register contains valid 
        random data. it is cleared by reading the valid data(using 
        RNG_GetRandomNumber() function).

    (#) RNG_FLAG_CECS : In the case of a seed error detection. 
      
    (#) RNG_FLAG_SECS : In the case of a clock error detection.
              
 *** Interrupts ***
 ==================
 [..] If enabled, an RNG interrupt is pending :
    
   (#) In the case of the RNG_DR register contains valid random data. 
       This interrupt source is cleared once the RNG_DR register has been read 
       (using RNG_GetRandomNumber() function) until a new valid value is 
       computed; or 
   (#) In the case of a seed error : One of the following faulty sequences has 
       been detected:
       (++) More than 64 consecutive bits at the same value (0 or 1)
       (++) More than 32 consecutive alternance of 0 and 1 (0101010101...01)
       This interrupt source is cleared using RNG_ClearITPendingBit(RNG_IT_SEI)
       function; or
   (#) In the case of a clock error : the PLL48CLK (RNG peripheral clock source) 
       was not correctly detected (fPLL48CLK< fHCLK/16). This interrupt source is
       cleared using RNG_ClearITPendingBit(RNG_IT_CEI) function.
       -@- note In this case, User have to check that the clock controller is 
           correctly configured to provide the RNG clock. 

 *** Managing the RNG controller events : ***
 ============================================
 [..] The user should identify which mode will be used in his application to manage 
      the RNG controller events: Polling mode or Interrupt mode.
  
   (#) In the Polling Mode it is advised to use the following functions:
       (++) RNG_GetFlagStatus() : to check if flags events occur. 
       (++) RNG_ClearFlag()     : to clear the flags events.
  
       -@@- RNG_FLAG_DRDY can not be cleared by RNG_ClearFlag(). it is cleared only 
            by reading the Random number data.      
  
   (#)  In the Interrupt Mode it is advised to use the following functions:
        (++) RNG_ITConfig()       : to enable or disable the interrupt source.
        (++) RNG_GetITStatus()    : to check if Interrupt occurs.
        (++) RNG_ClearITPendingBit() : to clear the Interrupt pending Bit 
             (corresponding Flag). 
  
@endverbatim
  * @{
  */ 

/**
  * @brief  Enables or disables the RNG interrupt.
  * @note   The RNG provides 3 interrupt sources,
  *           - Computed data is ready event (DRDY), and           
  *           - Seed error Interrupt (SEI) and 
  *           - Clock error Interrupt (CEI), 
  *         all these interrupts sources are enabled by setting the IE bit in 
  *         CR register. However, each interrupt have its specific status bit
  *         (see RNG_GetITStatus() function) and clear bit except the DRDY event
  *         (see RNG_ClearITPendingBit() function).
  * @param  NewState: new state of the RNG interrupt.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RNG_ITConfig(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the RNG interrupt */
    RNG->CR |= RNG_CR_IE;
  }
  else
  {
    /* Disable the RNG interrupt */
    RNG->CR &= ~RNG_CR_IE;
  }
}

/**
  * @brief  Checks whether the specified RNG flag is set or not.
  * @param  RNG_FLAG: specifies the RNG flag to check.
  *          This parameter can be one of the following values:
  *            @arg RNG_FLAG_DRDY: Data Ready flag.
  *            @arg RNG_FLAG_CECS: Clock Error Current flag.
  *            @arg RNG_FLAG_SECS: Seed Error Current flag.
  * @retval The new state of RNG_FLAG (SET or RESET).
  */
FlagStatus RNG_GetFlagStatus(uint8_t RNG_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RNG_GET_FLAG(RNG_FLAG));

  /* Check the status of the specified RNG flag */
  if ((RNG->SR & RNG_FLAG) != (uint8_t)RESET)
  {
    /* RNG_FLAG is set */
    bitstatus = SET;
  }
  else
  {
    /* RNG_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the RNG_FLAG status */
  return  bitstatus;
}


/**
  * @brief  Clears the RNG flags.
  * @param  RNG_FLAG: specifies the flag to clear. 
  *          This parameter can be any combination of the following values:
  *            @arg RNG_FLAG_CECS: Clock Error Current flag.
  *            @arg RNG_FLAG_SECS: Seed Error Current flag.
  * @note   RNG_FLAG_DRDY can not be cleared by RNG_ClearFlag() function. 
  *         This flag is cleared only by reading the Random number data (using 
  *         RNG_GetRandomNumber() function).                           
  * @retval None
  */
void RNG_ClearFlag(uint8_t RNG_FLAG)
{
  /* Check the parameters */
  assert_param(IS_RNG_CLEAR_FLAG(RNG_FLAG));
  /* Clear the selected RNG flags */
  RNG->SR = ~(uint32_t)(((uint32_t)RNG_FLAG) << 4);
}

/**
  * @brief  Checks whether the specified RNG interrupt has occurred or not.
  * @param  RNG_IT: specifies the RNG interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg RNG_IT_CEI: Clock Error Interrupt.
  *            @arg RNG_IT_SEI: Seed Error Interrupt.                   
  * @retval The new state of RNG_IT (SET or RESET).
  */
ITStatus RNG_GetITStatus(uint8_t RNG_IT)
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RNG_GET_IT(RNG_IT));

  /* Check the status of the specified RNG interrupt */
  if ((RNG->SR & RNG_IT) != (uint8_t)RESET)
  {
    /* RNG_IT is set */
    bitstatus = SET;
  }
  else
  {
    /* RNG_IT is reset */
    bitstatus = RESET;
  }
  /* Return the RNG_IT status */
  return bitstatus;
}


/**
  * @brief  Clears the RNG interrupt pending bit(s).
  * @param  RNG_IT: specifies the RNG interrupt pending bit(s) to clear.
  *          This parameter can be any combination of the following values:
  *            @arg RNG_IT_CEI: Clock Error Interrupt.
  *            @arg RNG_IT_SEI: Seed Error Interrupt.
  * @retval None
  */
void RNG_ClearITPendingBit(uint8_t RNG_IT)
{
  /* Check the parameters */
  assert_param(IS_RNG_IT(RNG_IT));

  /* Clear the selected RNG interrupt pending bit */
  RNG->SR = (uint8_t)~RNG_IT;
}
/**
  * @}
  */ 
  
/**
  * @}
  */ 

/**
  * @}
  */ 

/**
  * @}
  */ 


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
  ******************************************************************************
  * @file    stm32f4xx_rtc.c
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the Real-Time Clock (RTC) peripheral:
  *           + Initialization
  *           + Calendar (Time and Date) configuration
  *           + Alarms (Alarm A and Alarm B) configuration
  *           + WakeUp Timer configuration
  *           + Daylight Saving configuration
  *           + Output pin Configuration
  *           + Coarse digital Calibration configuration
  *           + Smooth digital Calibration configuration
  *           + TimeStamp configuration
  *           + Tampers configuration
  *           + Backup Data Registers configuration
  *           + Shift control synchronisation    
  *           + RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
  *           + Interrupts and flags management
  *
@verbatim

 ===================================================================
              ##### Backup Domain Operating Condition #####
 ===================================================================
 [..] The real-time clock (RTC), the RTC backup registers, and the backup 
      SRAM (BKP SRAM) can be powered from the VBAT voltage when the main 
      VDD supply is powered off.
      To retain the content of the RTC backup registers, backup SRAM, and supply 
      the RTC when VDD is turned off, VBAT pin can be connected to an optional 
      standby voltage supplied by a battery or by another source.

 [..] To allow the RTC to operate even when the main digital supply (VDD) is turned
      off, the VBAT pin powers the following blocks:
   (#) The RTC
   (#) The LSE oscillator
   (#) The backup SRAM when the low power backup regulator is enabled
   (#) PC13 to PC15 I/Os, plus PI8 I/O (when available)
  
 [..] When the backup domain is supplied by VDD (analog switch connected to VDD),
      the following functions are available:
   (#) PC14 and PC15 can be used as either GPIO or LSE pins
   (#) PC13 can be used as a GPIO or as the RTC_AF1 pin
   (#) PI8 can be used as a GPIO or as the RTC_AF2 pin
  
 [..] When the backup domain is supplied by VBAT (analog switch connected to VBAT 
      because VDD is not present), the following functions are available:
   (#) PC14 and PC15 can be used as LSE pins only
   (#) PC13 can be used as the RTC_AF1 pin 
   (#) PI8 can be used as the RTC_AF2 pin
  
            
                   ##### Backup Domain Reset #####
 ===================================================================
 [..] The backup domain reset sets all RTC registers and the RCC_BDCR register 
      to their reset values. The BKPSRAM is not affected by this reset. The only
      way of resetting the BKPSRAM is through the Flash interface by requesting 
      a protection level change from 1 to 0.
 [..] A backup domain reset is generated when one of the following events occurs:
   (#) Software reset, triggered by setting the BDRST bit in the 
       RCC Backup domain control register (RCC_BDCR). You can use the
       RCC_BackupResetCmd().
   (#) VDD or VBAT power on, if both supplies have previously been powered off.
  

                   ##### Backup Domain Access #####
 ===================================================================
 [..] After reset, the backup domain (RTC registers, RTC backup data 
      registers and backup SRAM) is protected against possible unwanted write 
      accesses. 
 [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
   (+) Enable the Power Controller (PWR) APB1 interface clock using the
       RCC_APB1PeriphClockCmd() function.
   (+) Enable access to RTC domain using the PWR_BackupAccessCmd() function.
   (+) Select the RTC clock source using the RCC_RTCCLKConfig() function.
   (+) Enable RTC Clock using the RCC_RTCCLKCmd() function.
  
  
                  ##### How to use RTC Driver #####
 ===================================================================
 [..] 
   (+) Enable the RTC domain access (see description in the section above)
   (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour 
       format using the RTC_Init() function.
  
 *** Time and Date configuration ***
 ===================================
 [..] 
   (+) To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
       and RTC_SetDate() functions.
   (+) To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate() functions.
   (+) Use the RTC_DayLightSavingConfig() function to add or sub one
       hour to the RTC Calendar.    
  
 *** Alarm configuration ***
 ===========================
 [..]
   (+) To configure the RTC Alarm use the RTC_SetAlarm() function.
   (+) Enable the selected RTC Alarm using the RTC_AlarmCmd() function
   (+) To read the RTC Alarm, use the RTC_GetAlarm() function.
   (+) To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
  
 *** RTC Wakeup configuration ***
 ================================
 [..] 
   (+) Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
       function.
   (+) Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() function  
   (+) Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
   (+) To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
       function.
  
 *** Outputs configuration ***
 =============================
 [..] The RTC has 2 different outputs:
   (+) AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
       and WaKeUp signals. To output the selected RTC signal on RTC_AF1 pin, use the 
       RTC_OutputConfig() function.                
   (+) AFO_CALIB: this output is 512Hz signal or 1Hz. To output the RTC Clock on 
       RTC_AF1 pin, use the RTC_CalibOutputCmd() function.
  
 *** Smooth digital Calibration configuration ***
 ================================================    
 [..]
   (+) Configure the RTC Original Digital Calibration Value and the corresponding
       calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig() 
       function.
  
 *** Coarse digital Calibration configuration ***
 ================================================
 [..]
   (+) Configure the RTC Coarse Calibration Value and the corresponding
       sign using the RTC_CoarseCalibConfig() function.
   (+) Enable the RTC Coarse Calibration using the RTC_CoarseCalibCmd() function  
  
 *** TimeStamp configuration ***
 ===============================
 [..]
   (+) Configure the RTC_AF1 trigger and enables the RTC TimeStamp using the RTC
      _TimeStampCmd() function.
   (+) To read the RTC TimeStamp Time and Date register, use the RTC_GetTimeStamp()
       function.
   (+) To read the RTC TimeStamp SubSecond register, use the 
       RTC_GetTimeStampSubSecond() function.
   (+) The TAMPER1 alternate function can be mapped either to RTC_AF1(PC13)
       or RTC_AF2 (PI8) depending on the value of TAMP1INSEL bit in 
       RTC_TAFCR register. You can use the  RTC_TamperPinSelection() function to
       select the corresponding pin.     
  
 *** Tamper configuration ***
 ============================
 [..]
   (+) Enable the RTC Tamper using the RTC_TamperCmd() function.
   (+) Configure the Tamper filter count using RTC_TamperFilterConfig()
       function. 
   (+) Configure the RTC Tamper trigger Edge or Level according to the Tamper 
       filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() 
       function.
   (+) Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
       function.
   (+) Configure the Tamper precharge or discharge duration using 
       RTC_TamperPinsPrechargeDuration() function.
   (+) Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
   (+) Enable the Time stamp on Tamper detection event using  
       TC_TSOnTamperDetecCmd() function.
   (+) The TIMESTAMP alternate function can be mapped to either RTC_AF1 
       or RTC_AF2 depending on the value of the TSINSEL bit in the RTC_TAFCR 
       register. You can use the  RTC_TimeStampPinSelection() function to select 
       the corresponding pin. 
  
 *** Backup Data Registers configuration ***
 ===========================================
 [..]
   (+) To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
       function.  
   (+) To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
       function.
   

                  ##### RTC and low power modes #####
 ===================================================================
 [..] The MCU can be woken up from a low power mode by an RTC alternate 
      function.
 [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
      RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
      These RTC alternate functions can wake up the system from the Stop and 
      Standby lowpower modes.
 [..] The system can also wake up from low power modes without depending 
      on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
      or the RTC wakeup events.
 [..] The RTC provides a programmable time base for waking up from the 
      Stop or Standby mode at regular intervals.
      Wakeup from STOP and Standby modes is possible only when the RTC clock source
      is LSE or LSI.
  

          ##### Selection of RTC_AF1 alternate functions #####
 ===================================================================
 [..] The RTC_AF1 pin (PC13) can be used for the following purposes:
   (+) AFO_ALARM output
   (+) AFO_CALIB output
   (+) AFI_TAMPER
   (+) AFI_TIMESTAMP
 
 [..]   
   +-------------------------------------------------------------------------------------------------------------+
   |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
   |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
   |  and function   |          |          |           |              | selection  |  selection   |Configuration |
   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
   |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
   |   output OD     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      0       |
   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
   |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
   |   output PP     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      1       |
   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
   | Calibration out |          |          |           |              |    Don't   |     Don't    |              |
   |   output PP     |     0    |    1     |Don't care | Don't care   |    care    |     care     |  Don't care  |
   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
   |  TAMPER input   |          |          |           |              |            |     Don't    |              |
   |   floating      |     0    |    0     |     1     |      0       |      0     |     care     |  Don't care  |
   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
   |  TIMESTAMP and  |          |          |           |              |            |              |              |
   |  TAMPER input   |     0    |    0     |     1     |      1       |      0     |      0       |  Don't care  |
   |   floating      |          |          |           |              |            |              |              |
   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
   | TIMESTAMP input |          |          |           |              |    Don't   |              |              |
   |    floating     |     0    |    0     |     0     |      1       |    care    |      0       |  Don't care  |
   |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
   |  Standard GPIO  |     0    |    0     |     0     |      0       | Don't care |  Don't care  |  Don't care  |
   +-------------------------------------------------------------------------------------------------------------+

            
        #####  Selection of RTC_AF2 alternate functions #####
 ===================================================================
 [..] The RTC_AF2 pin (PI8) can be used for the following purposes:
   (+) AFI_TAMPER
   (+) AFI_TIMESTAMP
 [..]
   +---------------------------------------------------------------------------------------+
   |     Pin         |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
   |  configuration  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
   |  and function   |           |              | selection  |  selection   |Configuration |
   |-----------------|-----------|--------------|------------|--------------|--------------|
   |  TAMPER input   |           |              |            |     Don't    |              |
   |   floating      |     1     |      0       |      1     |     care     |  Don't care  |
   |-----------------|-----------|--------------|------------|--------------|--------------|
   |  TIMESTAMP and  |           |              |            |              |              |
   |  TAMPER input   |     1     |      1       |      1     |      1       |  Don't care  |
   |   floating      |           |              |            |              |              |
   |-----------------|-----------|--------------|------------|--------------|--------------|
   | TIMESTAMP input |           |              |    Don't   |              |              |
   |    floating     |     0     |      1       |    care    |      1       |  Don't care  |
   |-----------------|-----------|--------------|------------|--------------|--------------|
   |  Standard GPIO  |     0     |      0       | Don't care |  Don't care  |  Don't care  |
   +---------------------------------------------------------------------------------------+   
 
     
@endverbatim
  
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_rtc.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @defgroup RTC 
  * @brief RTC driver modules
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

/* Masks Definition */
#define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
#define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
#define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
#define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
#define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
                                            RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
                                            RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
                                            RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F | \
                                            RTC_FLAG_RECALPF | RTC_FLAG_SHPF))

#define INITMODE_TIMEOUT         ((uint32_t) 0x00010000)
#define SYNCHRO_TIMEOUT          ((uint32_t) 0x00020000)
#define RECALPF_TIMEOUT          ((uint32_t) 0x00020000)
#define SHPF_TIMEOUT             ((uint32_t) 0x00001000)

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
static uint8_t RTC_ByteToBcd2(uint8_t Value);
static uint8_t RTC_Bcd2ToByte(uint8_t Value);

/* Private functions ---------------------------------------------------------*/

/** @defgroup RTC_Private_Functions
  * @{
  */ 

/** @defgroup RTC_Group1 Initialization and Configuration functions
 *  @brief   Initialization and Configuration functions 
 *
@verbatim   
 ===============================================================================
             ##### Initialization and Configuration functions #####
 ===============================================================================
 
 [..] This section provide functions allowing to initialize and configure the RTC
      Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
      Write protection, enter and exit the RTC initialization mode, RTC registers
      synchronization check and reference clock detection enable.
  
   (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
       split into 2 programmable prescalers to minimize power consumption.
       (++) A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
       (++) When both prescalers are used, it is recommended to configure the 
            asynchronous prescaler to a high value to minimize consumption.

   (#) All RTC registers are Write protected. Writing to the RTC registers
       is enabled by writing a key into the Write Protection register, RTC_WPR.

   (#) To Configure the RTC Calendar, user application should enter initialization
       mode. In this mode, the calendar counter is stopped and its value can be 
       updated. When the initialization sequence is complete, the calendar restarts 
       counting after 4 RTCCLK cycles.

   (#) To read the calendar through the shadow registers after Calendar initialization,
       calendar update or after wakeup from low power modes the software must first 
       clear the RSF flag. The software must then wait until it is set again before 
       reading the calendar, which means that the calendar registers have been 
       correctly copied into the RTC_TR and RTC_DR shadow registers.
       The RTC_WaitForSynchro() function implements the above software sequence 
       (RSF clear and RSF check).

@endverbatim
  * @{
  */

/**
  * @brief  Deinitializes the RTC registers to their default reset values.
  * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
  *         registers.       
  * @param  None
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are deinitialized
  *          - ERROR: RTC registers are not deinitialized
  */
ErrorStatus RTC_DeInit(void)
{
  __IO uint32_t wutcounter = 0x00;
  uint32_t wutwfstatus = 0x00;
  ErrorStatus status = ERROR;
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR = (uint32_t)0x00000000;
    RTC->DR = (uint32_t)0x00002101;
    /* Reset All CR bits except CR[2:0] */
    RTC->CR &= (uint32_t)0x00000007;
  
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
      wutcounter++;  
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
    {
      status = ERROR;
    }
    else
    {
      /* Reset all RTC CR register bits */
      RTC->CR &= (uint32_t)0x00000000;
      RTC->WUTR = (uint32_t)0x0000FFFF;
      RTC->PRER = (uint32_t)0x007F00FF;
      RTC->CALIBR = (uint32_t)0x00000000;
      RTC->ALRMAR = (uint32_t)0x00000000;        
      RTC->ALRMBR = (uint32_t)0x00000000;
      RTC->SHIFTR = (uint32_t)0x00000000;
      RTC->CALR = (uint32_t)0x00000000;
      RTC->ALRMASSR = (uint32_t)0x00000000;
      RTC->ALRMBSSR = (uint32_t)0x00000000;
      
      /* Reset ISR register and exit initialization mode */
      RTC->ISR = (uint32_t)0x00000000;
      
      /* Reset Tamper and alternate functions configuration register */
      RTC->TAFCR = 0x00000000;
  
      if(RTC_WaitForSynchro() == ERROR)
      {
        status = ERROR;
      }
      else
      {
        status = SUCCESS;      
      }
    }
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
  
  return status;
}

/**
  * @brief  Initializes the RTC registers according to the specified parameters 
  *         in RTC_InitStruct.
  * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
  *         the configuration information for the RTC peripheral.
  * @note   The RTC Prescaler register is write protected and can be written in 
  *         initialization mode only.  
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
  ErrorStatus status = ERROR;
  
  /* Check the parameters */
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
  } 
  else
  {
    /* Clear RTC CR FMT Bit */
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);

    /* Exit Initialization mode */
    RTC_ExitInitMode();

    status = SUCCESS;    
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  
  return status;
}

/**
  * @brief  Fills each RTC_InitStruct member with its default value.
  * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
{
  /* Initialize the RTC_HourFormat member */
  RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
    
  /* Initialize the RTC_AsynchPrediv member */
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;

  /* Initialize the RTC_SynchPrediv member */
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
}

/**
  * @brief  Enables or disables the RTC registers write protection.
  * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
  *         RTC_TAFCR and RTC_BKPxR.
  * @note   Writing a wrong key reactivates the write protection.
  * @note   The protection mechanism is not affected by system reset.  
  * @param  NewState: new state of the write protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_WriteProtectionCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;   
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
    RTC->WPR = 0x53;    
  }
}

/**
  * @brief  Enters the RTC Initialization mode.
  * @note   The RTC Initialization mode is write protected, use the 
  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
  * @param  None
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode  
  */
ErrorStatus RTC_EnterInitMode(void)
{
  __IO uint32_t initcounter = 0x00;
  ErrorStatus status = ERROR;
  uint32_t initstatus = 0x00;
     
  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
      initcounter++;  
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
    
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
    {
      status = SUCCESS;
    }
    else
    {
      status = ERROR;
    }        
  }
  else
  {
    status = SUCCESS;  
  } 
    
  return (status);  
}

/**
  * @brief  Exits the RTC Initialization mode.
  * @note   When the initialization sequence is complete, the calendar restarts 
  *         counting after 4 RTCCLK cycles.  
  * @note   The RTC Initialization mode is write protected, use the 
  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
  * @param  None
  * @retval None
  */
void RTC_ExitInitMode(void)
{ 
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
}

/**
  * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
  *         synchronized with RTC APB clock.
  * @note   The RTC Resynchronization mode is write protected, use the 
  *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
  * @note   To read the calendar through the shadow registers after Calendar 
  *         initialization, calendar update or after wakeup from low power modes 
  *         the software must first clear the RSF flag. 
  *         The software must then wait until it is set again before reading 
  *         the calendar, which means that the calendar registers have been 
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
  * @param  None
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
  __IO uint32_t synchrocounter = 0;
  ErrorStatus status = ERROR;
  uint32_t synchrostatus = 0x00;

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
    
  /* Clear RSF flag */
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
    
  /* Wait the registers to be synchronised */
  do
  {
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
    synchrocounter++;  
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
    
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
  {
    status = SUCCESS;
  }
  else
  {
    status = ERROR;
  }        

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
    
  return (status); 
}

/**
  * @brief  Enables or disables the RTC reference clock detection.
  * @param  NewState: new state of the RTC reference clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{ 
  ErrorStatus status = ERROR;
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
    
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
  } 
  else
  {  
    if (NewState != DISABLE)
    {
      /* Enable the RTC reference clock detection */
      RTC->CR |= RTC_CR_REFCKON;   
    }
    else
    {
      /* Disable the RTC reference clock detection */
      RTC->CR &= ~RTC_CR_REFCKON;    
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
    
    status = SUCCESS;
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
  
  return status; 
}

/**
  * @brief  Enables or Disables the Bypass Shadow feature.
  * @note   When the Bypass Shadow is enabled the calendar value are taken 
  *         directly from the Calendar counter.
  * @param  NewState: new state of the Bypass Shadow feature.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
*/
void RTC_BypassShadowCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  if (NewState != DISABLE)
  {
    /* Set the BYPSHAD bit */
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
  }
  else
  {
    /* Reset the BYPSHAD bit */
    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
}

/**
  * @}
  */

/** @defgroup RTC_Group2 Time and Date configuration functions
 *  @brief   Time and Date configuration functions 
 *
@verbatim   
 ===============================================================================
                 ##### Time and Date configuration functions #####
 ===============================================================================  
 
 [..] This section provide functions allowing to program and read the RTC Calendar
      (Time and Date).

@endverbatim
  * @{
  */

/**
  * @brief  Set the RTC current time.
  * @param  RTC_Format: specifies the format of the entered parameters.
  *          This parameter can be  one of the following values:
  *            @arg RTC_Format_BIN:  Binary data format 
  *            @arg RTC_Format_BCD:  BCD data format
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
  *                        the time configuration information for the RTC.     
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Time register is configured
  *          - ERROR: RTC Time register is not configured
  */
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
  uint32_t tmpreg = 0;
  ErrorStatus status = ERROR;
    
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
    {
      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
      assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
    }
    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
    {
      tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
  }  

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
    {
    if(RTC_WaitForSynchro() == ERROR)
    {
      status = ERROR;
    }
    else
    {
      status = SUCCESS;
    }
  }
    else
    {
      status = SUCCESS;
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
    
  return status;
}

/**
  * @brief  Fills each RTC_TimeStruct member with its default value
  *         (Time = 00h:00min:00sec).
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
{
  /* Time = 00h:00min:00sec */
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
  RTC_TimeStruct->RTC_Hours = 0;
  RTC_TimeStruct->RTC_Minutes = 0;
  RTC_TimeStruct->RTC_Seconds = 0; 
}

/**
  * @brief  Get the RTC current Time.
  * @param  RTC_Format: specifies the format of the returned parameters.
  *          This parameter can be  one of the following values:
  *            @arg RTC_Format_BIN:  Binary data format 
  *            @arg RTC_Format_BCD:  BCD data format
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.     
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
  }
}

/**
  * @brief  Gets the RTC current Calendar Sub seconds value.
  * @note   This function freeze the Time and Date registers after reading the 
  *         SSR register.
  * @param  None
  * @retval RTC current Calendar Sub seconds value.
  */
uint32_t RTC_GetSubSecond(void)
{
  uint32_t tmpreg = 0;
  
  /* Get sub seconds values from the correspondent registers*/
  tmpreg = (uint32_t)(RTC->SSR);
  
  /* Read DR register to unfroze calendar registers */
  (void) (RTC->DR);
  
  return (tmpreg);
}

/**
  * @brief  Set the RTC current date.
  * @param  RTC_Format: specifies the format of the entered parameters.
  *          This parameter can be  one of the following values:
  *            @arg RTC_Format_BIN:  Binary data format 
  *            @arg RTC_Format_BCD:  BCD data format
  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
  *                         the date configuration information for the RTC.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Date register is configured
  *          - ERROR: RTC Date register is not configured
  */
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
  uint32_t tmpreg = 0;
  ErrorStatus status = ERROR;
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
  {
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
  }  
  if (RTC_Format == RTC_Format_BIN)
  {
    assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
    assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
    assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
  }
  else
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
    assert_param(IS_RTC_MONTH(tmpreg));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
    assert_param(IS_RTC_DATE(tmpreg));
  }
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
    {
    if(RTC_WaitForSynchro() == ERROR)
    {
      status = ERROR;
    }
    else
    {
      status = SUCCESS;
    }
  }
    else
    {
      status = SUCCESS;
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
  
  return status;
}

/**
  * @brief  Fills each RTC_DateStruct member with its default value
  *         (Monday, January 01 xx00).
  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
{
  /* Monday, January 01 xx00 */
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
  RTC_DateStruct->RTC_Date = 1;
  RTC_DateStruct->RTC_Month = RTC_Month_January;
  RTC_DateStruct->RTC_Year = 0;
}

/**
  * @brief  Get the RTC current date. 
  * @param  RTC_Format: specifies the format of the returned parameters.
  *          This parameter can be one of the following values:
  *            @arg RTC_Format_BIN: Binary data format 
  *            @arg RTC_Format_BCD: BCD data format
  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                        contain the returned current date configuration.     
  * @retval None
  */
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
  }
}

/**
  * @}
  */

/** @defgroup RTC_Group3 Alarms configuration functions
 *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
 *
@verbatim   
 ===============================================================================
         ##### Alarms A and B configuration functions #####
 ===============================================================================  
 
 [..] This section provide functions allowing to program and read the RTC Alarms.

@endverbatim
  * @{
  */

/**
  * @brief  Set the specified RTC Alarm.
  * @note   The Alarm register can only be written when the corresponding Alarm
  *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
  * @param  RTC_Format: specifies the format of the returned parameters.
  *          This parameter can be one of the following values:
  *            @arg RTC_Format_BIN: Binary data format 
  *            @arg RTC_Format_BCD: BCD data format
  * @param  RTC_Alarm: specifies the alarm to be configured.
  *          This parameter can be one of the following values:
  *            @arg RTC_Alarm_A: to select Alarm A
  *            @arg RTC_Alarm_B: to select Alarm B  
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.     
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
    {
      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
      assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
    }
    assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
    
    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
    }
    
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
    
    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
    }
    else
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
    }    
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Configure the Alarm register */
  if (RTC_Alarm == RTC_Alarm_A)
  {
    RTC->ALRMAR = (uint32_t)tmpreg;
  }
  else
  {
    RTC->ALRMBR = (uint32_t)tmpreg;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
}

/**
  * @brief  Fills each RTC_AlarmStruct member with its default value
  *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
  *         all fields are masked).
  * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;

  /* Alarm Masks Settings : Mask =  all fields are not masked */
  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
}

/**
  * @brief  Get the RTC Alarm value and masks.
  * @param  RTC_Format: specifies the format of the output parameters.
  *          This parameter can be one of the following values:
  *            @arg RTC_Format_BIN: Binary data format 
  *            @arg RTC_Format_BCD: BCD data format
  * @param  RTC_Alarm: specifies the alarm to be read.
  *          This parameter can be one of the following values:
  *            @arg RTC_Alarm_A: to select Alarm A
  *            @arg RTC_Alarm_B: to select Alarm B  
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.     
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm)); 

  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
  {
    tmpreg = (uint32_t)(RTC->ALRMAR);
  }
  else
  {
    tmpreg = (uint32_t)(RTC->ALRMBR);
  }

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);

  if (RTC_Format == RTC_Format_BIN)
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
                                                        RTC_AlarmTime.RTC_Hours);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
                                                        RTC_AlarmTime.RTC_Minutes);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
                                                        RTC_AlarmTime.RTC_Seconds);
    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
  }  
}

/**
  * @brief  Enables or disables the specified RTC Alarm.
  * @param  RTC_Alarm: specifies the alarm to be configured.
  *          This parameter can be any combination of the following values:
  *            @arg RTC_Alarm_A: to select Alarm A
  *            @arg RTC_Alarm_B: to select Alarm B  
  * @param  NewState: new state of the specified alarm.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
  __IO uint32_t alarmcounter = 0x00;
  uint32_t alarmstatus = 0x00;
  ErrorStatus status = ERROR;
    
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Configure the Alarm state */
  if (NewState != DISABLE)
  {
    RTC->CR |= (uint32_t)RTC_Alarm;

    status = SUCCESS;    
  }
  else
  { 
    /* Disable the Alarm in RTC_CR register */
    RTC->CR &= (uint32_t)~RTC_Alarm;
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
      alarmcounter++;  
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
    
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
    {
      status = ERROR;
    } 
    else
    {
      status = SUCCESS;
    }        
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  
  return status;
}

/**
  * @brief  Configure the RTC AlarmA/B Sub seconds value and mask.*
  * @note   This function is performed only when the Alarm is disabled. 
  * @param  RTC_Alarm: specifies the alarm to be configured.
  *   This parameter can be one of the following values:
  *     @arg RTC_Alarm_A: to select Alarm A
  *     @arg RTC_Alarm_B: to select Alarm B
  * @param  RTC_AlarmSubSecondValue: specifies the Sub seconds value.
  *   This parameter can be a value from 0 to 0x00007FFF.
  * @param  RTC_AlarmSubSecondMask:  specifies the Sub seconds Mask.
  *   This parameter can be any combination of the following values:
  *     @arg RTC_AlarmSubSecondMask_All    : All Alarm SS fields are masked.
  *                                          There is no comparison on sub seconds for Alarm.
  *     @arg RTC_AlarmSubSecondMask_SS14_1 : SS[14:1] are don't care in Alarm comparison.
  *                                          Only SS[0] is compared
  *     @arg RTC_AlarmSubSecondMask_SS14_2 : SS[14:2] are don't care in Alarm comparison.
  *                                          Only SS[1:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_3 : SS[14:3] are don't care in Alarm comparison.
  *                                          Only SS[2:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_4 : SS[14:4] are don't care in Alarm comparison.
  *                                          Only SS[3:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_5 : SS[14:5] are don't care in Alarm comparison.
  *                                          Only SS[4:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_6 : SS[14:6] are don't care in Alarm comparison.
  *                                          Only SS[5:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_7 : SS[14:7] are don't care in Alarm comparison.
  *                                          Only SS[6:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_8 : SS[14:8] are don't care in Alarm comparison.
  *                                          Only SS[7:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_9 : SS[14:9] are don't care in Alarm comparison.
  *                                          Only SS[8:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
  *                                          Only SS[9:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
  *                                          Only SS[10:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
  *                                          Only SS[11:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
  *                                          Only SS[12:0] are compared
  *     @arg RTC_AlarmSubSecondMask_SS14   : SS[14] is don't care in Alarm comparison.
  *                                          Only SS[13:0] are compared
  *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
  *                                          to activate alarm
  * @retval None
  */
void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
{
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* Configure the Alarm A or Alarm B Sub Second registers */
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
  
  if (RTC_Alarm == RTC_Alarm_A)
  {
    /* Configure the Alarm A Sub Second register */
    RTC->ALRMASSR = tmpreg;
  }
  else
  {
    /* Configure the Alarm B Sub Second register */
    RTC->ALRMBSSR = tmpreg;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;

}

/**
  * @brief  Gets the RTC Alarm Sub seconds value.
  * @param  RTC_Alarm: specifies the alarm to be read.
  *   This parameter can be one of the following values:
  *     @arg RTC_Alarm_A: to select Alarm A
  *     @arg RTC_Alarm_B: to select Alarm B
  * @param  None
  * @retval RTC Alarm Sub seconds value.
  */
uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
{
  uint32_t tmpreg = 0;
  
  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
  {
    tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
  }
  else
  {
    tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
  } 
  
  return (tmpreg);
}

/**
  * @}
  */

/** @defgroup RTC_Group4 WakeUp Timer configuration functions
 *  @brief   WakeUp Timer configuration functions 
 *
@verbatim   
 ===============================================================================
                 ##### WakeUp Timer configuration functions #####
 ===============================================================================  

 [..] This section provide functions allowing to program and read the RTC WakeUp.

@endverbatim
  * @{
  */

/**
  * @brief  Configures the RTC Wakeup clock source.
  * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
  *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).      
  * @param  RTC_WakeUpClock: Wakeup Clock source.
  *          This parameter can be one of the following values:
  *            @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16
  *            @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8
  *            @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4
  *            @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2
  *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
  *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
  * @retval None
  */
void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
{
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
}

/**
  * @brief  Configures the RTC Wakeup counter.
  * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
  *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).        
  * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
  *          This parameter can be a value from 0x0000 to 0xFFFF. 
  * @retval None
  */
void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
{
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
}

/**
  * @brief  Returns the RTC WakeUp timer counter value.
  * @param  None
  * @retval The RTC WakeUp Counter value.
  */
uint32_t RTC_GetWakeUpCounter(void)
{
  /* Get the counter value */
  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
}

/**
  * @brief  Enables or Disables the RTC WakeUp timer.
  * @param  NewState: new state of the WakeUp timer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
  __IO uint32_t wutcounter = 0x00;
  uint32_t wutwfstatus = 0x00;
  ErrorStatus status = ERROR;
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  if (NewState != DISABLE)
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
    status = SUCCESS;    
  }
  else
  {
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
      wutcounter++;  
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
    {
      status = ERROR;
    }
    else
    {
      status = SUCCESS;
    }    
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  
  return status;
}

/**
  * @}
  */

/** @defgroup RTC_Group5 Daylight Saving configuration functions
 *  @brief   Daylight Saving configuration functions 
 *
@verbatim   
 ===============================================================================
              ##### Daylight Saving configuration functions #####
 ===============================================================================  

 [..] This section provide functions allowing to configure the RTC DayLight Saving.

@endverbatim
  * @{
  */

/**
  * @brief  Adds or substract one hour from the current time.
  * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
  *          This parameter can be one of the following values:
  *            @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
  *            @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
  * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
  *                            in CR register to store the operation.
  *          This parameter can be one of the following values:
  *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
  *            @arg RTC_StoreOperation_Set: BCK Bit Set
  * @retval None
  */
void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
{
  /* Check the parameters */
  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
}

/**
  * @brief  Returns the RTC Day Light Saving stored operation.
  * @param  None
  * @retval RTC Day Light Saving stored operation.
  *          - RTC_StoreOperation_Reset
  *          - RTC_StoreOperation_Set       
  */
uint32_t RTC_GetStoreOperation(void)
{
  return (RTC->CR & RTC_CR_BCK);
}

/**
  * @}
  */

/** @defgroup RTC_Group6 Output pin Configuration function
 *  @brief   Output pin Configuration function 
 *
@verbatim   
 ===============================================================================
                 ##### Output pin Configuration function #####
 ===============================================================================  

 [..] This section provide functions allowing to configure the RTC Output source.

@endverbatim
  * @{
  */

/**
  * @brief  Configures the RTC output source (AFO_ALARM).
  * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
  *          This parameter can be one of the following values:
  *            @arg RTC_Output_Disable: No output selected
  *            @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
  *            @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
  *            @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
  * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
  *          This parameter can be one of the following:
  *            @arg RTC_OutputPolarity_High: The output pin is high when the 
  *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
  *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
  *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
  * @retval None
  */
void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
{
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT(RTC_Output));
  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
}

/**
  * @}
  */

/** @defgroup RTC_Group7 Digital Calibration configuration functions
 *  @brief   Coarse Calibration configuration functions 
 *
@verbatim   
 ===============================================================================
              ##### Digital Calibration configuration functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Configures the Coarse calibration parameters.
  * @param  RTC_CalibSign: specifies the sign of the coarse calibration value.
  *          This parameter can be  one of the following values:
  *            @arg RTC_CalibSign_Positive: The value sign is positive 
  *            @arg RTC_CalibSign_Negative: The value sign is negative
  * @param  Value: value of coarse calibration expressed in ppm (coded on 5 bits).
  *    
  * @note   This Calibration value should be between 0 and 63 when using negative
  *         sign with a 2-ppm step.
  *           
  * @note   This Calibration value should be between 0 and 126 when using positive
  *         sign with a 4-ppm step.
  *           
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are initialized
  *          - ERROR: RTC Coarse calibration are not initialized     
  */
ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
{
  ErrorStatus status = ERROR;
   
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
  assert_param(IS_RTC_CALIB_VALUE(Value)); 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status = ERROR;
  } 
  else
  {
    /* Set the coarse calibration value */
    RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
    /* Exit Initialization mode */
    RTC_ExitInitMode();
    
    status = SUCCESS;
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  
  return status;
}

/**
  * @brief  Enables or disables the Coarse calibration process.
  * @param  NewState: new state of the Coarse calibration.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are enabled/disabled
  *          - ERROR: RTC Coarse calibration are not enabled/disabled    
  */
ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
{
  ErrorStatus status = ERROR;
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  {
    status =  ERROR;
  }
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the Coarse Calibration */
      RTC->CR |= (uint32_t)RTC_CR_DCE;
    }
    else
    { 
      /* Disable the Coarse Calibration */
      RTC->CR &= (uint32_t)~RTC_CR_DCE;
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
    
    status = SUCCESS;
  } 
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  
  return status;
}

/**
  * @brief  Enables or disables the RTC clock to be output through the relative pin.
  * @param  NewState: new state of the digital calibration Output.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_CalibOutputCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  if (NewState != DISABLE)
  {
    /* Enable the RTC clock output */
    RTC->CR |= (uint32_t)RTC_CR_COE;
  }
  else
  { 
    /* Disable the RTC clock output */
    RTC->CR &= (uint32_t)~RTC_CR_COE;
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
}

/**
  * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
  * @param  RTC_CalibOutput : Select the Calibration output Selection .
  *   This parameter can be one of the following values:
  *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
  *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
  * @retval None
*/
void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
{
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /*clear flags before configuration */
  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
}

/**
  * @brief  Configures the Smooth Calibration Settings.
  * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
  *   This parameter can be can be one of the following values:
  *     @arg RTC_SmoothCalibPeriod_32sec : The smooth calibration period is 32s.
  *     @arg RTC_SmoothCalibPeriod_16sec : The smooth calibration period is 16s.
  *     @arg RTC_SmoothCalibPeriod_8sec  : The smooth calibartion period is 8s.
  * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
  *   This parameter can be one of the following values:
  *     @arg RTC_SmoothCalibPlusPulses_Set  : Add one RTCCLK puls every 2**11 pulses.
  *     @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
  * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
  *   This parameter can be one any value from 0 to 0x000001FF.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Calib registers are configured
  *          - ERROR: RTC Calib registers are not configured
*/
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
{
  ErrorStatus status = ERROR;
  uint32_t recalpfcount = 0;

  /* Check the parameters */
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
    {
      recalpfcount++;
    }
  }

  /* check if the calibration pending is completed or if there is no calibration operation at all*/
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
  {
    /* Configure the Smooth calibration settings */
    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);

    status = SUCCESS;
  }
  else
  {
    status = ERROR;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
  
  return (ErrorStatus)(status);
}

/**
  * @}
  */


/** @defgroup RTC_Group8 TimeStamp configuration functions
 *  @brief   TimeStamp configuration functions 
 *
@verbatim   
 ===============================================================================
                 ##### TimeStamp configuration functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Enables or Disables the RTC TimeStamp functionality with the 
  *         specified time stamp pin stimulating edge.
  * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
  *         activated.
  *          This parameter can be one of the following:
  *            @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
  *                                    edge of the related pin.
  *            @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
  *                                     falling edge of the related pin.
  * @param  NewState: new state of the TimeStamp.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
{
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));

  /* Get the new configuration */
  if (NewState != DISABLE)
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
  }
  else
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
}

/**
  * @brief  Get the RTC TimeStamp value and masks.
  * @param  RTC_Format: specifies the format of the output parameters.
  *          This parameter can be one of the following values:
  *            @arg RTC_Format_BIN: Binary data format 
  *            @arg RTC_Format_BCD: BCD data format
  * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                             contains the TimeStamp time values. 
  * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                             contains the TimeStamp date values.     
  * @retval None
  */
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
                                      RTC_DateTypeDef* RTC_StampDateStruct)
{
  uint32_t tmptime = 0, tmpdate = 0;

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);

  /* Fill the Time structure fields with the read parameters */
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
  }
}

/**
  * @brief  Get the RTC timestamp Sub seconds value.
  * @param  None
  * @retval RTC current timestamp Sub seconds value.
  */
uint32_t RTC_GetTimeStampSubSecond(void)
{
  /* Get timestamp sub seconds values from the correspondent registers */
  return (uint32_t)(RTC->TSSSR);
}

/**
  * @}
  */

/** @defgroup RTC_Group9 Tampers configuration functions
 *  @brief   Tampers configuration functions 
 *
@verbatim   
 ===============================================================================
                 ##### Tampers configuration functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Configures the select Tamper pin edge.
  * @param  RTC_Tamper: Selected tamper pin.
  *          This parameter can be RTC_Tamper_1.
  * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
  *         stimulates tamper event. 
  *   This parameter can be one of the following values:
  *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
  *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.
  *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
  *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
  * @retval None
  */
void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
  }
  else
  { 
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
  }  
}

/**
  * @brief  Enables or Disables the Tamper detection.
  * @param  RTC_Tamper: Selected tamper pin.
  *          This parameter can be RTC_Tamper_1.
  * @param  NewState: new state of the tamper pin.
  *          This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
  }
  else
  {
    /* Disable the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
  }  
}

/**
  * @brief  Configures the Tampers Filter.
  * @param  RTC_TamperFilter: Specifies the tampers filter.
  *   This parameter can be one of the following values:
  *     @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
  *     @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
  *                                    samples at the active level 
  *     @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
  *                                    samples at the active level
  *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
  *                                    samples at the active level 
  * @retval None
  */
void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   
  /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
}

/**
  * @brief  Configures the Tampers Sampling Frequency.
  * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
  *   This parameter can be one of the following values:
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 32768
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 16384
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 8192
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 4096
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 2048
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 1024
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 512  
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 256  
  * @retval None
  */
void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
 
  /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
}

/**
  * @brief  Configures the Tampers Pins input Precharge Duration.
  * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
  *         Precharge Duration.
  *   This parameter can be one of the following values:
  *     @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are precharged before sampling during 1 RTCCLK cycle
  *     @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are precharged before sampling during 2 RTCCLK cycle
  *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are precharged before sampling during 4 RTCCLK cycle    
  *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are precharged before sampling during 8 RTCCLK cycle
  * @retval None
  */
void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   
  /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
}

/**
  * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
  * @note   The timestamp is valid even the TSE bit in tamper control register 
  *         is reset.   
  * @param  NewState: new state of the timestamp on tamper event.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
  }
  else
  {
    /* Tamper detection does not cause a timestamp to be saved */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
  }
}

/**
  * @brief  Enables or Disables the Precharge of Tamper pin.
  * @param  NewState: new state of tamper pull up.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperPullUpCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
  }
  else
  {
    /* Disable precharge of the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
  } 
}

/**
  * @}
  */

/** @defgroup RTC_Group10 Backup Data Registers configuration functions
 *  @brief   Backup Data Registers configuration functions  
 *
@verbatim   
 ===============================================================================
             ##### Backup Data Registers configuration functions ##### 
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Writes a data in a specified RTC Backup data register.
  * @param  RTC_BKP_DR: RTC Backup data Register number.
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
  *                          specify the register.
  * @param  Data: Data to be written in the specified RTC Backup data register.                     
  * @retval None
  */
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
{
  __IO uint32_t tmp = 0;
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
  tmp += (RTC_BKP_DR * 4);

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
}

/**
  * @brief  Reads data from the specified RTC Backup data Register.
  * @param  RTC_BKP_DR: RTC Backup data Register number.
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
  *                          specify the register.                   
  * @retval None
  */
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
{
  __IO uint32_t tmp = 0;
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
  tmp += (RTC_BKP_DR * 4);
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
}

/**
  * @}
  */

/** @defgroup RTC_Group11 RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions
 *  @brief   RTC Tamper and TimeStamp Pins Selection and Output Type Config 
 *           configuration functions  
 *
@verbatim   
 ==================================================================================================
 ##### RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions ##### 
 ==================================================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Selects the RTC Tamper Pin.
  * @param  RTC_TamperPin: specifies the RTC Tamper Pin.
  *          This parameter can be one of the following values:
  *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
  *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
  * @retval None
  */
void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
{
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
  RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
}

/**
  * @brief  Selects the RTC TimeStamp Pin.
  * @param  RTC_TimeStampPin: specifies the RTC TimeStamp Pin.
  *          This parameter can be one of the following values:
  *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
  *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
  * @retval None
  */
void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
{
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
  RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
}

/**
  * @brief  Configures the RTC Output Pin mode. 
  * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
  *          This parameter can be one of the following values:
  *            @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
  *                                    Open Drain mode.
  *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
  *                                    Push Pull mode.    
  * @retval None
  */
void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
{
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
}

/**
  * @}
  */

/** @defgroup RTC_Group12 Shift control synchronisation functions
 *  @brief   Shift control synchronisation functions 
 *
@verbatim   
 ===============================================================================
              ##### Shift control synchronisation functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Configures the Synchronization Shift Control Settings.
  * @note   When REFCKON is set, firmware must not write to Shift control register 
  * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
  *   This parameter can be one of the following values :
  *     @arg RTC_ShiftAdd1S_Set  : Add one second to the clock calendar. 
  *     @arg RTC_ShiftAdd1S_Reset: No effect.
  * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
  *         This parameter can be one any value from 0 to 0x7FFF.
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Shift registers are configured
  *          - ERROR: RTC Shift registers are not configured
*/
ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
{
  ErrorStatus status = ERROR;
  uint32_t shpfcount = 0;

  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
    {
      shpfcount++;
    }
  }

  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
  {
    /* check if the reference clock detection is disabled */
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
    {
      /* Configure the Shift settings */
      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
    
      if(RTC_WaitForSynchro() == ERROR)
      {
        status = ERROR;
      }
      else
      {
        status = SUCCESS;
      }
    }
    else
    {
      status = ERROR;
    }
  }
  else
  {
    status = ERROR;
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
  
  return (ErrorStatus)(status);
}

/**
  * @}
  */

/** @defgroup RTC_Group13 Interrupts and flags management functions
 *  @brief   Interrupts and flags management functions  
 *
@verbatim   
 ===============================================================================
              ##### Interrupts and flags management functions #####
 ===============================================================================  
 [..] All RTC interrupts are connected to the EXTI controller.
 
   (+) To enable the RTC Alarm interrupt, the following sequence is required:
       (++) Configure and enable the EXTI Line 17 in interrupt mode and select 
            the rising edge sensitivity using the EXTI_Init() function.
       (++) Configure and enable the RTC_Alarm IRQ channel in the NVIC using the 
            NVIC_Init() function.
       (++) Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B) using
            the RTC_SetAlarm() and RTC_AlarmCmd() functions.

   (+) To enable the RTC Wakeup interrupt, the following sequence is required:
       (++) Configure and enable the EXTI Line 22 in interrupt mode and select the
            rising edge sensitivity using the EXTI_Init() function.
       (++) Configure and enable the RTC_WKUP IRQ channel in the NVIC using the 
            NVIC_Init() function.
       (++) Configure the RTC to generate the RTC wakeup timer event using the 
            RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() 
            functions.

   (+) To enable the RTC Tamper interrupt, the following sequence is required:
       (++) Configure and enable the EXTI Line 21 in interrupt mode and select 
            the rising edge sensitivity using the EXTI_Init() function.
       (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the
            NVIC_Init() function.
       (++) Configure the RTC to detect the RTC tamper event using the 
            RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.

   (+) To enable the RTC TimeStamp interrupt, the following sequence is required:
       (++) Configure and enable the EXTI Line 21 in interrupt mode and select the
            rising edge sensitivity using the EXTI_Init() function.
       (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the 
            NVIC_Init() function.
       (++) Configure the RTC to detect the RTC time stamp event using the 
            RTC_TimeStampCmd() functions.

@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the specified RTC interrupts.
  * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
  *          This parameter can be any combination of the following values:
  *            @arg RTC_IT_TS:  Time Stamp interrupt mask
  *            @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
  *            @arg RTC_IT_ALRB:  Alarm B interrupt mask
  *            @arg RTC_IT_ALRA:  Alarm A interrupt mask
  *            @arg RTC_IT_TAMP: Tamper event interrupt mask
  * @param  NewState: new state of the specified RTC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  RTC->WPR = 0x53;

  if (NewState != DISABLE)
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
  }
  else
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
}

/**
  * @brief  Checks whether the specified RTC flag is set or not.
  * @param  RTC_FLAG: specifies the flag to check.
  *          This parameter can be one of the following values:
  *            @arg RTC_FLAG_RECALPF: RECALPF event flag.
  *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
  *            @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
  *            @arg RTC_FLAG_TSF: Time Stamp event flag
  *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
  *            @arg RTC_FLAG_ALRBF: Alarm B flag
  *            @arg RTC_FLAG_ALRAF: Alarm A flag
  *            @arg RTC_FLAG_INITF: Initialization mode flag
  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
  *            @arg RTC_FLAG_INITS: Registers Configured flag
  *            @arg RTC_FLAG_SHPF: Shift operation pending flag.
  *            @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
  *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
  *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
  * @retval The new state of RTC_FLAG (SET or RESET).
  */
FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
{
  FlagStatus bitstatus = RESET;
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
  
  /* Get all the flags */
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
  
  /* Return the status of the flag */
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}

/**
  * @brief  Clears the RTC's pending flags.
  * @param  RTC_FLAG: specifies the RTC flag to clear.
  *          This parameter can be any combination of the following values:
  *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
  *            @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
  *            @arg RTC_FLAG_TSF: Time Stamp event flag
  *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
  *            @arg RTC_FLAG_ALRBF: Alarm B flag
  *            @arg RTC_FLAG_ALRAF: Alarm A flag
  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
  * @retval None
  */
void RTC_ClearFlag(uint32_t RTC_FLAG)
{
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));

  /* Clear the Flags in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
}

/**
  * @brief  Checks whether the specified RTC interrupt has occurred or not.
  * @param  RTC_IT: specifies the RTC interrupt source to check.
  *          This parameter can be one of the following values:
  *            @arg RTC_IT_TS: Time Stamp interrupt 
  *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
  *            @arg RTC_IT_ALRB: Alarm B interrupt 
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval The new state of RTC_IT (SET or RESET).
  */
ITStatus RTC_GetITStatus(uint32_t RTC_IT)
{
  ITStatus bitstatus = RESET;
  uint32_t tmpreg = 0, enablestatus = 0;
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}

/**
  * @brief  Clears the RTC's interrupt pending bits.
  * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
  *          This parameter can be any combination of the following values:
  *            @arg RTC_IT_TS: Time Stamp interrupt 
  *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
  *            @arg RTC_IT_ALRB: Alarm B interrupt 
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval None
  */
void RTC_ClearITPendingBit(uint32_t RTC_IT)
{
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_IT(RTC_IT));

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
}

/**
  * @}
  */

/**
  * @brief  Converts a 2 digit decimal to BCD format.
  * @param  Value: Byte to be converted.
  * @retval Converted byte
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  {
    bcdhigh++;
    Value -= 10;
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
}

/**
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value: BCD value to be converted.
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
  return (tmp + (Value & (uint8_t)0x0F));
}

/**
  * @}
  */ 

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
  ******************************************************************************
  * @file    stm32f4xx_sai.c
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014  
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the Serial Audio Interface (SAI):
  *           + Initialization and Configuration
  *           + Data transfers functions
  *           + DMA transfers management
  *           + Interrupts and flags management 
  *           
  @verbatim
 ===============================================================================
                     ##### How to use this driver #####
 ===============================================================================
    [..] 
    
       (#) Enable peripheral clock using the following functions 
           RCC_APB2PeriphClockCmd(RCC_APB2Periph_SAI1, ENABLE) for SAI1
  
       (#) For each SAI Block A/B enable SCK, SD, FS and MCLK GPIO clocks 
           using RCC_AHB1PeriphClockCmd() function.
  
       (#) Peripherals alternate function: 
           (++) Connect the pin to the desired peripherals' Alternate 
                Function (AF) using GPIO_PinAFConfig() function.
           (++) Configure the desired pin in alternate function by:
                GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
           (++) Select the type, pull-up/pull-down and output speed via 
                GPIO_PuPd, GPIO_OType and GPIO_Speed members
           (++) Call GPIO_Init() function
           -@@- If an external clock source is used then the I2S CKIN pin should be 
               also configured in Alternate function Push-pull pull-up mode.
                
      (#) The SAI clock can be generated from different clock source :
          PLL I2S, PLL SAI or external clock source.
          (++) The PLL I2S is configured using the following functions RCC_PLLI2SConfig(), 
               RCC_PLLI2SCmd(ENABLE), RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY) and 
               RCC_SAIPLLI2SClkDivConfig() or;
              
          (++) The PLL SAI is configured using the following functions RCC_PLLSAIConfig(), 
               RCC_PLLSAICmd(ENABLE), RCC_GetFlagStatus(RCC_FLAG_PLLSAIRDY) and 
               RCC_SAIPLLSAIClkDivConfig()or;          
              
          (++) External clock source is configured using the function 
               RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly the 
               define constant I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file.      
                
      (#) Each SAI Block A or B has its own clock generator to make these two blocks 
          completely independent. The Clock generator is configured using RCC_SAIBlockACLKConfig() and 
          RCC_SAIBlockBCLKConfig() functions.
                  
      (#) Each SAI Block A or B can be configured separetely : 
          (++) Program the Master clock divider, Audio mode, Protocol, Data Length, Clock Strobing Edge, 
               Synchronous mode, Output drive and FIFO Thresold using SAI_Init() function.   
               In case of master mode, program the Master clock divider (MCKDIV) using 
               the following formula :  
               (+++) MCLK_x = SAI_CK_x / (MCKDIV * 2) with MCLK_x = 256 * FS
               (+++) FS = SAI_CK_x / (MCKDIV * 2) * 256
               (+++) MCKDIV = SAI_CK_x / FS * 512
         (++) Program the Frame Length, Frame active Length, FS Definition, FS Polarity, 
              FS Offset using SAI_FrameInit() function.    
         (++) Program the Slot First Bit Offset, Slot Size, Slot Number, Slot Active 
              using SAI_SlotInit() function. 
                   
      (#) Enable the NVIC and the corresponding interrupt using the function 
          SAI_ITConfig() if you need to use interrupt mode. 
  
      (#) When using the DMA mode 
          (++) Configure the DMA using DMA_Init() function
          (++) Active the needed channel Request using SAI_DMACmd() function
   
      (#) Enable the SAI using the SAI_Cmd() function.
   
      (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
  
      (#) The SAI has some specific functions which can be useful depending 
          on the audio protocol selected.  
          (++) Enable Mute mode when the audio block is a transmitter using SAI_MuteModeCmd()
               function and configure the value transmitted during mute using SAI_MuteValueConfig().  
          (++) Detect the Mute mode when audio block is a receiver using SAI_MuteFrameCounterConfig().             
          (++) Enable the MONO mode without any data preprocessing in memory when the number
               of slot is equal to 2 using SAI_MonoModeConfig() function.
          (++) Enable data companding algorithm (U law and A law) using SAI_CompandingModeConfig().
          (++) Choose the behavior of the SD line in output when an inactive slot is sent 
               on the data line using SAI_TRIStateConfig() function.   
  [..]               
   (@)    In master TX mode: enabling the audio block immediately generates the bit clock 
          for the external slaves even if there is no data in the FIFO, However FS signal 
          generation is conditioned by the presence of data in the FIFO.
                 
   (@)    In master RX mode: enabling the audio block immediately generates the bit clock 
          and FS signal for the external slaves. 
                
   (@)    It is mandatory to respect the following conditions in order to avoid bad SAI behavior: 
            (+@)  First bit Offset <= (SLOT size - Data size)
            (+@)  Data size <= SLOT size
            (+@)  Number of SLOT x SLOT size = Frame length
            (+@)  The number of slots should be even when bit FSDEF in the SAI_xFRCR is set.    
  
    @endverbatim  

  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_sai.h"
#include "stm32f4xx_rcc.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @defgroup SAI 
  * @brief SAI driver modules
  * @{
  */ 

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

/* *SAI registers Masks */
#define CR1_CLEAR_MASK            ((uint32_t)0xFF07C010)
#define FRCR_CLEAR_MASK           ((uint32_t)0xFFF88000)
#define SLOTR_CLEAR_MASK          ((uint32_t)0x0000F020)

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/** @defgroup SAI_Private_Functions
  * @{
  */

/** @defgroup SAI_Group1 Initialization and Configuration functions
 *  @brief   Initialization and Configuration functions 
 *
@verbatim   
 ===============================================================================
            ##### Initialization and Configuration functions #####
 ===============================================================================  
  [..]
  This section provides a set of functions allowing to initialize the SAI Audio 
  Block Mode, Audio Protocol, Data size, Synchronization between audio block, 
  Master clock Divider, Fifo threshold, Frame configuration, slot configuration,
  Tristate mode, Companding mode and Mute mode.  
  [..] 
  The SAI_Init(), SAI_FrameInit() and SAI_SlotInit() functions follows the SAI Block
  configuration procedures for Master mode and Slave mode (details for these procedures 
  are available in reference manual(RM0090).
  
@endverbatim
  * @{
  */

/**
  * @brief  Deinitialize the SAIx peripheral registers to their default reset values.
  * @param  SAIx: To select the SAIx peripheral, where x can be the different instances 
  *                     
  * @retval None
  */
void SAI_DeInit(SAI_TypeDef* SAIx)
{
  /* Check the parameters */
  assert_param(IS_SAI_PERIPH(SAIx));

  /* Enable SAI1 reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, ENABLE);
  /* Release SAI1 from reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, DISABLE);  
}

/**
  * @brief  Initializes the SAI Block x peripheral according to the specified 
  *         parameters in the SAI_InitStruct.
  *         
  * @note   SAI clock is generated from a specific output of the PLLSAI or a specific  
  *         output of the PLLI2S or from an alternate function bypassing the PLL I2S.
  *        
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  SAI_InitStruct: pointer to a SAI_InitTypeDef structure that
  *         contains the configuration information for the specified SAI Block peripheral.             
  * @retval None
  */
void SAI_Init(SAI_Block_TypeDef* SAI_Block_x, SAI_InitTypeDef* SAI_InitStruct)
{
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  
  /* Check the SAI Block parameters */
  assert_param(IS_SAI_BLOCK_MODE(SAI_InitStruct->SAI_AudioMode));
  assert_param(IS_SAI_BLOCK_PROTOCOL(SAI_InitStruct->SAI_Protocol));
  assert_param(IS_SAI_BLOCK_DATASIZE(SAI_InitStruct->SAI_DataSize));
  assert_param(IS_SAI_BLOCK_FIRST_BIT(SAI_InitStruct->SAI_FirstBit));
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(SAI_InitStruct->SAI_ClockStrobing));
  assert_param(IS_SAI_BLOCK_SYNCHRO(SAI_InitStruct->SAI_Synchro));
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(SAI_InitStruct->SAI_OUTDRIV));
  assert_param(IS_SAI_BLOCK_NODIVIDER(SAI_InitStruct->SAI_NoDivider));
  assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(SAI_InitStruct->SAI_MasterDivider));
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(SAI_InitStruct->SAI_FIFOThreshold));

  /* SAI Block_x CR1 Configuration */
  /* Get the SAI Block_x CR1 value */
  tmpreg = SAI_Block_x->CR1;
  /* Clear MODE, PRTCFG, DS, LSBFIRST, CKSTR, SYNCEN, OUTDRIV, NODIV, and MCKDIV bits */
  tmpreg &= CR1_CLEAR_MASK;
  /* Configure SAI_Block_x: Audio mode, Protocol, Data Size, first transmitted bit, Clock strobing 
     edge, Synchronization mode, Output drive, Master Divider and FIFO level */  
  /* Set MODE bits according to SAI_AudioMode value       */
  /* Set PRTCFG bits according to SAI_Protocol value      */
  /* Set DS bits according to SAI_DataSize value          */
  /* Set LSBFIRST bit according to SAI_FirstBit value     */
  /* Set CKSTR bit according to SAI_ClockStrobing value   */
  /* Set SYNCEN bit according to SAI_Synchro value        */
  /* Set OUTDRIV bit according to SAI_OUTDRIV value       */
  /* Set NODIV bit according to SAI_NoDivider value       */
  /* Set MCKDIV bits according to SAI_MasterDivider value */
  tmpreg |= (uint32_t)(SAI_InitStruct->SAI_AudioMode     | SAI_InitStruct->SAI_Protocol  |
                       SAI_InitStruct->SAI_DataSize      | SAI_InitStruct->SAI_FirstBit  |  
                       SAI_InitStruct->SAI_ClockStrobing | SAI_InitStruct->SAI_Synchro   |  
                       SAI_InitStruct->SAI_OUTDRIV       | SAI_InitStruct->SAI_NoDivider | 
                       (uint32_t)((SAI_InitStruct->SAI_MasterDivider) << 20));
  /* Write to SAI_Block_x CR1 */
  SAI_Block_x->CR1 = tmpreg;
  
  /* SAI Block_x CR2 Configuration */
  /* Get the SAIBlock_x CR2 value */
  tmpreg = SAI_Block_x->CR2;
  /* Clear FTH bits */
  tmpreg &= ~(SAI_xCR2_FTH);
  /* Configure the FIFO Level */
  /* Set FTH bits according to SAI_FIFOThreshold value */ 
  tmpreg |= (uint32_t)(SAI_InitStruct->SAI_FIFOThreshold);
  /* Write to SAI_Block_x CR2 */
  SAI_Block_x->CR2 = tmpreg;
}

/**
  * @brief  Initializes the SAI Block Audio frame according to the specified 
  *         parameters in the SAI_FrameInitStruct.
  *         
  * @note   this function has no meaning if the AC'97 or SPDIF audio protocol 
  *         are selected. 
  *               
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  SAI_FrameInitStruct: pointer to an SAI_FrameInitTypeDef structure that
  *         contains the configuration of audio frame for a specified SAI Block                       
  * @retval None
  */
void SAI_FrameInit(SAI_Block_TypeDef* SAI_Block_x, SAI_FrameInitTypeDef* SAI_FrameInitStruct)
{
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  
  /* Check the SAI Block frame parameters */
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(SAI_FrameInitStruct->SAI_FrameLength));
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(SAI_FrameInitStruct->SAI_ActiveFrameLength));
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(SAI_FrameInitStruct->SAI_FSDefinition));
  assert_param(IS_SAI_BLOCK_FS_POLARITY(SAI_FrameInitStruct->SAI_FSPolarity));
  assert_param(IS_SAI_BLOCK_FS_OFFSET(SAI_FrameInitStruct->SAI_FSOffset));

  /* SAI Block_x FRCR Configuration */
  /* Get the SAI Block_x FRCR value */
  tmpreg = SAI_Block_x->FRCR;
  /* Clear FRL, FSALL, FSDEF, FSPOL, FSOFF bits */
  tmpreg &= FRCR_CLEAR_MASK;
  /* Configure SAI_Block_x Frame: Frame Length, Active Frame Length, Frame Synchronization
     Definition, Frame Synchronization Polarity and Frame Synchronization Polarity */
  /* Set FRL bits according to SAI_FrameLength value         */
  /* Set FSALL bits according to SAI_ActiveFrameLength value */
  /* Set FSDEF bit according to SAI_FSDefinition value       */
  /* Set FSPOL bit according to SAI_FSPolarity value         */
  /* Set FSOFF bit according to SAI_FSOffset value           */
  tmpreg |= (uint32_t)((uint32_t)(SAI_FrameInitStruct->SAI_FrameLength - 1)  | 
                       SAI_FrameInitStruct->SAI_FSOffset     | 
                       SAI_FrameInitStruct->SAI_FSDefinition |    
                       SAI_FrameInitStruct->SAI_FSPolarity   |                        
                       (uint32_t)((SAI_FrameInitStruct->SAI_ActiveFrameLength - 1) << 8));
                       
  /* Write to SAI_Block_x FRCR */
  SAI_Block_x->FRCR = tmpreg;
}

/**
  * @brief  Initializes the SAI Block audio Slot according to the specified 
  *         parameters in the SAI_SlotInitStruct.
  *         
  * @note   this function has no meaning if the AC'97 or SPDIF audio protocol 
  *         are selected.
  *               
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  SAI_SlotInitStruct: pointer to an SAI_SlotInitTypeDef structure that
  *         contains the configuration of audio slot for a specified SAI Block                      
  * @retval None
  */
void SAI_SlotInit(SAI_Block_TypeDef* SAI_Block_x, SAI_SlotInitTypeDef* SAI_SlotInitStruct)
{
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  
  /* Check the SAI Block Slot parameters */
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(SAI_SlotInitStruct->SAI_FirstBitOffset));
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(SAI_SlotInitStruct->SAI_SlotSize));
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(SAI_SlotInitStruct->SAI_SlotNumber));
  assert_param(IS_SAI_SLOT_ACTIVE(SAI_SlotInitStruct->SAI_SlotActive));

  /* SAI Block_x SLOTR Configuration */
  /* Get the SAI Block_x SLOTR value */
  tmpreg = SAI_Block_x->SLOTR;
  /* Clear FBOFF, SLOTSZ, NBSLOT, SLOTEN bits */
  tmpreg &= SLOTR_CLEAR_MASK;
  /* Configure SAI_Block_x Slot: First bit offset, Slot size, Number of Slot in  
     audio frame and slots activated in audio frame */
  /* Set FBOFF bits according to SAI_FirstBitOffset value  */
  /* Set SLOTSZ bits according to SAI_SlotSize value       */
  /* Set NBSLOT bits according to SAI_SlotNumber value     */
  /* Set SLOTEN bits according to SAI_SlotActive value     */
  tmpreg |= (uint32_t)(SAI_SlotInitStruct->SAI_FirstBitOffset | 
                       SAI_SlotInitStruct->SAI_SlotSize       | 
                       SAI_SlotInitStruct->SAI_SlotActive     |    
                       (uint32_t)((SAI_SlotInitStruct->SAI_SlotNumber - 1) <<  8));
                       
  /* Write to SAI_Block_x SLOTR */
  SAI_Block_x->SLOTR = tmpreg;
}

/**
  * @brief  Fills each SAI_InitStruct member with its default value.
  * @param  SAI_InitStruct: pointer to a SAI_InitTypeDef structure which will 
  *         be initialized.  
  * @retval None
  */
void SAI_StructInit(SAI_InitTypeDef* SAI_InitStruct)
{
  /* Reset SAI init structure parameters values */
  /* Initialize the SAI_AudioMode member */
  SAI_InitStruct->SAI_AudioMode = SAI_Mode_MasterTx;
  /* Initialize the SAI_Protocol member */
  SAI_InitStruct->SAI_Protocol = SAI_Free_Protocol;
  /* Initialize the SAI_DataSize member */
  SAI_InitStruct->SAI_DataSize = SAI_DataSize_8b;
  /* Initialize the SAI_FirstBit member */
  SAI_InitStruct->SAI_FirstBit = SAI_FirstBit_MSB;
  /* Initialize the SAI_ClockStrobing member */
  SAI_InitStruct->SAI_ClockStrobing = SAI_ClockStrobing_FallingEdge;
  /* Initialize the SAI_Synchro member */
  SAI_InitStruct->SAI_Synchro = SAI_Asynchronous;
  /* Initialize the SAI_OUTDRIV member */
  SAI_InitStruct->SAI_OUTDRIV = SAI_OutputDrive_Disabled;
  /* Initialize the SAI_NoDivider member */
  SAI_InitStruct->SAI_NoDivider = SAI_MasterDivider_Enabled;
  /* Initialize the SAI_MasterDivider member */
  SAI_InitStruct->SAI_MasterDivider = 0;
  /* Initialize the SAI_FIFOThreshold member */
  SAI_InitStruct->SAI_FIFOThreshold = SAI_Threshold_FIFOEmpty;
}

/**
  * @brief  Fills each SAI_FrameInitStruct member with its default value.
  * @param  SAI_FrameInitStruct: pointer to a SAI_FrameInitTypeDef structure 
  *         which will be initialized.                     
  * @retval None
  */
void SAI_FrameStructInit(SAI_FrameInitTypeDef* SAI_FrameInitStruct)
{
  /* Reset SAI Frame init structure parameters values */
  /* Initialize the SAI_FrameLength member */
  SAI_FrameInitStruct->SAI_FrameLength = 8;
  /* Initialize the SAI_ActiveFrameLength member */
  SAI_FrameInitStruct->SAI_ActiveFrameLength = 1;
  /* Initialize the SAI_FSDefinition member */
  SAI_FrameInitStruct->SAI_FSDefinition = SAI_FS_StartFrame;
  /* Initialize the SAI_FSPolarity member */
  SAI_FrameInitStruct->SAI_FSPolarity = SAI_FS_ActiveLow;
  /* Initialize the SAI_FSOffset member */
  SAI_FrameInitStruct->SAI_FSOffset = SAI_FS_FirstBit;
}

/**
  * @brief  Fills each SAI_SlotInitStruct member with its default value.
  * @param  SAI_SlotInitStruct: pointer to a SAI_SlotInitTypeDef structure 
  *         which will be initialized.                     
  * @retval None
  */
void SAI_SlotStructInit(SAI_SlotInitTypeDef* SAI_SlotInitStruct)
{
  /* Reset SAI Slot init structure parameters values */
  /* Initialize the SAI_FirstBitOffset member */
  SAI_SlotInitStruct->SAI_FirstBitOffset = 0;
  /* Initialize the SAI_SlotSize member */
  SAI_SlotInitStruct->SAI_SlotSize = SAI_SlotSize_DataSize;
  /* Initialize the SAI_SlotNumber member */
  SAI_SlotInitStruct->SAI_SlotNumber = 1;
  /* Initialize the SAI_SlotActive member */
  SAI_SlotInitStruct->SAI_SlotActive = SAI_Slot_NotActive;

}

/**
  * @brief  Enables or disables the specified SAI Block peripheral.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  NewState: new state of the SAI_Block_x peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SAI_Cmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SAI peripheral */
    SAI_Block_x->CR1 |= SAI_xCR1_SAIEN;
  }
  else
  {
    /* Disable the selected SAI peripheral */
    SAI_Block_x->CR1 &= ~(SAI_xCR1_SAIEN);
  }
}

/**
  * @brief  Configures the mono mode for the selected SAI block.
  * 
  * @note  This function has a meaning only when the number of slot is equal to 2. 
  *      
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  SAI_MonoMode: specifies the SAI block mono mode.
  *          This parameter can be one of the following values:
  *            @arg SAI_MonoMode : Set mono audio mode
  *            @arg SAI_StreoMode : Set streo audio mode                       
  * @retval None
  */
void SAI_MonoModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_Mono_StreoMode)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_MONO_STREO_MODE(SAI_MonoMode));
  /* Clear MONO bit */
  SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
  /* Set new Mono Mode value */
  SAI_Block_x->CR1 |= SAI_MonoMode;
}

/**
  * @brief  Configures the TRIState managment on data line for the selected SAI block.
  * 
  * @note  This function has a meaning only when the SAI block is configured in transmitter 
  *      
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  SAI_TRIState: specifies the SAI block TRIState management.
  *          This parameter can be one of the following values:
  *            @arg SAI_Output_NotReleased : SD output line is still drived by the SAI.
  *            @arg SAI_Output_Released : SD output line is released (HI-Z)                       
  * @retval None
  */
void SAI_TRIStateConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_TRIState)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(SAI_TRIState));
  /* Clear MONO bit */
  SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
  /* Set new Mono Mode value */
  SAI_Block_x->CR1 |= SAI_MonoMode;  
  
}

/**
  * @brief  Configures the companding mode for the selected SAI block.
  * 
  * @note  The data expansion or data compression are determined by the state of
  *        SAI block selected (transmitter or receiver). 

  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.              
  * @param  SAI_CompandingMode: specifies the SAI block companding mode.
  *          This parameter can be one of the following values:
  *            @arg SAI_NoCompanding : no companding algorithm set
  *            @arg SAI_ULaw_1CPL_Companding : Set U law (algorithm 1's complement representation)
  *            @arg SAI_ALaw_1CPL_Companding : Set A law (algorithm 1's complement repesentation)  
  *            @arg SAI_ULaw_2CPL_Companding : Set U law (algorithm 2's complement representation)
  *            @arg SAI_ALaw_2CPL_Companding : Set A law (algorithm 2's complement repesentation)  
  * @retval None
  */
void SAI_CompandingModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_CompandingMode)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(SAI_CompandingMode));
  /* Clear Companding Mode bits */
  SAI_Block_x->CR2 &= ~(SAI_xCR2_COMP);
  /* Set new Companding Mode value */
  SAI_Block_x->CR2 |= SAI_CompandingMode;
}

/**
  * @brief  Enables or disables the Mute mode for the selected SAI block.
  *    
  * @note   This function has a meaning only when the audio block is transmitter
  * @note   Mute mode is applied for an entire frame for all the valid slot
  *         It becomes active at the end of an audio frame when set somewhere in a frame. 
  *         Mute mode exit occurs at the end of the frame in which the bit MUTE has been set.
  *
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  NewState: new state of the SAIx block. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SAI_MuteModeCmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SAI block mute mode */
    SAI_Block_x->CR2 |= SAI_xCR2_MUTE;
  }
  else
  {
    /* Disable the selected SAI SS output */
    SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTE);
  }
}

/**
  * @brief  Configure the mute value for the selected SAI block.
  *    
  * @note   This function has a meaning only when the audio block is transmitter
  * @note   the configuration last value sent during mute mode has only a meaning 
  *          when the number of slot is lower or equal to 2 and if the MUTE bit is set.
  *           
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  SAI_MuteValue: specifies the SAI block mute value.
  *          This parameter can be one of the following values:
  *            @arg SAI_ZeroValue : bit value 0 is sent during Mute Mode
  *            @arg SAI_LastSentValue : Last value is sent during Mute Mode  
  * @retval None
  */
void SAI_MuteValueConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteValue)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_MUTE_VALUE(SAI_MuteValue));
  
  /* Clear Mute value bits */
  SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTEVAL);
  /* Set new Mute value */
  SAI_Block_x->CR2 |= SAI_MuteValue;
}

/**
  * @brief  Enables or disables the Mute mode for the selected SAI block. 
  *
  * @note   This function has a meaning only when the audio block is Receiver
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  SAI_MuteCounter: specifies the SAI block mute value.
  *         This parameter can be a number between 0 and 63.  
 
  * @retval None
  */
void SAI_MuteFrameCounterConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteCounter)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_MUTE_COUNTER(SAI_MuteCounter));
  
  /* Clear Mute value bits */
  SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTECNT);
  /* Set new Mute value */
  SAI_Block_x->CR2 |= (SAI_MuteCounter << 7);
}

/**
  * @brief  Reinitialize the FIFO pointer
  *   
  * @note   The FIFO pointers can be reinitialized at anytime The data present 
  *         into the FIFO, if it is not empty, will be lost. 
  * 
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  * @param  NewState: new state of the selected SAI TI communication mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SAI_FlushFIFO(SAI_Block_TypeDef* SAI_Block_x)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));

  /* FIFO flush */
  SAI_Block_x->CR2 |= SAI_xCR2_FFLUSH;
}

/**
  * @}
  */

/** @defgroup SAI_Group2 Data transfers functions
 *  @brief   Data transfers functions
 *
@verbatim   
 ===============================================================================
                       ##### Data transfers functions #####
 ===============================================================================  
  [..]
  This section provides a set of functions allowing to manage the SAI data transfers.
  [..]
  In reception, data are received and then stored into an internal FIFO while 
  In transmission, data are first stored into an internal FIFO before being 
  transmitted.
  [..]
  The read access of the SAI_xDR register can be done using the SAI_ReceiveData()
  function and returns the Rx buffered value. Whereas a write access to the SAI_DR 
  can be done using SAI_SendData() function and stores the written data into 
  Tx buffer.

@endverbatim
  * @{
  */

/**
  * @brief  Returns the most recent received data by the SAI block x peripheral. 
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
  *         
  * @retval The value of the received data.
  */
uint32_t SAI_ReceiveData(SAI_Block_TypeDef* SAI_Block_x)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  
  /* Return the data in the DR register */
  return SAI_Block_x->DR;
}

/**
  * @brief  Transmits a Data through the SAI block x peripheral.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  *        
  * @param  Data: Data to be transmitted.
  * @retval None
  */
void SAI_SendData(SAI_Block_TypeDef* SAI_Block_x, uint32_t Data)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  
  /* Write in the DR register the data to be sent */
  SAI_Block_x->DR = Data;
}

/**
  * @}
  */

/** @defgroup SAI_Group3 DMA transfers management functions
 *  @brief   DMA transfers management functions
  *
@verbatim   
 ===============================================================================
                  ##### DMA transfers management functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the SAI Block x DMA interface.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
  * @param  NewState: new state of the selected SAI block DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected SAI block mute mode */
    SAI_Block_x->CR1 |= SAI_xCR1_DMAEN;
  }
  else
  {
    /* Disable the selected SAI SS output */
    SAI_Block_x->CR1 &= ~(SAI_xCR1_DMAEN);
  }
}

/**
  * @}
  */

/** @defgroup SAI_Group4 Interrupts and flags management functions
 *  @brief   Interrupts and flags management functions
  *
@verbatim   
 ===============================================================================
            ##### Interrupts and flags management functions #####
 ===============================================================================  
  [..]
  This section provides a set of functions allowing to configure the SAI Interrupts 
  sources and check or clear the flags or pending bits status.
  The user should identify which mode will be used in his application to manage 
  the communication: Polling mode, Interrupt mode or DMA mode. 
    
  *** Polling Mode ***
  ====================
  [..]
  In Polling Mode, the SAI communication can be managed by 7 flags:
     (#) SAI_FLAG_FREQ : to indicate if there is a FIFO Request to write or to read.
     (#) SAI_FLAG_MUTEDET : to indicate if a MUTE frame detected
     (#) SAI_FLAG_OVRUDR : to indicate if an Overrun or Underrun error occur
     (#) SAI_FLAG_AFSDET : to indicate if there is the detection of a audio frame 
                          synchronisation (FS) earlier than expected
     (#) SAI_FLAG_LFSDET : to indicate if there is the detection of a audio frame 
                          synchronisation (FS) later than expected              
     (#) SAI_FLAG_CNRDY : to indicate if  the codec is not ready to communicate during 
                         the reception of the TAG 0 (slot0) of the AC97 audio frame 
     (#) SAI_FLAG_WCKCFG: to indicate if wrong clock configuration in master mode 
                         error occurs.
  [..]
  In this Mode it is advised to use the following functions:
     (+) FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
     (+) void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);

  *** Interrupt Mode ***
  ======================
  [..]
  In Interrupt Mode, the SAI communication can be managed by 7 interrupt sources
  and 7 pending bits: 
  (+) Pending Bits:
     (##) SAI_IT_FREQ : to indicate if there is a FIFO Request to write or to read.
     (##) SAI_IT_MUTEDET : to indicate if a MUTE frame detected.
     (##) SAI_IT_OVRUDR : to indicate if an Overrun or Underrun error occur.
     (##) SAI_IT_AFSDET : to indicate if there is the detection of a audio frame 
                          synchronisation (FS) earlier than expected.
     (##) SAI_IT_LFSDET : to indicate if there is the detection of a audio frame 
                          synchronisation (FS) later than expected.              
     (##) SAI_IT_CNRDY : to indicate if  the codec is not ready to communicate during 
                         the reception of the TAG 0 (slot0) of the AC97 audio frame. 
     (##) SAI_IT_WCKCFG: to indicate if wrong clock configuration in master mode 
                         error occurs.

  (+) Interrupt Source:
     (##) SAI_IT_FREQ : specifies the interrupt source for FIFO Request.
     (##) SAI_IT_MUTEDET : specifies the interrupt source for MUTE frame detected.
     (##) SAI_IT_OVRUDR : specifies the interrupt source for overrun or underrun error.
     (##) SAI_IT_AFSDET : specifies the interrupt source for anticipated frame synchronization
                          detection interrupt.
     (##) SAI_IT_LFSDET : specifies the interrupt source for late frame synchronization
                          detection interrupt.             
     (##) SAI_IT_CNRDY : specifies the interrupt source for codec not ready interrupt
     (##) SAI_IT_WCKCFG: specifies the interrupt source for wrong clock configuration
                         interrupt.
  [..]                     
  In this Mode it is advised to use the following functions:
     (+) void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState);
     (+) ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
     (+) void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);

  *** DMA Mode ***
  ================
  [..]
  In DMA Mode, each SAI audio block has an independent DMA interface in order to 
  read or to write into the SAI_xDR register (to hit the internal FIFO). 
  There is one DMA channel by audio block following basic DMA request/acknowledge 
  protocol.
  [..]
  In this Mode it is advised to use the following function:
    (+) void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);
  [..]
  This section provides also functions allowing to
   (+) Check the SAI Block enable status
   (+)Check the FIFO status 
   
  *** SAI Block Enable status ***
  ===============================
  [..]
  After disabling a SAI Block, it is recommended to check (or wait until) the SAI Block 
  is effectively disabled. If a Block is disabled while an audio frame transfer is ongoing
  the current frame will be transferred and the block will be effectively disabled only at 
  the end of audio frame. 
  To monitor this state it is possible to use the following function:
    (+) FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x); 
 
  *** SAI Block FIFO status ***
  =============================
  [..]
  It is possible to monitor the FIFO status when a transfer is ongoing using the following 
  function:
    (+) uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x);
    
@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the specified SAI Block interrupts.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
  * @param  SAI_IT: specifies the SAI interrupt source to be enabled or disabled. 
  *          This parameter can be one of the following values:
  *            @arg SAI_IT_FREQ: FIFO Request interrupt mask
  *            @arg SAI_IT_MUTEDET: MUTE detection interrupt mask
  *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt mask
  *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection 
  *                                interrupt mask  
  *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt 
  *                                mask
  *            @arg SAI_IT_CNRDY: codec not ready interrupt mask
  *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt mask      
  * @param  NewState: new state of the specified SAI interrupt.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));

  if (NewState != DISABLE)
  {
    /* Enable the selected SAI Block interrupt */
    SAI_Block_x->IMR |= SAI_IT;
  }
  else
  {
    /* Disable the selected SAI Block interrupt */
    SAI_Block_x->IMR &= ~(SAI_IT);
  }
}

/**
  * @brief  Checks whether the specified SAI block x flag is set or not.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
  * @param  SAI_FLAG: specifies the SAI block flag to check. 
  *          This parameter can be one of the following values:
  *            @arg SAI_FLAG_FREQ: FIFO Request flag.  
  *            @arg SAI_FLAG_MUTEDET: MUTE detection flag.  
  *            @arg SAI_FLAG_OVRUDR: overrun/underrun flag.
  *            @arg SAI_FLAG_WCKCFG: wrong clock configuration flag.            
  *            @arg SAI_FLAG_CNRDY: codec not ready flag. 
  *            @arg SAI_FLAG_AFSDET: anticipated frame synchronization detection flag.
  *            @arg SAI_FLAG_LFSDET: late frame synchronization detection flag.
  * @retval The new state of SAI_FLAG (SET or RESET).
  */
FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
{
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_GET_FLAG(SAI_FLAG));
  
  /* Check the status of the specified SAI flag */
  if ((SAI_Block_x->SR & SAI_FLAG) != (uint32_t)RESET)
  {
    /* SAI_FLAG is set */
    bitstatus = SET;
  }
  else
  {
    /* SAI_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SAI_FLAG status */
  return  bitstatus;
}

/**
  * @brief  Clears the specified SAI Block x flag.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
  * @param  SAI_FLAG: specifies the SAI block flag to check. 
  *          This parameter can be one of the following values: 
  *            @arg SAI_FLAG_MUTEDET: MUTE detection flag.  
  *            @arg SAI_FLAG_OVRUDR: overrun/underrun flag.
  *            @arg SAI_FLAG_WCKCFG: wrong clock configuration flag.            
  *            @arg SAI_FLAG_CNRDY: codec not ready flag. 
  *            @arg SAI_FLAG_AFSDET: anticipated frame synchronization detection flag.
  *            @arg SAI_FLAG_LFSDET: late frame synchronization detection flag. 
  *  
  * @note    FREQ (FIFO Request) flag is cleared : 
  *          - When the audio block is transmitter and the FIFO is full or the FIFO   
  *            has one data (one buffer mode) depending the bit FTH in the
  *            SAI_xCR2 register.
  *          - When the audio block is receiver and the FIFO is not empty           
  *  
  * @retval None
  */
void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_CLEAR_FLAG(SAI_FLAG));
    
  /* Clear the selected SAI Block flag */
  SAI_Block_x->CLRFR |= SAI_FLAG;
}

/**
  * @brief  Checks whether the specified SAI Block x interrupt has occurred or not.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
  * @param  SAI_IT: specifies the SAI interrupt source to be enabled or disabled. 
  *          This parameter can be one of the following values:
  *            @arg SAI_IT_FREQ: FIFO Request interrupt 
  *            @arg SAI_IT_MUTEDET: MUTE detection interrupt 
  *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt 
  *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection interrupt                                    
  *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt                                
  *            @arg SAI_IT_CNRDY: codec not ready interrupt 
  *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt 
  *                
  * @retval The new state of SAI_IT (SET or RESET).
  */
ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
{
  ITStatus bitstatus = RESET;
  uint32_t  enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
  
  /* Get the SAI_IT enable bit status */
  enablestatus = (SAI_Block_x->IMR & SAI_IT) ;

  /* Check the status of the specified SAI interrupt */
  if (((SAI_Block_x->SR & SAI_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
  {
    /* SAI_IT is set */
    bitstatus = SET;
  }
  else
  {
    /* SAI_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SAI_IT status */
  return bitstatus;
}

/**
  * @brief  Clears the SAI Block x interrupt pending bit.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
  * @param  SAI_IT: specifies the SAI Block interrupt pending bit to clear. 
  *          This parameter can be one of the following values:  
  *            @arg SAI_IT_MUTEDET: MUTE detection interrupt.  
  *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt.
  *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt.            
  *            @arg SAI_IT_CNRDY: codec not ready interrupt. 
  *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection interrupt.
  *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt. 
  *  
  * @note    FREQ (FIFO Request) flag is cleared : 
  *          - When the audio block is transmitter and the FIFO is full or the FIFO   
  *            has one data (one buffer mode) depending the bit FTH in the
  *            SAI_xCR2 register.
  *          - When the audio block is receiver and the FIFO is not empty  
  *            
  * @retval None
  */
void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
{
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));

  /* Clear the selected SAI Block x interrupt pending bit */
  SAI_Block_x->CLRFR |= SAI_IT; 
}

/**
  * @brief  Returns the status of EN bit for the specified SAI Block x.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  *   
  * @note    After disabling a SAI Block, it is recommended to check (or wait until) 
  *          the SAI Block is effectively disabled. If a Block is disabled while
  *          an audio frame transfer is ongoing, the current frame will be 
  *          transferred and the block will be effectively disabled only at 
  *          the end of audio frame.  
  *      
  * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
  */
FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x)
{
  FunctionalState state = DISABLE;

  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  if ((SAI_Block_x->CR1 & (uint32_t)SAI_xCR1_SAIEN) != 0)
  {
    /* The selected SAI Block x EN bit is set (audio frame transfer is ongoing) */
    state = ENABLE;
  }
  else
  {
    /* The selected SAI Block x EN bit is cleared (SAI Block is disabled and 
        all transfers are complete) */
    state = DISABLE;
  }
  return state;
}

/**
  * @brief  Returns the current SAI Block x FIFO filled level.
  * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
  *   
  * @retval The FIFO filling state.
  *           - SAI_FIFOStatus_Empty: when FIFO is empty  
  *           - SAI_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
  *                                               and not empty.
  *           - SAI_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
  *           - SAI_FIFOStatus_HalfFull: if more than 1 half-full.
  *           - SAI_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
  *           - SAI_FIFOStatus_Full: when FIFO is full
  */
uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x)
{
  uint32_t tmpreg = 0;
 
  /* Check the parameters */
  assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
  
  /* Get the FIFO level bits */
  tmpreg = (uint32_t)((SAI_Block_x->SR & SAI_xSR_FLVL));
  
  return tmpreg;
}


/**
  * @}
  */

/**
  * @}
  */ 

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
  ******************************************************************************
  * @file    stm32f4xx_sdio.c
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the Secure digital input/output interface (SDIO) 
  *          peripheral:
  *           + Initialization and Configuration
  *           + Command path state machine (CPSM) management
  *           + Data path state machine (DPSM) management
  *           + SDIO IO Cards mode management
  *           + CE-ATA mode management
  *           + DMA transfers management
  *           + Interrupts and flags management
  *
@verbatim

 ===================================================================
                 ##### How to use this driver #####
 ===================================================================
 [..]
   (#) The SDIO clock (SDIOCLK = 48 MHz) is coming from a specific output of PLL 
       (PLL48CLK). Before to start working with SDIO peripheral make sure that the
       PLL is well configured.
       The SDIO peripheral uses two clock signals:
       (++) SDIO adapter clock (SDIOCLK = 48 MHz)
       (++) APB2 bus clock (PCLK2)
       
       -@@- PCLK2 and SDIO_CK clock frequencies must respect the following condition:
           Frequency(PCLK2) >= (3 / 8 x Frequency(SDIO_CK))
  
   (#) Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SDIO, ENABLE).
  
   (#) According to the SDIO mode, enable the GPIO clocks using 
       RCC_AHB1PeriphClockCmd() function. 
       The I/O can be one of the following configurations:
       (++) 1-bit data length: SDIO_CMD, SDIO_CK and D0.
       (++) 4-bit data length: SDIO_CMD, SDIO_CK and D[3:0].
       (++) 8-bit data length: SDIO_CMD, SDIO_CK and D[7:0].      
  
   (#) Peripheral alternate function: 
       (++) Connect the pin to the desired peripherals' Alternate Function (AF) 
           using GPIO_PinAFConfig() function
       (++) Configure the desired pin in alternate function by: 
           GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
       (++) Select the type, pull-up/pull-down and output speed via GPIO_PuPd, 
           GPIO_OType and GPIO_Speed members
       (++) Call GPIO_Init() function
  
   (#) Program the Clock Edge, Clock Bypass, Clock Power Save, Bus Wide, 
       hardware, flow control and the Clock Divider using the SDIO_Init()
       function.
  
   (#) Enable the Power ON State using the SDIO_SetPowerState(SDIO_PowerState_ON) 
       function.
                
   (#) Enable the clock using the SDIO_ClockCmd() function.
  
   (#) Enable the NVIC and the corresponding interrupt using the function 
       SDIO_ITConfig() if you need to use interrupt mode. 
  
   (#) When using the DMA mode 
       (++) Configure the DMA using DMA_Init() function
       (++) Active the needed channel Request using SDIO_DMACmd() function
  
   (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
  
   (#) To control the CPSM (Command Path State Machine) and send 
       commands to the card use the SDIO_SendCommand(), 
       SDIO_GetCommandResponse() and SDIO_GetResponse() functions. First, user has
       to fill the command structure (pointer to SDIO_CmdInitTypeDef) according 
       to the selected command to be sent.
       The parameters that should be filled are:
       (++) Command Argument
       (++) Command Index
       (++) Command Response type
       (++) Command Wait
       (++) CPSM Status (Enable or Disable).
  
       -@@- To check if the command is well received, read the SDIO_CMDRESP
           register using the SDIO_GetCommandResponse().
           The SDIO responses registers (SDIO_RESP1 to SDIO_RESP2), use the
           SDIO_GetResponse() function.
  
   (#) To control the DPSM (Data Path State Machine) and send/receive 
       data to/from the card use the SDIO_DataConfig(), SDIO_GetDataCounter(), 
       SDIO_ReadData(), SDIO_WriteData() and SDIO_GetFIFOCount() functions.
  
 *** Read Operations ***
 =======================
 [..]
   (#) First, user has to fill the data structure (pointer to
       SDIO_DataInitTypeDef) according to the selected data type to be received.
       The parameters that should be filled are:
       (++) Data TimeOut
       (++) Data Length
       (++) Data Block size
       (++) Data Transfer direction: should be from card (To SDIO)
       (++) Data Transfer mode
       (++) DPSM Status (Enable or Disable)
                                     
   (#) Configure the SDIO resources to receive the data from the card
       according to selected transfer mode (Refer to Step 8, 9 and 10).
  
   (#)  Send the selected Read command (refer to step 11).
                    
   (#) Use the SDIO flags/interrupts to check the transfer status.
  
 *** Write Operations ***
 ========================
 [..]
   (#) First, user has to fill the data structure (pointer to
       SDIO_DataInitTypeDef) according to the selected data type to be received.
       The parameters that should be filled are:
       (++) Data TimeOut
       (++) Data Length
       (++) Data Block size
       (++) Data Transfer direction:  should be to card (To CARD)
       (++) Data Transfer mode
       (++) DPSM Status (Enable or Disable)
  
   (#) Configure the SDIO resources to send the data to the card according to 
       selected transfer mode (Refer to Step 8, 9 and 10).
                     
   (#) Send the selected Write command (refer to step 11).
                    
   (#) Use the SDIO flags/interrupts to check the transfer status.
  
  
@endverbatim
  *
  *
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_sdio.h"
#include "stm32f4xx_rcc.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @defgroup SDIO 
  * @brief SDIO driver modules
  * @{
  */ 

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

/* ------------ SDIO registers bit address in the alias region ----------- */
#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)

/* --- CLKCR Register ---*/
/* Alias word address of CLKEN bit */
#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
#define CLKEN_BitNumber           0x08
#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))

/* --- CMD Register ---*/
/* Alias word address of SDIOSUSPEND bit */
#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
#define SDIOSUSPEND_BitNumber     0x0B
#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))

/* Alias word address of ENCMDCOMPL bit */
#define ENCMDCOMPL_BitNumber      0x0C
#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))

/* Alias word address of NIEN bit */
#define NIEN_BitNumber            0x0D
#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))

/* Alias word address of ATACMD bit */
#define ATACMD_BitNumber          0x0E
#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))

/* --- DCTRL Register ---*/
/* Alias word address of DMAEN bit */
#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
#define DMAEN_BitNumber           0x03
#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))

/* Alias word address of RWSTART bit */
#define RWSTART_BitNumber         0x08
#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))

/* Alias word address of RWSTOP bit */
#define RWSTOP_BitNumber          0x09
#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))

/* Alias word address of RWMOD bit */
#define RWMOD_BitNumber           0x0A
#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))

/* Alias word address of SDIOEN bit */
#define SDIOEN_BitNumber          0x0B
#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))

/* ---------------------- SDIO registers bit mask ------------------------ */
/* --- CLKCR Register ---*/
/* CLKCR register clear mask */
#define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100) 

/* --- PWRCTRL Register ---*/
/* SDIO PWRCTRL Mask */
#define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)

/* --- DCTRL Register ---*/
/* SDIO DCTRL Clear Mask */
#define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)

/* --- CMD Register ---*/
/* CMD Register clear mask */
#define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)

/* SDIO RESP Registers Address */
#define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/** @defgroup SDIO_Private_Functions
  * @{
  */

/** @defgroup SDIO_Group1 Initialization and Configuration functions
 *  @brief   Initialization and Configuration functions 
 *
@verbatim   
 ===============================================================================
              ##### Initialization and Configuration functions #####
 ===============================================================================

@endverbatim
  * @{
  */

/**
  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void SDIO_DeInit(void)
{
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);
}

/**
  * @brief  Initializes the SDIO peripheral according to the specified 
  *         parameters in the SDIO_InitStruct.
  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
  *         that contains the configuration information for the SDIO peripheral.
  * @retval None
  */
void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
{
  uint32_t tmpreg = 0;
    
  /* Check the parameters */
  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
   
/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
  /* Get the SDIO CLKCR value */
  tmpreg = SDIO->CLKCR;
  
  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
  tmpreg &= CLKCR_CLEAR_MASK;
  
  /* Set CLKDIV bits according to SDIO_ClockDiv value */
  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
  
  /* Write to SDIO CLKCR */
  SDIO->CLKCR = tmpreg;
}

/**
  * @brief  Fills each SDIO_InitStruct member with its default value.
  * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
  *         will be initialized.
  * @retval None
  */
void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
{
  /* SDIO_InitStruct members default value */
  SDIO_InitStruct->SDIO_ClockDiv = 0x00;
  SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
  SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
  SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
  SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
  SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
}

/**
  * @brief  Enables or disables the SDIO Clock.
  * @param  NewState: new state of the SDIO Clock. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_ClockCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
}

/**
  * @brief  Sets the power status of the controller.
  * @param  SDIO_PowerState: new state of the Power state. 
  *          This parameter can be one of the following values:
  *            @arg SDIO_PowerState_OFF: SDIO Power OFF
  *            @arg SDIO_PowerState_ON: SDIO Power ON
  * @retval None
  */
void SDIO_SetPowerState(uint32_t SDIO_PowerState)
{
  /* Check the parameters */
  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
  
  SDIO->POWER = SDIO_PowerState;
}

/**
  * @brief  Gets the power status of the controller.
  * @param  None
  * @retval Power status of the controller. The returned value can be one of the 
  *         following values:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(void)
{
  return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
}

/**
  * @}
  */

/** @defgroup SDIO_Group2 Command path state machine (CPSM) management functions
 *  @brief   Command path state machine (CPSM) management functions 
 *
@verbatim   
 ===============================================================================
        ##### Command path state machine (CPSM) management functions #####
 ===============================================================================  

  This section provide functions allowing to program and read the Command path 
  state machine (CPSM).

@endverbatim
  * @{
  */

/**
  * @brief  Initializes the SDIO Command according to the specified 
  *         parameters in the SDIO_CmdInitStruct and send the command.
  * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
  *         structure that contains the configuration information for the SDIO 
  *         command.
  * @retval None
  */
void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
  
/*---------------------------- SDIO ARG Configuration ------------------------*/
  /* Set the SDIO Argument value */
  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
  
/*---------------------------- SDIO CMD Configuration ------------------------*/  
  /* Get the SDIO CMD value */
  tmpreg = SDIO->CMD;
  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
  tmpreg &= CMD_CLEAR_MASK;
  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
  /* Set WAITRESP bits according to SDIO_Response value */
  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
  /* Set CPSMEN bits according to SDIO_CPSM value */
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
  
  /* Write to SDIO CMD */
  SDIO->CMD = tmpreg;
}

/**
  * @brief  Fills each SDIO_CmdInitStruct member with its default value.
  * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
  *         structure which will be initialized.
  * @retval None
  */
void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
{
  /* SDIO_CmdInitStruct members default value */
  SDIO_CmdInitStruct->SDIO_Argument = 0x00;
  SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
  SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
  SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
  SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
}

/**
  * @brief  Returns command index of last command for which response received.
  * @param  None
  * @retval Returns the command index of the last command response received.
  */
uint8_t SDIO_GetCommandResponse(void)
{
  return (uint8_t)(SDIO->RESPCMD);
}

/**
  * @brief  Returns response received from the card for the last command.
  * @param  SDIO_RESP: Specifies the SDIO response register. 
  *          This parameter can be one of the following values:
  *            @arg SDIO_RESP1: Response Register 1
  *            @arg SDIO_RESP2: Response Register 2
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4
  * @retval The Corresponding response register value.
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
  __IO uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));

  tmp = SDIO_RESP_ADDR + SDIO_RESP;
  
  return (*(__IO uint32_t *) tmp); 
}

/**
  * @}
  */

/** @defgroup SDIO_Group3 Data path state machine (DPSM) management functions
 *  @brief   Data path state machine (DPSM) management functions
 *
@verbatim   
 ===============================================================================
         ##### Data path state machine (DPSM) management functions #####
 ===============================================================================  

  This section provide functions allowing to program and read the Data path 
  state machine (DPSM).

@endverbatim
  * @{
  */

/**
  * @brief  Initializes the SDIO data path according to the specified 
  *         parameters in the SDIO_DataInitStruct.
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval None
  */
void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));

/*---------------------------- SDIO DTIMER Configuration ---------------------*/
  /* Set the SDIO Data TimeOut value */
  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;

/*---------------------------- SDIO DLEN Configuration -----------------------*/
  /* Set the SDIO DataLength value */
  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;

/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
  /* Get the SDIO DCTRL value */
  tmpreg = SDIO->DCTRL;
  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
  tmpreg &= DCTRL_CLEAR_MASK;
  /* Set DEN bit according to SDIO_DPSM value */
  /* Set DTMODE bit according to SDIO_TransferMode value */
  /* Set DTDIR bit according to SDIO_TransferDir value */
  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;

  /* Write to SDIO DCTRL */
  SDIO->DCTRL = tmpreg;
}

/**
  * @brief  Fills each SDIO_DataInitStruct member with its default value.
  * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure 
  *         which will be initialized.
  * @retval None
  */
void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
  /* SDIO_DataInitStruct members default value */
  SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
  SDIO_DataInitStruct->SDIO_DataLength = 0x00;
  SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
  SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
  SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
  SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
}

/**
  * @brief  Returns number of remaining data bytes to be transferred.
  * @param  None
  * @retval Number of remaining data bytes to be transferred
  */
uint32_t SDIO_GetDataCounter(void)
{ 
  return SDIO->DCOUNT;
}

/**
  * @brief  Read one data word from Rx FIFO.
  * @param  None
  * @retval Data received
  */
uint32_t SDIO_ReadData(void)
{ 
  return SDIO->FIFO;
}

/**
  * @brief  Write one data word to Tx FIFO.
  * @param  Data: 32-bit data word to write.
  * @retval None
  */
void SDIO_WriteData(uint32_t Data)
{ 
  SDIO->FIFO = Data;
}

/**
  * @brief  Returns the number of words left to be written to or read from FIFO.	
  * @param  None
  * @retval Remaining number of words.
  */
uint32_t SDIO_GetFIFOCount(void)
{ 
  return SDIO->FIFOCNT;
}

/**
  * @}
  */

/** @defgroup SDIO_Group4 SDIO IO Cards mode management functions
 *  @brief   SDIO IO Cards mode management functions
 *
@verbatim   
 ===============================================================================
               ##### SDIO IO Cards mode management functions #####
 ===============================================================================  

  This section provide functions allowing to program and read the SDIO IO Cards.

@endverbatim
  * @{
  */

/**
  * @brief  Starts the SD I/O Read Wait operation.	
  * @param  NewState: new state of the Start SDIO Read Wait operation. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_StartSDIOReadWait(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
}

/**
  * @brief  Stops the SD I/O Read Wait operation.	
  * @param  NewState: new state of the Stop SDIO Read Wait operation. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_StopSDIOReadWait(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
}

/**
  * @brief  Sets one of the two options of inserting read wait interval.
  * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
  *          This parameter can be:
  *            @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
  *            @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
  * @retval None
  */
void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
{
  /* Check the parameters */
  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
  
  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
}

/**
  * @brief  Enables or disables the SD I/O Mode Operation.
  * @param  NewState: new state of SDIO specific operation. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_SetSDIOOperation(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
}

/**
  * @brief  Enables or disables the SD I/O Mode suspend command sending.
  * @param  NewState: new state of the SD I/O Mode suspend command.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
}

/**
  * @}
  */

/** @defgroup SDIO_Group5 CE-ATA mode management functions
 *  @brief   CE-ATA mode management functions
 *
@verbatim   
 ===============================================================================
                  ##### CE-ATA mode management functions #####
 ===============================================================================  

  This section provide functions allowing to program and read the CE-ATA card.

@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the command completion signal.
  * @param  NewState: new state of command completion signal. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_CommandCompletionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
}

/**
  * @brief  Enables or disables the CE-ATA interrupt.
  * @param  NewState: new state of CE-ATA interrupt. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_CEATAITCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
}

/**
  * @brief  Sends CE-ATA command (CMD61).
  * @param  NewState: new state of CE-ATA command. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_SendCEATACmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
}

/**
  * @}
  */

/** @defgroup SDIO_Group6 DMA transfers management functions
 *  @brief   DMA transfers management functions
 *
@verbatim   
 ===============================================================================
                  ##### DMA transfers management functions #####
 ===============================================================================  

  This section provide functions allowing to program SDIO DMA transfer.

@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the SDIO DMA request.
  * @param  NewState: new state of the selected SDIO DMA request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SDIO_DMACmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
}

/**
  * @}
  */

/** @defgroup SDIO_Group7 Interrupts and flags management functions
 *  @brief   Interrupts and flags management functions  
 *
@verbatim   
 ===============================================================================
              ##### Interrupts and flags management functions #####
 ===============================================================================  


@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the SDIO interrupts.
  * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.
  *          This parameter can be one or a combination of the following values:
  *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
  *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
  *                                   bus mode interrupt
  *            @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
  *            @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
  *            @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
  *            @arg SDIO_IT_RXACT:    Data receive in progress interrupt
  *            @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
  *            @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
  *            @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
  *            @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
  *            @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
  *            @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
  *            @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
  *            @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
  *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
  *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
  * @param  NewState: new state of the specified SDIO interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None 
  */
void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SDIO_IT(SDIO_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the SDIO interrupts */
    SDIO->MASK |= SDIO_IT;
  }
  else
  {
    /* Disable the SDIO interrupts */
    SDIO->MASK &= ~SDIO_IT;
  } 
}

/**
  * @brief  Checks whether the specified SDIO flag is set or not.
  * @param  SDIO_FLAG: specifies the flag to check. 
  *          This parameter can be one of the following values:
  *            @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
  *            @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
  *            @arg SDIO_FLAG_CTIMEOUT: Command response timeout
  *            @arg SDIO_FLAG_DTIMEOUT: Data timeout
  *            @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
  *            @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
  *            @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
  *            @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
  *            @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
  *            @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide bus mode.
  *            @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
  *            @arg SDIO_FLAG_CMDACT:   Command transfer in progress
  *            @arg SDIO_FLAG_TXACT:    Data transmit in progress
  *            @arg SDIO_FLAG_RXACT:    Data receive in progress
  *            @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty
  *            @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full
  *            @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full
  *            @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full
  *            @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty
  *            @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty
  *            @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO
  *            @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO
  *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
  *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
  * @retval The new state of SDIO_FLAG (SET or RESET).
  */
FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
{ 
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
  
  if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}

/**
  * @brief  Clears the SDIO's pending flags.
  * @param  SDIO_FLAG: specifies the flag to clear.  
  *          This parameter can be one or a combination of the following values:
  *            @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
  *            @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
  *            @arg SDIO_FLAG_CTIMEOUT: Command response timeout
  *            @arg SDIO_FLAG_DTIMEOUT: Data timeout
  *            @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
  *            @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
  *            @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
  *            @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
  *            @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
  *            @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide bus mode
  *            @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
  *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
  *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
  * @retval None
  */
void SDIO_ClearFlag(uint32_t SDIO_FLAG)
{ 
  /* Check the parameters */
  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
   
  SDIO->ICR = SDIO_FLAG;
}

/**
  * @brief  Checks whether the specified SDIO interrupt has occurred or not.
  * @param  SDIO_IT: specifies the SDIO interrupt source to check. 
  *          This parameter can be one of the following values:
  *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
  *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
  *                                   bus mode interrupt
  *            @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
  *            @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
  *            @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
  *            @arg SDIO_IT_RXACT:    Data receive in progress interrupt
  *            @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
  *            @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
  *            @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
  *            @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
  *            @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
  *            @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
  *            @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
  *            @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
  *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
  *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
  * @retval The new state of SDIO_IT (SET or RESET).
  */
ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
{ 
  ITStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_SDIO_GET_IT(SDIO_IT));
  if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}

/**
  * @brief  Clears the SDIO's interrupt pending bits.
  * @param  SDIO_IT: specifies the interrupt pending bit to clear. 
  *          This parameter can be one or a combination of the following values:
  *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
  *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
  *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
  *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
  *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
  *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
  *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
  *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
  *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIO_DCOUNT, is zero) interrupt
  *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
  *                                   bus mode interrupt
  *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
  *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61
  * @retval None
  */
void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
{ 
  /* Check the parameters */
  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
   
  SDIO->ICR = SDIO_IT;
}

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
  ******************************************************************************
  * @file    stm32f4xx_spi.c
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the Serial peripheral interface (SPI):
  *           + Initialization and Configuration
  *           + Data transfers functions
  *           + Hardware CRC Calculation
  *           + DMA transfers management
  *           + Interrupts and flags management 
  *           
@verbatim

 ===================================================================
                  ##### How to use this driver #####
 ===================================================================
 [..]
   (#) Enable peripheral clock using the following functions 
       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE) for SPI1
       RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE) for SPI2
       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI3
       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI4
       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI5
       RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI6.
  
   (#) Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHB1PeriphClockCmd()
       function. In I2S mode, if an external clock source is used then the I2S 
       CKIN pin GPIO clock should also be enabled.
  
   (#) Peripherals alternate function: 
       (++) Connect the pin to the desired peripherals' Alternate Function (AF) 
            using GPIO_PinAFConfig() function
       (++) Configure the desired pin in alternate function by: 
            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
       (++) Select the type, pull-up/pull-down and output speed via GPIO_PuPd, 
            GPIO_OType and GPIO_Speed members
       (++) Call GPIO_Init() function In I2S mode, if an external clock source is 
            used then the I2S CKIN pin should be also configured in Alternate 
            function Push-pull pull-up mode. 
          
   (#) Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
       Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
       function.
       In I2S mode, program the Mode, Standard, Data Format, MCLK Output, Audio 
       frequency and Polarity using I2S_Init() function. For I2S mode, make sure 
       that either:
       (++) I2S PLL is configured using the functions 
            RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S), RCC_PLLI2SCmd(ENABLE) and 
            RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY); or 
       (++) External clock source is configured using the function 
            RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly 
            the define constant I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file. 
  
   (#) Enable the NVIC and the corresponding interrupt using the function 
       SPI_ITConfig() if you need to use interrupt mode. 
  
   (#) When using the DMA mode 
       (++) Configure the DMA using DMA_Init() function
       (++) Active the needed channel Request using SPI_I2S_DMACmd() function
   
   (#) Enable the SPI using the SPI_Cmd() function or enable the I2S using
       I2S_Cmd().
   
   (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
  
   (#) Optionally, you can enable/configure the following parameters without
       re-initialization (i.e there is no need to call again SPI_Init() function):
       (++) When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
            is programmed as Data direction parameter using the SPI_Init() function
            it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
            using the SPI_BiDirectionalLineConfig() function.
       (++) When SPI_NSS_Soft is selected as Slave Select Management parameter 
            using the SPI_Init() function it can be possible to manage the 
            NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
       (++) Reconfigure the data size using the SPI_DataSizeConfig() function  
       (++) Enable or disable the SS output using the SPI_SSOutputCmd() function  
            
    (#) To use the CRC Hardware calculation feature refer to the Peripheral 
        CRC hardware Calculation subsection.
     
  
 [..] It is possible to use SPI in I2S full duplex mode, in this case, each SPI 
      peripheral is able to manage sending and receiving data simultaneously
      using two data lines. Each SPI peripheral has an extended block called I2Sxext
      (ie. I2S2ext for SPI2 and I2S3ext for SPI3).
      The extension block is not a full SPI IP, it is used only as I2S slave to
      implement full duplex mode. The extension block uses the same clock sources
      as its master.          
      To configure I2S full duplex you have to:
              
      (#) Configure SPIx in I2S mode (I2S_Init() function) as described above. 
             
      (#) Call the I2S_FullDuplexConfig() function using the same strucutre passed to  
          I2S_Init() function.
              
      (#) Call I2S_Cmd() for SPIx then for its extended block.
            
      (#) To configure interrupts or DMA requests and to get/clear flag status, 
          use I2Sxext instance for the extension block.
               
 [..] Functions that can be called with I2Sxext instances are: I2S_Cmd(), 
      I2S_FullDuplexConfig(), SPI_I2S_ReceiveData(), SPI_I2S_SendData(), 
      SPI_I2S_DMACmd(), SPI_I2S_ITConfig(), SPI_I2S_GetFlagStatus(), 
      SPI_I2S_ClearFlag(), SPI_I2S_GetITStatus() and SPI_I2S_ClearITPendingBit().
                   
      Example: To use SPI3 in Full duplex mode (SPI3 is Master Tx, I2S3ext is Slave Rx):
              
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);   
      I2S_StructInit(&I2SInitStruct);
      I2SInitStruct.Mode = I2S_Mode_MasterTx;     
      I2S_Init(SPI3, &I2SInitStruct);
      I2S_FullDuplexConfig(SPI3ext, &I2SInitStruct)
      I2S_Cmd(SPI3, ENABLE);
      I2S_Cmd(SPI3ext, ENABLE);
      ...
      while (SPI_I2S_GetFlagStatus(SPI2, SPI_FLAG_TXE) == RESET)
      {}
      SPI_I2S_SendData(SPI3, txdata[i]);
      ...  
      while (SPI_I2S_GetFlagStatus(I2S3ext, SPI_FLAG_RXNE) == RESET)
      {}
      rxdata[i] = SPI_I2S_ReceiveData(I2S3ext);
      ...          
                
 [..]       
   (@) In I2S mode: if an external clock is used as source clock for the I2S,  
       then the define I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should 
       be enabled and set to the value of the source clock frequency (in Hz).
   
   (@) In SPI mode: To use the SPI TI mode, call the function SPI_TIModeCmd() 
       just after calling the function SPI_Init().
  
@endverbatim  
  *                                  
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************  
  */ 

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_spi.h"
#include "stm32f4xx_rcc.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @defgroup SPI 
  * @brief SPI driver modules
  * @{
  */ 

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

/* SPI registers Masks */
#define CR1_CLEAR_MASK            ((uint16_t)0x3040)
#define I2SCFGR_CLEAR_MASK        ((uint16_t)0xF040)

/* RCC PLLs masks */
#define PLLCFGR_PPLR_MASK         ((uint32_t)0x70000000)
#define PLLCFGR_PPLN_MASK         ((uint32_t)0x00007FC0)

#define SPI_CR2_FRF               ((uint16_t)0x0010)
#define SPI_SR_TIFRFE             ((uint16_t)0x0100)

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/** @defgroup SPI_Private_Functions
  * @{
  */

/** @defgroup SPI_Group1 Initialization and Configuration functions
 *  @brief   Initialization and Configuration functions 
 *
@verbatim   
 ===============================================================================
             ##### Initialization and Configuration functions ##### 
 ===============================================================================  
 [..] This section provides a set of functions allowing to initialize the SPI 
      Direction, SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS 
      Management, SPI Baud Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
  
 [..] The SPI_Init() function follows the SPI configuration procedures for Master 
      mode and Slave mode (details for these procedures are available in reference 
      manual (RM0090)).
  
@endverbatim
  * @{
  */

/**
  * @brief  De-initialize the SPIx peripheral registers to their default reset values.
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode.   
  *         
  * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are de-initialized
  *         when the relative I2S peripheral is de-initialized (the extended block's clock
  *         is managed by the I2S peripheral clock).
  *             
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
  }
  else if (SPIx == SPI2)
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
  }
  else if (SPIx == SPI3)
  {
    /* Enable SPI3 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
    /* Release SPI3 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
  }
  else if (SPIx == SPI4)
  {
    /* Enable SPI4 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
    /* Release SPI4 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
  }
  else if (SPIx == SPI5)
  {
    /* Enable SPI5 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, ENABLE);
    /* Release SPI5 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
  }
  else 
  {
    if (SPIx == SPI6)
    {
      /* Enable SPI6 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
    }
  }
}

/**
  * @brief  Initializes the SPIx peripheral according to the specified 
  *         parameters in the SPI_InitStruct.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
  uint16_t tmpreg = 0;
  
  /* check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Check the SPI parameters */
  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
  assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
  assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
  assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
  assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
  assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
     master/salve mode, CPOL and CPHA */
  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
}

/**
  * @brief  Initializes the SPIx peripheral according to the specified 
  *         parameters in the I2S_InitStruct.
  * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral (configured in I2S mode).
  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral
  *         configured in I2S mode.
  *           
  * @note   The function calculates the optimal prescaler needed to obtain the most 
  *         accurate audio frequency (depending on the I2S clock source, the PLL values 
  *         and the product configuration). But in case the prescaler value is greater 
  *         than 511, the default value (0x02) will be configured instead.    
  * 
  * @note   if an external clock is used as source clock for the I2S, then the define
  *         I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should be enabled and set
  *         to the value of the the source clock frequency (in Hz).
  *  
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
  uint32_t tmp = 0, i2sclk = 0;
#ifndef I2S_EXTERNAL_CLOCK_VAL
  uint32_t pllm = 0, plln = 0, pllr = 0;
#endif /* I2S_EXTERNAL_CLOCK_VAL */
  
  /* Check the I2S parameters */
  assert_param(IS_SPI_23_PERIPH(SPIx));
  assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
  assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  SPIx->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
  {
    i2sodd = (uint16_t)0;
    i2sdiv = (uint16_t)2;   
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
    {
      /* Packet length is 16 bits */
      packetlength = 1;
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 2;
    }

    /* Get I2S source Clock frequency  ****************************************/
      
    /* If an external I2S clock has to be used, this define should be set  
       in the project configuration or in the stm32f4xx_conf.h file */
  #ifdef I2S_EXTERNAL_CLOCK_VAL     
    /* Set external clock as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
    {
      RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
    }
    
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);

    if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)
    {
      /* Get the I2S source clock value */
      i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
    }
    else
    { /* Get the I2S source clock value */
      i2sclk = (uint32_t)(((HSI_VALUE / pllm) * plln) / pllr);
    }
  #endif /* I2S_EXTERNAL_CLOCK_VAL */
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
   
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  SPIx->I2SCFGR = tmpreg;
}

/**
  * @brief  Fills each SPI_InitStruct member with its default value.
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
  * @retval None
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
  /* initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
  /* initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
}

/**
  * @brief  Fills each I2S_InitStruct member with its default value.
  * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
  * @retval None
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
  
  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
  
  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
  
  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
}

/**
  * @brief  Enables or disables the specified SPI peripheral.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @param  NewState: new state of the SPIx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
  }
}

/**
  * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
  * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
  *         for full duplex mode).
  * @param  NewState: new state of the SPIx peripheral. 
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral (in I2S mode) */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
  }
}

/**
  * @brief  Configures the data size for the selected SPI.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @param  SPI_DataSize: specifies the SPI data size.
  *          This parameter can be one of the following values:
  *            @arg SPI_DataSize_16b: Set data frame format to 16bit
  *            @arg SPI_DataSize_8b: Set data frame format to 8bit
  * @retval None
  */
void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
  /* Clear DFF bit */
  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
  /* Set new DFF bit value */
  SPIx->CR1 |= SPI_DataSize;
}

/**
  * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
  *          This parameter can be one of the following values:
  *            @arg SPI_Direction_Tx: Selects Tx transmission direction
  *            @arg SPI_Direction_Rx: Selects Rx receive direction
  * @retval None
  */
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
  }
}

/**
  * @brief  Configures internally by software the NSS pin for the selected SPI.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
  *          This parameter can be one of the following values:
  *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
  *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
  * @retval None
  */
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
  }
}

/**
  * @brief  Enables or disables the SS output for the selected SPI.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @param  NewState: new state of the SPIx SS output. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
  }
}

/**
  * @brief  Enables or disables the SPIx/I2Sx DMA interface.
  *   
  * @note   This function can be called only after the SPI_Init() function has 
  *         been called. 
  * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
  *         are not taken into consideration and are configured by hardware
  *         respectively to the TI mode requirements.  
  * 
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 
  * @param  NewState: new state of the selected SPI TI communication mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
  }
}

/**
  * @brief  Configures the full duplex mode for the I2Sx peripheral using its
  *         extension I2Sxext according to the specified parameters in the 
  *         I2S_InitStruct.
  * @param  I2Sxext: where x can be  2 or 3 to select the I2S peripheral extension block.
  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
  *         contains the configuration information for the specified I2S peripheral
  *         extension.
  * 
  * @note   The structure pointed by I2S_InitStruct parameter should be the same
  *         used for the master I2S peripheral. In this case, if the master is 
  *         configured as transmitter, the slave will be receiver and vice versa.
  *         Or you can force a different mode by modifying the field I2S_Mode to the
  *         value I2S_SlaveRx or I2S_SlaveTx indepedently of the master configuration.    
  *         
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
  uint16_t tmpreg = 0, tmp = 0;
  
  /* Check the I2S parameters */
  assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
  assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
  assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  I2Sxext->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
  {
    tmp = I2S_Mode_SlaveRx;
  }
  else
  {
    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
    {
      tmp = I2S_Mode_SlaveTx;
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
}

/**
  * @}
  */

/** @defgroup SPI_Group2 Data transfers functions
 *  @brief   Data transfers functions
 *
@verbatim   
 ===============================================================================
                      ##### Data transfers functions #####
 ===============================================================================  

 [..] This section provides a set of functions allowing to manage the SPI data 
      transfers. In reception, data are received and then stored into an internal 
      Rx buffer while. In transmission, data are first stored into an internal Tx 
      buffer before being transmitted.

 [..] The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
      function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
      can be done using SPI_I2S_SendData() function and stores the written data into 
      Tx buffer.

@endverbatim
  * @{
  */

/**
  * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
  * @retval The value of the received data.
  */
uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
}

/**
  * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
  * @param  Data: Data to be transmitted.
  * @retval None
  */
void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
}

/**
  * @}
  */

/** @defgroup SPI_Group3 Hardware CRC Calculation functions
 *  @brief   Hardware CRC Calculation functions
 *
@verbatim   
 ===============================================================================
                 ##### Hardware CRC Calculation functions #####
 ===============================================================================  

 [..] This section provides a set of functions allowing to manage the SPI CRC hardware 
      calculation

 [..] SPI communication using CRC is possible through the following procedure:
   (#) Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
       Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
       function.
   (#) Enable the CRC calculation using the SPI_CalculateCRC() function.
   (#) Enable the SPI using the SPI_Cmd() function
   (#) Before writing the last data to the TX buffer, set the CRCNext bit using the 
       SPI_TransmitCRC() function to indicate that after transmission of the last 
       data, the CRC should be transmitted.
   (#) After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
        bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
        value. 
        If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
        can be generated when the SPI_I2S_IT_ERR interrupt is enabled.

 [..]
   (@) It is advised not to read the calculated CRC values during the communication.

   (@) When the SPI is in slave mode, be careful to enable CRC calculation only 
       when the clock is stable, that is, when the clock is in the steady state. 
       If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
       to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
       the value of the SPE bit.

   (@) With high bitrate frequencies, be careful when transmitting the CRC.
       As the number of used CPU cycles has to be as low as possible in the CRC 
       transfer phase, it is forbidden to call software functions in the CRC 
       transmission sequence to avoid errors in the last data and CRC reception. 
       In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
       of the last data.

   (@) For high bit rate frequencies, it is advised to use the DMA mode to avoid the
       degradation of the SPI speed performance due to CPU accesses impacting the 
       SPI bandwidth.

   (@) When the STM32F4xx is configured as slave and the NSS hardware mode is 
       used, the NSS pin needs to be kept low between the data phase and the CRC 
       phase.

   (@) When the SPI is configured in slave mode with the CRC feature enabled, CRC
       calculation takes place even if a high level is applied on the NSS pin. 
       This may happen for example in case of a multi-slave environment where the 
       communication master addresses slaves alternately.

   (@) Between a slave de-selection (high level on NSS) and a new slave selection 
       (low level on NSS), the CRC value should be cleared on both master and slave
       sides in order to resynchronize the master and slave for their respective 
       CRC calculation.

   (@) To clear the CRC, follow the procedure below:
       (#@) Disable SPI using the SPI_Cmd() function
       (#@) Disable the CRC calculation using the SPI_CalculateCRC() function.
       (#@) Enable the CRC calculation using the SPI_CalculateCRC() function.
       (#@) Enable SPI using the SPI_Cmd() function.

@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the CRC value calculation of the transferred bytes.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @param  NewState: new state of the SPIx CRC value calculation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
  }
}

/**
  * @brief  Transmit the SPIx CRC value.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @retval None
  */
void SPI_TransmitCRC(SPI_TypeDef* SPIx)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
}

/**
  * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @param  SPI_CRC: specifies the CRC register to be read.
  *          This parameter can be one of the following values:
  *            @arg SPI_CRC_Tx: Selects Tx CRC register
  *            @arg SPI_CRC_Rx: Selects Rx CRC register
  * @retval The selected CRC register value..
  */
uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
{
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));
  if (SPI_CRC != SPI_CRC_Rx)
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
  }
  /* Return the selected CRC register */
  return crcreg;
}

/**
  * @brief  Returns the CRC Polynomial register value for the specified SPI.
  * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
  * @retval The CRC Polynomial register value.
  */
uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
}

/**
  * @}
  */

/** @defgroup SPI_Group4 DMA transfers management functions
 *  @brief   DMA transfers management functions
  *
@verbatim   
 ===============================================================================
                   ##### DMA transfers management functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the SPIx/I2Sx DMA interface.
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
  * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
  *          This parameter can be any combination of the following values:
  *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
  *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
  * @param  NewState: new state of the selected SPI DMA transfer request.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
  }
}

/**
  * @}
  */

/** @defgroup SPI_Group5 Interrupts and flags management functions
 *  @brief   Interrupts and flags management functions
  *
@verbatim   
 ===============================================================================
            ##### Interrupts and flags management functions #####
 ===============================================================================  
 
 [..] This section provides a set of functions allowing to configure the SPI Interrupts 
      sources and check or clear the flags or pending bits status.
      The user should identify which mode will be used in his application to manage 
      the communication: Polling mode, Interrupt mode or DMA mode. 
    
 *** Polling Mode ***
 ====================
[..] In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
  (#) SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
  (#) SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
  (#) SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
  (#) SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
  (#) SPI_FLAG_MODF : to indicate if a Mode Fault error occur
  (#) SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
  (#) I2S_FLAG_TIFRFE: to indicate a Frame Format error occurs.
  (#) I2S_FLAG_UDR: to indicate an Underrun error occurs.
  (#) I2S_FLAG_CHSIDE: to indicate Channel Side.

  (@) Do not use the BSY flag to handle each data transmission or reception. It is
      better to use the TXE and RXNE flags instead.

 [..] In this Mode it is advised to use the following functions:
   (+) FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   (+) void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);

 *** Interrupt Mode ***
 ======================
 [..] In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
      and 7 pending bits: 
   (+) Pending Bits:
       (##) SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
       (##) SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
       (##) SPI_IT_CRCERR : to indicate if a CRC Calculation error occur (available in SPI mode only)            
       (##) SPI_IT_MODF : to indicate if a Mode Fault error occur (available in SPI mode only)
       (##) SPI_I2S_IT_OVR : to indicate if an Overrun error occur
       (##) I2S_IT_UDR : to indicate an Underrun Error occurs (available in I2S mode only).
       (##) I2S_FLAG_TIFRFE : to indicate a Frame Format error occurs (available in TI mode only).

   (+) Interrupt Source:
       (##) SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
            interrupt.  
       (##) SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
            empty interrupt.
       (##) SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.

 [..] In this Mode it is advised to use the following functions:
   (+) void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
   (+) ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   (+) void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);

 *** DMA Mode ***
 ================
 [..] In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
   (#) SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   (#) SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request

 [..] In this Mode it is advised to use the following function:
   (+) void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState 
       NewState);

@endverbatim
  * @{
  */

/**
  * @brief  Enables or disables the specified SPI/I2S interrupts.
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
  * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
  *          This parameter can be one of the following values:
  *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
  *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
  *            @arg SPI_I2S_IT_ERR: Error interrupt mask
  * @param  NewState: new state of the specified SPI interrupt.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
{
  uint16_t itpos = 0, itmask = 0 ;
  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
  }
}

/**
  * @brief  Checks whether the specified SPIx/I2Sx flag is set or not.
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
  * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
  *          This parameter can be one of the following values:
  *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
  *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
  *            @arg SPI_I2S_FLAG_BSY: Busy flag.
  *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
  *            @arg SPI_FLAG_MODF: Mode Fault flag.
  *            @arg SPI_FLAG_CRCERR: CRC Error flag.
  *            @arg SPI_I2S_FLAG_TIFRFE: Format Error.
  *            @arg I2S_FLAG_UDR: Underrun Error flag.
  *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
  */
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
  {
    /* SPI_I2S_FLAG is set */
    bitstatus = SET;
  }
  else
  {
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}

/**
  * @brief  Clears the SPIx CRC Error (CRCERR) flag.
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
  * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
  *          This function clears only CRCERR flag.
  *            @arg SPI_FLAG_CRCERR: CRC Error flag.  
  *  
  * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
  *          operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
  *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
  * @note   UDR (UnderRun error) flag is cleared by a read operation to 
  *          SPI_SR register (SPI_I2S_GetFlagStatus()).   
  * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
  *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
  *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
  *  
  * @retval None
  */
void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    
  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
}

/**
  * @brief  Checks whether the specified SPIx/I2Sx interrupt has occurred or not.
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
  * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
  *          This parameter can be one of the following values:
  *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
  *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
  *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
  *            @arg SPI_IT_MODF: Mode Fault interrupt.
  *            @arg SPI_IT_CRCERR: CRC Error interrupt.
  *            @arg I2S_IT_UDR: Underrun interrupt.  
  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
  ITStatus bitstatus = RESET;
  uint16_t itpos = 0, itmask = 0, enablestatus = 0;

  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
  }
  else
  {
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}

/**
  * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
  *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
  * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
  *         This function clears only CRCERR interrupt pending bit.   
  *            @arg SPI_IT_CRCERR: CRC Error interrupt.
  *   
  * @note   OVR (OverRun Error) interrupt pending bit is cleared by software 
  *          sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
  *          followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
  * @note   UDR (UnderRun Error) interrupt pending bit is cleared by a read 
  *          operation to SPI_SR register (SPI_I2S_GetITStatus()).   
  * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
  *          a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
  *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
  *          the SPI).
  * @retval None
  */
void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
  uint16_t itpos = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));

  /* Get the SPI_I2S IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);

  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
  SPIx->SR = (uint16_t)~itpos;
}

/**
  * @}
  */

/**
  * @}
  */ 

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /**
  ******************************************************************************
  * @file    stm32f4xx_syscfg.c
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file provides firmware functions to manage the SYSCFG peripheral.
  *
 @verbatim
    
 ===============================================================================
                     ##### How to use this driver #####
 ===============================================================================
    [..] This driver provides functions for:
            
       (#) Remapping the memory accessible in the code area using SYSCFG_MemoryRemapConfig()
            
       (#) Swapping the internal flash Bank1 and Bank2 this features is only visible for 
           STM32F42xxx/43xxx devices Devices. 
                
       (#) Manage the EXTI lines connection to the GPIOs using SYSCFG_EXTILineConfig()
              
       (#) Select the ETHERNET media interface (RMII/RII) using SYSCFG_ETH_MediaInterfaceConfig()
  
       -@- SYSCFG APB clock must be enabled to get write access to SYSCFG registers,
           using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
                   
 @endverbatim      
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_syscfg.h"
#include "stm32f4xx_rcc.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @defgroup SYSCFG 
  * @brief SYSCFG driver modules
  * @{
  */ 

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* ------------ RCC registers bit address in the alias region ----------- */
#define SYSCFG_OFFSET             (SYSCFG_BASE - PERIPH_BASE)
/* ---  MEMRMP Register ---*/ 
/* Alias word address of UFB_MODE bit */ 
#define MEMRMP_OFFSET             SYSCFG_OFFSET 
#define UFB_MODE_BitNumber        ((uint8_t)0x8) 
#define UFB_MODE_BB               (PERIPH_BB_BASE + (MEMRMP_OFFSET * 32) + (UFB_MODE_BitNumber * 4)) 


/* ---  PMC Register ---*/ 
/* Alias word address of MII_RMII_SEL bit */ 
#define PMC_OFFSET                (SYSCFG_OFFSET + 0x04) 
#define MII_RMII_SEL_BitNumber    ((uint8_t)0x17) 
#define PMC_MII_RMII_SEL_BB       (PERIPH_BB_BASE + (PMC_OFFSET * 32) + (MII_RMII_SEL_BitNumber * 4)) 

/* ---  CMPCR Register ---*/ 
/* Alias word address of CMP_PD bit */ 
#define CMPCR_OFFSET              (SYSCFG_OFFSET + 0x20) 
#define CMP_PD_BitNumber          ((uint8_t)0x00) 
#define CMPCR_CMP_PD_BB           (PERIPH_BB_BASE + (CMPCR_OFFSET * 32) + (CMP_PD_BitNumber * 4)) 

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/** @defgroup SYSCFG_Private_Functions
  * @{
  */ 

/**
  * @brief  Deinitializes the Alternate Functions (remap and EXTI configuration)
  *   registers to their default reset values.
  * @param  None
  * @retval None
  */
void SYSCFG_DeInit(void)
{
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
}

/**
  * @brief  Changes the mapping of the specified pin.
  * @param  SYSCFG_Memory: selects the memory remapping.
  *         This parameter can be one of the following values:
  *            @arg SYSCFG_MemoryRemap_Flash:       Main Flash memory mapped at 0x00000000  
  *            @arg SYSCFG_MemoryRemap_SystemFlash: System Flash memory mapped at 0x00000000
  *            @arg SYSCFG_MemoryRemap_FSMC:        FSMC (Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000 for STM32F405xx/407xx and STM32F415xx/417xx devices. 
  *            @arg SYSCFG_MemoryRemap_FMC:         FMC (Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000 for STM32F42xxx/43xxx devices.  
  *            @arg SYSCFG_MemoryRemap_SRAM:        Embedded SRAM (112kB) mapped at 0x00000000
  *            @arg SYSCFG_MemoryRemap_SDRAM:       FMC (External SDRAM)  mapped at 0x00000000 for STM32F42xxx/43xxx devices.            
  * @retval None
  */
void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));

  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
}

/**
  * @brief  Enables or disables the Interal FLASH Bank Swapping.
  *   
  * @note   This function can be used only for STM32F42xxx/43xxx devices. 
  *
  * @param  NewState: new state of Interal FLASH Bank swapping.
  *          This parameter can be one of the following values:
  *            @arg ENABLE: Flash Bank2 mapped at 0x08000000 (and aliased @0x00000000) 
  *                         and Flash Bank1 mapped at 0x08100000 (and aliased at 0x00100000)   
  *            @arg DISABLE:(the default state) Flash Bank1 mapped at 0x08000000 (and aliased @0x0000 0000) 
                            and Flash Bank2 mapped at 0x08100000 (and aliased at 0x00100000)  
  * @retval None
  */
void SYSCFG_MemorySwappingBank(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) UFB_MODE_BB = (uint32_t)NewState;
}

/**
  * @brief  Selects the GPIO pin used as EXTI Line.
  * @param  EXTI_PortSourceGPIOx : selects the GPIO port to be used as source for
  *          EXTI lines where x can be (A..K) for STM32F42xxx/43xxx devices, (A..I) 
  *          for STM32F405xx/407xx and STM32F415xx/417xx devices or (A, B, C, D and H)
  *          for STM32401xx devices.  
  *            
  * @param  EXTI_PinSourcex: specifies the EXTI line to be configured.
  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
  *           for EXTI_PortSourceGPIOI x can be (0..11) for STM32F405xx/407xx
  *           and STM32F405xx/407xx devices and for EXTI_PortSourceGPIOK x can   
  *           be (0..7) for STM32F42xxx/43xxx devices. 
  *             
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
  uint32_t tmp = 0x00;

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
}

/**
  * @brief  Selects the ETHERNET media interface 
  * @param  SYSCFG_ETH_MediaInterface: specifies the Media Interface mode. 
  *          This parameter can be one of the following values: 
  *            @arg SYSCFG_ETH_MediaInterface_MII: MII mode selected
  *            @arg SYSCFG_ETH_MediaInterface_RMII: RMII mode selected 
  * @retval None 
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
}

/**
  * @brief  Enables or disables the I/O Compensation Cell.
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.  
  * @param  NewState: new state of the I/O Compensation Cell.
  *          This parameter can be one of the following values:
  *            @arg ENABLE: I/O compensation cell enabled  
  *            @arg DISABLE: I/O compensation cell power-down mode  
  * @retval None
  */
void SYSCFG_CompensationCellCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
}

/**
  * @brief  Checks whether the I/O Compensation Cell ready flag is set or not.
  * @param  None
  * @retval The new state of the I/O Compensation Cell ready flag (SET or RESET)
  */
FlagStatus SYSCFG_GetCompensationCellStatus(void)
{
  FlagStatus bitstatus = RESET;
    
  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
  ******************************************************************************
  * @file    stm32f4xx_wwdg.c
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file provides firmware functions to manage the following 
  *          functionalities of the Window watchdog (WWDG) peripheral:           
  *           + Prescaler, Refresh window and Counter configuration
  *           + WWDG activation
  *           + Interrupts and flags management
  *             
 @verbatim    
 ===============================================================================
                           ##### WWDG features #####
 ===============================================================================
    [..]                                      
        Once enabled the WWDG generates a system reset on expiry of a programmed
        time period, unless the program refreshes the counter (downcounter) 
        before to reach 0x3F value (i.e. a reset is generated when the counter
        value rolls over from 0x40 to 0x3F). 
        An MCU reset is also generated if the counter value is refreshed
        before the counter has reached the refresh window value. This 
        implies that the counter must be refreshed in a limited window.
              
        Once enabled the WWDG cannot be disabled except by a system reset.
          
        WWDGRST flag in RCC_CSR register can be used to inform when a WWDG
        reset occurs.
             
        The WWDG counter input clock is derived from the APB clock divided 
        by a programmable prescaler.
                
        WWDG counter clock = PCLK1 / Prescaler
        WWDG timeout = (WWDG counter clock) * (counter value)
                       
        Min-max timeout value @42 MHz(PCLK1): ~97.5 us / ~49.9 ms
                             
                      ##### How to use this driver #####
 ===============================================================================
    [..]
      (#) Enable WWDG clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE) function
              
      (#) Configure the WWDG prescaler using WWDG_SetPrescaler() function
                             
      (#) Configure the WWDG refresh window using WWDG_SetWindowValue() function
              
      (#) Set the WWDG counter value and start it using WWDG_Enable() function.
          When the WWDG is enabled the counter value should be configured to 
          a value greater than 0x40 to prevent generating an immediate reset.     
              
      (#) Optionally you can enable the Early wakeup interrupt which is 
          generated when the counter reach 0x40.
          Once enabled this interrupt cannot be disabled except by a system reset.
                  
      (#) Then the application program must refresh the WWDG counter at regular
          intervals during normal operation to prevent an MCU reset, using
          WWDG_SetCounter() function. This operation must occur only when
          the counter value is lower than the refresh window value, 
          programmed using WWDG_SetWindowValue().         
  
    @endverbatim
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_wwdg.h"
#include "stm32f4xx_rcc.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @defgroup WWDG 
  * @brief WWDG driver modules
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

/* ----------- WWDG registers bit address in the alias region ----------- */
#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)
/* Alias word address of EWI bit */
#define CFR_OFFSET        (WWDG_OFFSET + 0x04)
#define EWI_BitNumber     0x09
#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))

/* --------------------- WWDG registers bit mask ------------------------ */
/* CFR register bit mask */
#define CFR_WDGTB_MASK    ((uint32_t)0xFFFFFE7F)
#define CFR_W_MASK        ((uint32_t)0xFFFFFF80)
#define BIT_MASK          ((uint8_t)0x7F)

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/** @defgroup WWDG_Private_Functions
  * @{
  */

/** @defgroup WWDG_Group1 Prescaler, Refresh window and Counter configuration functions
 *  @brief   Prescaler, Refresh window and Counter configuration functions 
 *
@verbatim   
 ===============================================================================
    ##### Prescaler, Refresh window and Counter configuration functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void WWDG_DeInit(void)
{
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
}

/**
  * @brief  Sets the WWDG Prescaler.
  * @param  WWDG_Prescaler: specifies the WWDG Prescaler.
  *   This parameter can be one of the following values:
  *     @arg WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1
  *     @arg WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2
  *     @arg WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4
  *     @arg WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8
  * @retval None
  */
void WWDG_SetPrescaler(uint32_t WWDG_Prescaler)
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
  /* Clear WDGTB[1:0] bits */
  tmpreg = WWDG->CFR & CFR_WDGTB_MASK;
  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
  tmpreg |= WWDG_Prescaler;
  /* Store the new value */
  WWDG->CFR = tmpreg;
}

/**
  * @brief  Sets the WWDG window value.
  * @param  WindowValue: specifies the window value to be compared to the downcounter.
  *   This parameter value must be lower than 0x80.
  * @retval None
  */
void WWDG_SetWindowValue(uint8_t WindowValue)
{
  __IO uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
  /* Clear W[6:0] bits */

  tmpreg = WWDG->CFR & CFR_W_MASK;

  /* Set W[6:0] bits according to WindowValue value */
  tmpreg |= WindowValue & (uint32_t) BIT_MASK;

  /* Store the new value */
  WWDG->CFR = tmpreg;
}

/**
  * @brief  Enables the WWDG Early Wakeup interrupt(EWI).
  * @note   Once enabled this interrupt cannot be disabled except by a system reset.
  * @param  None
  * @retval None
  */
void WWDG_EnableIT(void)
{
  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
}

/**
  * @brief  Sets the WWDG counter value.
  * @param  Counter: specifies the watchdog counter value.
  *   This parameter must be a number between 0x40 and 0x7F (to prevent generating
  *   an immediate reset) 
  * @retval None
  */
void WWDG_SetCounter(uint8_t Counter)
{
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  /* Write to T[6:0] bits to configure the counter value, no need to do
     a read-modify-write; writing a 0 to WDGA bit does nothing */
  WWDG->CR = Counter & BIT_MASK;
}
/**
  * @}
  */

/** @defgroup WWDG_Group2 WWDG activation functions
 *  @brief   WWDG activation functions 
 *
@verbatim   
 ===============================================================================
                    ##### WWDG activation function #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Enables WWDG and load the counter value.                  
  * @param  Counter: specifies the watchdog counter value.
  *   This parameter must be a number between 0x40 and 0x7F (to prevent generating
  *   an immediate reset)
  * @retval None
  */
void WWDG_Enable(uint8_t Counter)
{
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  WWDG->CR = WWDG_CR_WDGA | Counter;
}
/**
  * @}
  */

/** @defgroup WWDG_Group3 Interrupts and flags management functions
 *  @brief   Interrupts and flags management functions 
 *
@verbatim   
 ===============================================================================
            ##### Interrupts and flags management functions #####
 ===============================================================================  

@endverbatim
  * @{
  */

/**
  * @brief  Checks whether the Early Wakeup interrupt flag is set or not.
  * @param  None
  * @retval The new state of the Early Wakeup interrupt flag (SET or RESET)
  */
FlagStatus WWDG_GetFlagStatus(void)
{
  FlagStatus bitstatus = RESET;
    
  if ((WWDG->SR) != (uint32_t)RESET)
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}

/**
  * @brief  Clears Early Wakeup interrupt flag.
  * @param  None
  * @retval None
  */
void WWDG_ClearFlag(void)
{
  WWDG->SR = (uint32_t)RESET;
}

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #include "key.h"
#include "delay.h" 
//////////////////////////////////////////////////////////////////////////////////	 
//
//ALIENTEK STM32F407
//	   
//@ALIENTEK
//:www.openedv.com
//:2014/5/3
//V1.0
//
//Copyright(C)  2014-2024
//All rights reserved									  
////////////////////////////////////////////////////////////////////////////////// 	 

//
void KEY_Init(void)
{
	
	GPIO_InitTypeDef  GPIO_InitStructure;

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA|RCC_AHB1Periph_GPIOE, ENABLE);//GPIOA,GPIOE
 
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4; //KEY0 KEY1 KEY2
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;//
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100M
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//
  GPIO_Init(GPIOE, &GPIO_InitStructure);//GPIOE2,3,4
	
	 
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//WK_UPPA0
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN ;//
  GPIO_Init(GPIOA, &GPIO_InitStructure);//GPIOA0
 
} 
//
//
//mode:0,;1,;
//0
//1KEY0
//2KEY1
//3KEY2 
//4WKUP WK_UP
//,KEY0>KEY1>KEY2>WK_UP!!
u8 KEY_Scan(u8 mode)
{	 
	static u8 key_up=1;//
	if(mode)key_up=1;  //		  
	if(key_up&&(KEY0==0||KEY1==0||KEY2==0||WK_UP==1))
	{
		delay_ms(10);// 
		key_up=0;
		if(KEY0==0)return 1;
		else if(KEY1==0)return 2;
		else if(KEY2==0)return 3;
		else if(WK_UP==1)return 4;
	}else if(KEY0==1&&KEY1==1&&KEY2==1&&WK_UP==0)key_up=1; 	    
 	return 0;// 
}




















                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #ifndef __KEY_H
#define __KEY_H	 
#include "sys.h" 
//////////////////////////////////////////////////////////////////////////////////	 
//
//ALIENTEK STM32F407
//	   
//@ALIENTEK
//:www.openedv.com
//:2014/5/3
//V1.0
//
//Copyright(C)  2014-2024
//All rights reserved									  
////////////////////////////////////////////////////////////////////////////////// 	 

/*IO*/
#define KEY0 		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4) //PE4
#define KEY1 		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3)	//PE3 
#define KEY2 		GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_2) //PE2
#define WK_UP 	GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)	//PA0


/*IO*/
/*
#define KEY0 		PEin(4)   	//PE4
#define KEY1 		PEin(3)		//PE3 
#define KEY2 		PEin(2)		//P32
#define WK_UP 	PAin(0)		//PA0
*/


#define KEY0_PRES 	1
#define KEY1_PRES	2
#define KEY2_PRES	3
#define WKUP_PRES   4

void KEY_Init(void);	//IO
u8 KEY_Scan(u8);  		//	

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #ifndef __FONT_H
#define __FONT_H 	   
//ASCII
//32 
//ASCII: !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
//PC2LCD2002+++C51
//312*1216*1624*24
//:(size/8+((size%8)?1:0))*(size/2),size:(12/16/24...)
 
//12*12 ASCII
const unsigned char asc2_1206[95][12]={
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
{0x00,0x00,0x00,0x00,0x3F,0x40,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
{0x00,0x00,0x30,0x00,0x40,0x00,0x30,0x00,0x40,0x00,0x00,0x00},/*""",2*/
{0x09,0x00,0x0B,0xC0,0x3D,0x00,0x0B,0xC0,0x3D,0x00,0x09,0x00},/*"#",3*/
{0x18,0xC0,0x24,0x40,0x7F,0xE0,0x22,0x40,0x31,0x80,0x00,0x00},/*"$",4*/
{0x18,0x00,0x24,0xC0,0x1B,0x00,0x0D,0x80,0x32,0x40,0x01,0x80},/*"%",5*/
{0x03,0x80,0x1C,0x40,0x27,0x40,0x1C,0x80,0x07,0x40,0x00,0x40},/*"&",6*/
{0x10,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x20,0x40,0x40,0x20},/*"(",8*/
{0x00,0x00,0x40,0x20,0x20,0x40,0x1F,0x80,0x00,0x00,0x00,0x00},/*")",9*/
{0x09,0x00,0x06,0x00,0x1F,0x80,0x06,0x00,0x09,0x00,0x00,0x00},/*"*",10*/
{0x04,0x00,0x04,0x00,0x3F,0x80,0x04,0x00,0x04,0x00,0x00,0x00},/*"+",11*/
{0x00,0x10,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
{0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x00},/*"-",13*/
{0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
{0x00,0x20,0x01,0xC0,0x06,0x00,0x38,0x00,0x40,0x00,0x00,0x00},/*"/",15*/
{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"0",16*/
{0x00,0x00,0x10,0x40,0x3F,0xC0,0x00,0x40,0x00,0x00,0x00,0x00},/*"1",17*/
{0x18,0xC0,0x21,0x40,0x22,0x40,0x24,0x40,0x18,0x40,0x00,0x00},/*"2",18*/
{0x10,0x80,0x20,0x40,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"3",19*/
{0x02,0x00,0x0D,0x00,0x11,0x00,0x3F,0xC0,0x01,0x40,0x00,0x00},/*"4",20*/
{0x3C,0x80,0x24,0x40,0x24,0x40,0x24,0x40,0x23,0x80,0x00,0x00},/*"5",21*/
{0x1F,0x80,0x24,0x40,0x24,0x40,0x34,0x40,0x03,0x80,0x00,0x00},/*"6",22*/
{0x30,0x00,0x20,0x00,0x27,0xC0,0x38,0x00,0x20,0x00,0x00,0x00},/*"7",23*/
{0x1B,0x80,0x24,0x40,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"8",24*/
{0x1C,0x00,0x22,0xC0,0x22,0x40,0x22,0x40,0x1F,0x80,0x00,0x00},/*"9",25*/
{0x00,0x00,0x00,0x00,0x08,0x40,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
{0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
{0x00,0x00,0x04,0x00,0x0A,0x00,0x11,0x00,0x20,0x80,0x40,0x40},/*"<",28*/
{0x09,0x00,0x09,0x00,0x09,0x00,0x09,0x00,0x09,0x00,0x00,0x00},/*"=",29*/
{0x00,0x00,0x40,0x40,0x20,0x80,0x11,0x00,0x0A,0x00,0x04,0x00},/*">",30*/
{0x18,0x00,0x20,0x00,0x23,0x40,0x24,0x00,0x18,0x00,0x00,0x00},/*"?",31*/
{0x1F,0x80,0x20,0x40,0x27,0x40,0x29,0x40,0x1F,0x40,0x00,0x00},/*"@",32*/
{0x00,0x40,0x07,0xC0,0x39,0x00,0x0F,0x00,0x01,0xC0,0x00,0x40},/*"A",33*/
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"B",34*/
{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x30,0x80,0x00,0x00},/*"C",35*/
{0x20,0x40,0x3F,0xC0,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"D",36*/
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x2E,0x40,0x30,0xC0,0x00,0x00},/*"E",37*/
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x2E,0x00,0x30,0x00,0x00,0x00},/*"F",38*/
{0x0F,0x00,0x10,0x80,0x20,0x40,0x22,0x40,0x33,0x80,0x02,0x00},/*"G",39*/
{0x20,0x40,0x3F,0xC0,0x04,0x00,0x04,0x00,0x3F,0xC0,0x20,0x40},/*"H",40*/
{0x20,0x40,0x20,0x40,0x3F,0xC0,0x20,0x40,0x20,0x40,0x00,0x00},/*"I",41*/
{0x00,0x60,0x20,0x20,0x20,0x20,0x3F,0xC0,0x20,0x00,0x20,0x00},/*"J",42*/
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x0B,0x00,0x30,0xC0,0x20,0x40},/*"K",43*/
{0x20,0x40,0x3F,0xC0,0x20,0x40,0x00,0x40,0x00,0x40,0x00,0xC0},/*"L",44*/
{0x3F,0xC0,0x3C,0x00,0x03,0xC0,0x3C,0x00,0x3F,0xC0,0x00,0x00},/*"M",45*/
{0x20,0x40,0x3F,0xC0,0x0C,0x40,0x23,0x00,0x3F,0xC0,0x20,0x00},/*"N",46*/
{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"O",47*/
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x24,0x00,0x18,0x00,0x00,0x00},/*"P",48*/
{0x1F,0x80,0x21,0x40,0x21,0x40,0x20,0xE0,0x1F,0xA0,0x00,0x00},/*"Q",49*/
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x26,0x00,0x19,0xC0,0x00,0x40},/*"R",50*/
{0x18,0xC0,0x24,0x40,0x24,0x40,0x22,0x40,0x31,0x80,0x00,0x00},/*"S",51*/
{0x30,0x00,0x20,0x40,0x3F,0xC0,0x20,0x40,0x30,0x00,0x00,0x00},/*"T",52*/
{0x20,0x00,0x3F,0x80,0x00,0x40,0x00,0x40,0x3F,0x80,0x20,0x00},/*"U",53*/
{0x20,0x00,0x3E,0x00,0x01,0xC0,0x07,0x00,0x38,0x00,0x20,0x00},/*"V",54*/
{0x38,0x00,0x07,0xC0,0x3C,0x00,0x07,0xC0,0x38,0x00,0x00,0x00},/*"W",55*/
{0x20,0x40,0x39,0xC0,0x06,0x00,0x39,0xC0,0x20,0x40,0x00,0x00},/*"X",56*/
{0x20,0x00,0x38,0x40,0x07,0xC0,0x38,0x40,0x20,0x00,0x00,0x00},/*"Y",57*/
{0x30,0x40,0x21,0xC0,0x26,0x40,0x38,0x40,0x20,0xC0,0x00,0x00},/*"Z",58*/
{0x00,0x00,0x00,0x00,0x7F,0xE0,0x40,0x20,0x40,0x20,0x00,0x00},/*"[",59*/
{0x00,0x00,0x70,0x00,0x0C,0x00,0x03,0x80,0x00,0x40,0x00,0x00},/*"\",60*/
{0x00,0x00,0x40,0x20,0x40,0x20,0x7F,0xE0,0x00,0x00,0x00,0x00},/*"]",61*/
{0x00,0x00,0x20,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
{0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10},/*"_",63*/
{0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
{0x00,0x00,0x02,0x80,0x05,0x40,0x05,0x40,0x03,0xC0,0x00,0x40},/*"a",65*/
{0x20,0x00,0x3F,0xC0,0x04,0x40,0x04,0x40,0x03,0x80,0x00,0x00},/*"b",66*/
{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x40,0x06,0x40,0x00,0x00},/*"c",67*/
{0x00,0x00,0x03,0x80,0x04,0x40,0x24,0x40,0x3F,0xC0,0x00,0x40},/*"d",68*/
{0x00,0x00,0x03,0x80,0x05,0x40,0x05,0x40,0x03,0x40,0x00,0x00},/*"e",69*/
{0x00,0x00,0x04,0x40,0x1F,0xC0,0x24,0x40,0x24,0x40,0x20,0x00},/*"f",70*/
{0x00,0x00,0x02,0xE0,0x05,0x50,0x05,0x50,0x06,0x50,0x04,0x20},/*"g",71*/
{0x20,0x40,0x3F,0xC0,0x04,0x40,0x04,0x00,0x03,0xC0,0x00,0x40},/*"h",72*/
{0x00,0x00,0x04,0x40,0x27,0xC0,0x00,0x40,0x00,0x00,0x00,0x00},/*"i",73*/
{0x00,0x10,0x00,0x10,0x04,0x10,0x27,0xE0,0x00,0x00,0x00,0x00},/*"j",74*/
{0x20,0x40,0x3F,0xC0,0x01,0x40,0x07,0x00,0x04,0xC0,0x04,0x40},/*"k",75*/
{0x20,0x40,0x20,0x40,0x3F,0xC0,0x00,0x40,0x00,0x40,0x00,0x00},/*"l",76*/
{0x07,0xC0,0x04,0x00,0x07,0xC0,0x04,0x00,0x03,0xC0,0x00,0x00},/*"m",77*/
{0x04,0x40,0x07,0xC0,0x04,0x40,0x04,0x00,0x03,0xC0,0x00,0x40},/*"n",78*/
{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x40,0x03,0x80,0x00,0x00},/*"o",79*/
{0x04,0x10,0x07,0xF0,0x04,0x50,0x04,0x40,0x03,0x80,0x00,0x00},/*"p",80*/
{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x50,0x07,0xF0,0x00,0x10},/*"q",81*/
{0x04,0x40,0x07,0xC0,0x02,0x40,0x04,0x00,0x04,0x00,0x00,0x00},/*"r",82*/
{0x00,0x00,0x06,0x40,0x05,0x40,0x05,0x40,0x04,0xC0,0x00,0x00},/*"s",83*/
{0x00,0x00,0x04,0x00,0x1F,0x80,0x04,0x40,0x00,0x40,0x00,0x00},/*"t",84*/
{0x04,0x00,0x07,0x80,0x00,0x40,0x04,0x40,0x07,0xC0,0x00,0x40},/*"u",85*/
{0x04,0x00,0x07,0x00,0x04,0xC0,0x01,0x80,0x06,0x00,0x04,0x00},/*"v",86*/
{0x06,0x00,0x01,0xC0,0x07,0x00,0x01,0xC0,0x06,0x00,0x00,0x00},/*"w",87*/
{0x04,0x40,0x06,0xC0,0x01,0x00,0x06,0xC0,0x04,0x40,0x00,0x00},/*"x",88*/
{0x04,0x10,0x07,0x10,0x04,0xE0,0x01,0x80,0x06,0x00,0x04,0x00},/*"y",89*/
{0x00,0x00,0x04,0x40,0x05,0xC0,0x06,0x40,0x04,0x40,0x00,0x00},/*"z",90*/
{0x00,0x00,0x00,0x00,0x04,0x00,0x7B,0xE0,0x40,0x20,0x00,0x00},/*"{",91*/
{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xF0,0x00,0x00,0x00,0x00},/*"|",92*/
{0x00,0x00,0x40,0x20,0x7B,0xE0,0x04,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
{0x40,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x40,0x00},/*"~",94*/
};  
//16*16 ASCII
const unsigned char asc2_1608[95][16]={	  
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xCC,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
{0x00,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x00,0x00},/*""",2*/
{0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x00,0x00},/*"#",3*/
{0x00,0x00,0x0E,0x18,0x11,0x04,0x3F,0xFF,0x10,0x84,0x0C,0x78,0x00,0x00,0x00,0x00},/*"$",4*/
{0x0F,0x00,0x10,0x84,0x0F,0x38,0x00,0xC0,0x07,0x78,0x18,0x84,0x00,0x78,0x00,0x00},/*"%",5*/
{0x00,0x78,0x0F,0x84,0x10,0xC4,0x11,0x24,0x0E,0x98,0x00,0xE4,0x00,0x84,0x00,0x08},/*"&",6*/
{0x08,0x00,0x68,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x18,0x18,0x20,0x04,0x40,0x02,0x00,0x00},/*"(",8*/
{0x00,0x00,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},/*")",9*/
{0x02,0x40,0x02,0x40,0x01,0x80,0x0F,0xF0,0x01,0x80,0x02,0x40,0x02,0x40,0x00,0x00},/*"*",10*/
{0x00,0x80,0x00,0x80,0x00,0x80,0x0F,0xF8,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},/*"+",11*/
{0x00,0x01,0x00,0x0D,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
{0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},/*"-",13*/
{0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
{0x00,0x00,0x00,0x06,0x00,0x18,0x00,0x60,0x01,0x80,0x06,0x00,0x18,0x00,0x20,0x00},/*"/",15*/
{0x00,0x00,0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"0",16*/
{0x00,0x00,0x08,0x04,0x08,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"1",17*/
{0x00,0x00,0x0E,0x0C,0x10,0x14,0x10,0x24,0x10,0x44,0x11,0x84,0x0E,0x0C,0x00,0x00},/*"2",18*/
{0x00,0x00,0x0C,0x18,0x10,0x04,0x11,0x04,0x11,0x04,0x12,0x88,0x0C,0x70,0x00,0x00},/*"3",19*/
{0x00,0x00,0x00,0xE0,0x03,0x20,0x04,0x24,0x08,0x24,0x1F,0xFC,0x00,0x24,0x00,0x00},/*"4",20*/
{0x00,0x00,0x1F,0x98,0x10,0x84,0x11,0x04,0x11,0x04,0x10,0x88,0x10,0x70,0x00,0x00},/*"5",21*/
{0x00,0x00,0x07,0xF0,0x08,0x88,0x11,0x04,0x11,0x04,0x18,0x88,0x00,0x70,0x00,0x00},/*"6",22*/
{0x00,0x00,0x1C,0x00,0x10,0x00,0x10,0xFC,0x13,0x00,0x1C,0x00,0x10,0x00,0x00,0x00},/*"7",23*/
{0x00,0x00,0x0E,0x38,0x11,0x44,0x10,0x84,0x10,0x84,0x11,0x44,0x0E,0x38,0x00,0x00},/*"8",24*/
{0x00,0x00,0x07,0x00,0x08,0x8C,0x10,0x44,0x10,0x44,0x08,0x88,0x07,0xF0,0x00,0x00},/*"9",25*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x03,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
{0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
{0x00,0x00,0x00,0x80,0x01,0x40,0x02,0x20,0x04,0x10,0x08,0x08,0x10,0x04,0x00,0x00},/*"<",28*/
{0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x00,0x00},/*"=",29*/
{0x00,0x00,0x10,0x04,0x08,0x08,0x04,0x10,0x02,0x20,0x01,0x40,0x00,0x80,0x00,0x00},/*">",30*/
{0x00,0x00,0x0E,0x00,0x12,0x00,0x10,0x0C,0x10,0x6C,0x10,0x80,0x0F,0x00,0x00,0x00},/*"?",31*/
{0x03,0xE0,0x0C,0x18,0x13,0xE4,0x14,0x24,0x17,0xC4,0x08,0x28,0x07,0xD0,0x00,0x00},/*"@",32*/
{0x00,0x04,0x00,0x3C,0x03,0xC4,0x1C,0x40,0x07,0x40,0x00,0xE4,0x00,0x1C,0x00,0x04},/*"A",33*/
{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x11,0x04,0x0E,0x88,0x00,0x70,0x00,0x00},/*"B",34*/
{0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x08,0x1C,0x10,0x00,0x00},/*"C",35*/
{0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"D",36*/
{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x17,0xC4,0x10,0x04,0x08,0x18,0x00,0x00},/*"E",37*/
{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x17,0xC0,0x10,0x00,0x08,0x00,0x00,0x00},/*"F",38*/
{0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x44,0x1C,0x78,0x00,0x40,0x00,0x00},/*"G",39*/
{0x10,0x04,0x1F,0xFC,0x10,0x84,0x00,0x80,0x00,0x80,0x10,0x84,0x1F,0xFC,0x10,0x04},/*"H",40*/
{0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x00,0x00,0x00,0x00},/*"I",41*/
{0x00,0x03,0x00,0x01,0x10,0x01,0x10,0x01,0x1F,0xFE,0x10,0x00,0x10,0x00,0x00,0x00},/*"J",42*/
{0x10,0x04,0x1F,0xFC,0x11,0x04,0x03,0x80,0x14,0x64,0x18,0x1C,0x10,0x04,0x00,0x00},/*"K",43*/
{0x10,0x04,0x1F,0xFC,0x10,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x0C,0x00,0x00},/*"L",44*/
{0x10,0x04,0x1F,0xFC,0x1F,0x00,0x00,0xFC,0x1F,0x00,0x1F,0xFC,0x10,0x04,0x00,0x00},/*"M",45*/
{0x10,0x04,0x1F,0xFC,0x0C,0x04,0x03,0x00,0x00,0xE0,0x10,0x18,0x1F,0xFC,0x10,0x00},/*"N",46*/
{0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"O",47*/
{0x10,0x04,0x1F,0xFC,0x10,0x84,0x10,0x80,0x10,0x80,0x10,0x80,0x0F,0x00,0x00,0x00},/*"P",48*/
{0x07,0xF0,0x08,0x18,0x10,0x24,0x10,0x24,0x10,0x1C,0x08,0x0A,0x07,0xF2,0x00,0x00},/*"Q",49*/
{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x11,0xC0,0x11,0x30,0x0E,0x0C,0x00,0x04},/*"R",50*/
{0x00,0x00,0x0E,0x1C,0x11,0x04,0x10,0x84,0x10,0x84,0x10,0x44,0x1C,0x38,0x00,0x00},/*"S",51*/
{0x18,0x00,0x10,0x00,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x00,0x18,0x00,0x00,0x00},/*"T",52*/
{0x10,0x00,0x1F,0xF8,0x10,0x04,0x00,0x04,0x00,0x04,0x10,0x04,0x1F,0xF8,0x10,0x00},/*"U",53*/
{0x10,0x00,0x1E,0x00,0x11,0xE0,0x00,0x1C,0x00,0x70,0x13,0x80,0x1C,0x00,0x10,0x00},/*"V",54*/
{0x1F,0xC0,0x10,0x3C,0x00,0xE0,0x1F,0x00,0x00,0xE0,0x10,0x3C,0x1F,0xC0,0x00,0x00},/*"W",55*/
{0x10,0x04,0x18,0x0C,0x16,0x34,0x01,0xC0,0x01,0xC0,0x16,0x34,0x18,0x0C,0x10,0x04},/*"X",56*/
{0x10,0x00,0x1C,0x00,0x13,0x04,0x00,0xFC,0x13,0x04,0x1C,0x00,0x10,0x00,0x00,0x00},/*"Y",57*/
{0x08,0x04,0x10,0x1C,0x10,0x64,0x10,0x84,0x13,0x04,0x1C,0x04,0x10,0x18,0x00,0x00},/*"Z",58*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFE,0x40,0x02,0x40,0x02,0x40,0x02,0x00,0x00},/*"[",59*/
{0x00,0x00,0x30,0x00,0x0C,0x00,0x03,0x80,0x00,0x60,0x00,0x1C,0x00,0x03,0x00,0x00},/*"\",60*/
{0x00,0x00,0x40,0x02,0x40,0x02,0x40,0x02,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00},/*"]",61*/
{0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00},/*"^",62*/
{0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01},/*"_",63*/
{0x00,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
{0x00,0x00,0x00,0x98,0x01,0x24,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xFC,0x00,0x04},/*"a",65*/
{0x10,0x00,0x1F,0xFC,0x00,0x88,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*"b",66*/
{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x00},/*"c",67*/
{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x11,0x08,0x1F,0xFC,0x00,0x04},/*"d",68*/
{0x00,0x00,0x00,0xF8,0x01,0x44,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xC8,0x00,0x00},/*"e",69*/
{0x00,0x00,0x01,0x04,0x01,0x04,0x0F,0xFC,0x11,0x04,0x11,0x04,0x11,0x00,0x18,0x00},/*"f",70*/
{0x00,0x00,0x00,0xD6,0x01,0x29,0x01,0x29,0x01,0x29,0x01,0xC9,0x01,0x06,0x00,0x00},/*"g",71*/
{0x10,0x04,0x1F,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*"h",72*/
{0x00,0x00,0x01,0x04,0x19,0x04,0x19,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"i",73*/
{0x00,0x00,0x00,0x03,0x00,0x01,0x01,0x01,0x19,0x01,0x19,0xFE,0x00,0x00,0x00,0x00},/*"j",74*/
{0x10,0x04,0x1F,0xFC,0x00,0x24,0x00,0x40,0x01,0xB4,0x01,0x0C,0x01,0x04,0x00,0x00},/*"k",75*/
{0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"l",76*/
{0x01,0x04,0x01,0xFC,0x01,0x04,0x01,0x00,0x01,0xFC,0x01,0x04,0x01,0x00,0x00,0xFC},/*"m",77*/
{0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*"n",78*/
{0x00,0x00,0x00,0xF8,0x01,0x04,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0xF8,0x00,0x00},/*"o",79*/
{0x01,0x01,0x01,0xFF,0x00,0x85,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*"p",80*/
{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x05,0x01,0xFF,0x00,0x01},/*"q",81*/
{0x01,0x04,0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x04,0x01,0x00,0x01,0x80,0x00,0x00},/*"r",82*/
{0x00,0x00,0x00,0xCC,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x98,0x00,0x00},/*"s",83*/
{0x00,0x00,0x01,0x00,0x01,0x00,0x07,0xF8,0x01,0x04,0x01,0x04,0x00,0x00,0x00,0x00},/*"t",84*/
{0x01,0x00,0x01,0xF8,0x00,0x04,0x00,0x04,0x00,0x04,0x01,0x08,0x01,0xFC,0x00,0x04},/*"u",85*/
{0x01,0x00,0x01,0x80,0x01,0x70,0x00,0x0C,0x00,0x10,0x01,0x60,0x01,0x80,0x01,0x00},/*"v",86*/
{0x01,0xF0,0x01,0x0C,0x00,0x30,0x01,0xC0,0x00,0x30,0x01,0x0C,0x01,0xF0,0x01,0x00},/*"w",87*/
{0x00,0x00,0x01,0x04,0x01,0x8C,0x00,0x74,0x01,0x70,0x01,0x8C,0x01,0x04,0x00,0x00},/*"x",88*/
{0x01,0x01,0x01,0x81,0x01,0x71,0x00,0x0E,0x00,0x18,0x01,0x60,0x01,0x80,0x01,0x00},/*"y",89*/
{0x00,0x00,0x01,0x84,0x01,0x0C,0x01,0x34,0x01,0x44,0x01,0x84,0x01,0x0C,0x00,0x00},/*"z",90*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x3E,0xFC,0x40,0x02,0x40,0x02},/*"{",91*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00},/*"|",92*/
{0x00,0x00,0x40,0x02,0x40,0x02,0x3E,0xFC,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
{0x00,0x00,0x60,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00},/*"~",94*/
};  
//24*24 ASICII
const unsigned char asc2_2412[95][36]={	  
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x80,0x38,0x0F,0xFE,0x38,0x0F,0x80,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x06,0x00,0x00,0x0C,0x00,0x00,0x38,0x00,0x00,0x31,0x00,0x00,0x06,0x00,0x00,0x0C,0x00,0x00,0x38,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00},/*""",2*/
{0x00,0x00,0x00,0x00,0x61,0x80,0x00,0x67,0xF8,0x07,0xF9,0x80,0x00,0x61,0x80,0x00,0x61,0x80,0x00,0x61,0x80,0x00,0x61,0x80,0x00,0x67,0xF8,0x07,0xF9,0x80,0x00,0x61,0x80,0x00,0x00,0x00},/*"#",3*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0xE0,0x03,0xE0,0xF0,0x06,0x30,0x08,0x04,0x18,0x08,0x1F,0xFF,0xFE,0x04,0x0E,0x08,0x07,0x87,0xF0,0x03,0x81,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},/*"$",4*/
{0x01,0xF0,0x00,0x06,0x0C,0x00,0x04,0x04,0x08,0x06,0x0C,0x70,0x01,0xF9,0xC0,0x00,0x0E,0x00,0x00,0x3B,0xE0,0x00,0xEC,0x18,0x07,0x08,0x08,0x04,0x0C,0x18,0x00,0x03,0xE0,0x00,0x00,0x00},/*"%",5*/
{0x00,0x01,0xE0,0x00,0x07,0xF0,0x03,0xF8,0x18,0x04,0x1C,0x08,0x04,0x17,0x08,0x07,0xE1,0xD0,0x03,0xC0,0xE0,0x00,0x23,0xB0,0x00,0x3C,0x08,0x00,0x20,0x08,0x00,0x00,0x10,0x00,0x00,0x00},/*"&",6*/
{0x00,0x00,0x00,0x01,0x00,0x00,0x31,0x00,0x00,0x32,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x01,0xFF,0xC0,0x07,0x80,0xF0,0x0C,0x00,0x18,0x10,0x00,0x04,0x20,0x00,0x02,0x00,0x00,0x00},/*"(",8*/
{0x00,0x00,0x00,0x20,0x00,0x02,0x10,0x00,0x04,0x0C,0x00,0x18,0x07,0x80,0xF0,0x01,0xFF,0xC0,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*")",9*/
{0x00,0x00,0x00,0x00,0x42,0x00,0x00,0x66,0x00,0x00,0x66,0x00,0x00,0x3C,0x00,0x00,0x18,0x00,0x03,0xFF,0xC0,0x00,0x18,0x00,0x00,0x3C,0x00,0x00,0x66,0x00,0x00,0x66,0x00,0x00,0x42,0x00},/*"*",10*/
{0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x01,0xFF,0xC0,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00},/*"+",11*/
{0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x31,0x00,0x00,0x32,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
{0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x00,0x00},/*"-",13*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
{0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x1C,0x00,0x00,0x70,0x00,0x01,0x80,0x00,0x0E,0x00,0x00,0x38,0x00,0x00,0xC0,0x00,0x07,0x00,0x00,0x1C,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00},/*"/",15*/
{0x00,0x00,0x00,0x00,0x7F,0x80,0x01,0xFF,0xE0,0x03,0x80,0x70,0x06,0x00,0x18,0x04,0x00,0x08,0x04,0x00,0x08,0x06,0x00,0x18,0x03,0x80,0x70,0x01,0xFF,0xE0,0x00,0x7F,0x80,0x00,0x00,0x00},/*"0",16*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x08,0x01,0x00,0x08,0x01,0x00,0x08,0x03,0xFF,0xF8,0x07,0xFF,0xF8,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00},/*"1",17*/
{0x00,0x00,0x00,0x01,0xC0,0x38,0x02,0xC0,0x58,0x04,0x00,0x98,0x04,0x01,0x18,0x04,0x02,0x18,0x04,0x04,0x18,0x06,0x1C,0x18,0x03,0xF8,0x18,0x01,0xE0,0xF8,0x00,0x00,0x00,0x00,0x00,0x00},/*"2",18*/
{0x00,0x00,0x00,0x01,0xC0,0xE0,0x03,0xC0,0xF0,0x04,0x00,0x08,0x04,0x08,0x08,0x04,0x08,0x08,0x06,0x18,0x08,0x03,0xF4,0x18,0x01,0xE7,0xF0,0x00,0x01,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},/*"3",19*/
{0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x0D,0x00,0x00,0x11,0x00,0x00,0x61,0x00,0x00,0x81,0x08,0x03,0x01,0x08,0x07,0xFF,0xF8,0x0F,0xFF,0xF8,0x00,0x01,0x08,0x00,0x01,0x08,0x00,0x00,0x00},/*"4",20*/
{0x00,0x00,0x00,0x00,0x00,0xE0,0x07,0xFC,0xD0,0x06,0x08,0x08,0x06,0x10,0x08,0x06,0x10,0x08,0x06,0x10,0x08,0x06,0x18,0x38,0x06,0x0F,0xF0,0x06,0x07,0xC0,0x00,0x00,0x00,0x00,0x00,0x00},/*"5",21*/
{0x00,0x00,0x00,0x00,0x3F,0x80,0x01,0xFF,0xE0,0x03,0x84,0x30,0x02,0x08,0x18,0x04,0x10,0x08,0x04,0x10,0x08,0x04,0x10,0x08,0x07,0x18,0x10,0x03,0x0F,0xF0,0x00,0x07,0xC0,0x00,0x00,0x00},/*"6",22*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x07,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0xF8,0x06,0x07,0xF8,0x06,0x18,0x00,0x06,0xE0,0x00,0x07,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00},/*"7",23*/
{0x00,0x00,0x00,0x01,0xE1,0xE0,0x03,0xF7,0xF0,0x06,0x34,0x10,0x04,0x18,0x08,0x04,0x18,0x08,0x04,0x0C,0x08,0x04,0x0C,0x08,0x06,0x16,0x18,0x03,0xF3,0xF0,0x01,0xC1,0xE0,0x00,0x00,0x00},/*"8",24*/
{0x00,0x00,0x00,0x00,0xF8,0x00,0x03,0xFC,0x30,0x03,0x06,0x38,0x04,0x02,0x08,0x04,0x02,0x08,0x04,0x02,0x08,0x04,0x04,0x10,0x03,0x08,0xF0,0x01,0xFF,0xC0,0x00,0x7F,0x00,0x00,0x00,0x00},/*"9",25*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x38,0x00,0x70,0x38,0x00,0x70,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x1A,0x00,0x30,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x14,0x00,0x00,0x22,0x00,0x00,0x41,0x00,0x00,0x80,0x80,0x01,0x00,0x40,0x02,0x00,0x20,0x04,0x00,0x10,0x08,0x00,0x08,0x00,0x00,0x00},/*"<",28*/
{0x00,0x00,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x21,0x00,0x00,0x00,0x00},/*"=",29*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x08,0x04,0x00,0x10,0x02,0x00,0x20,0x01,0x00,0x40,0x00,0x80,0x80,0x00,0x41,0x00,0x00,0x22,0x00,0x00,0x14,0x00,0x00,0x08,0x00,0x00,0x00,0x00},/*">",30*/
{0x00,0x00,0x00,0x03,0xC0,0x00,0x04,0xC0,0x00,0x04,0x00,0x00,0x08,0x00,0x38,0x08,0x0F,0x38,0x08,0x08,0x38,0x08,0x10,0x00,0x0C,0x30,0x00,0x07,0xE0,0x00,0x03,0xC0,0x00,0x00,0x00,0x00},/*"?",31*/
{0x00,0x00,0x00,0x00,0x3F,0x80,0x00,0xFF,0xE0,0x03,0x80,0x70,0x02,0x0F,0x10,0x06,0x70,0x88,0x04,0xC0,0x88,0x04,0x83,0x08,0x04,0x7F,0x88,0x02,0xC0,0x90,0x03,0x01,0x20,0x00,0xFE,0x40},/*"@",32*/
{0x00,0x00,0x08,0x00,0x00,0x18,0x00,0x01,0xF8,0x00,0x3E,0x08,0x01,0xC2,0x00,0x07,0x02,0x00,0x07,0xE2,0x00,0x00,0xFE,0x00,0x00,0x1F,0xC8,0x00,0x01,0xF8,0x00,0x00,0x38,0x00,0x00,0x08},/*"A",33*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x08,0x08,0x04,0x08,0x08,0x04,0x08,0x08,0x04,0x08,0x08,0x06,0x18,0x08,0x03,0xF4,0x18,0x01,0xE7,0xF0,0x00,0x01,0xE0,0x00,0x00,0x00},/*"B",34*/
{0x00,0x00,0x00,0x00,0x3F,0x80,0x01,0xFF,0xE0,0x03,0x80,0x70,0x02,0x00,0x18,0x04,0x00,0x08,0x04,0x00,0x08,0x04,0x00,0x08,0x04,0x00,0x10,0x06,0x00,0x20,0x07,0x80,0xC0,0x00,0x00,0x00},/*"C",35*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x00,0x08,0x04,0x00,0x08,0x04,0x00,0x08,0x04,0x00,0x18,0x02,0x00,0x10,0x03,0x80,0x70,0x01,0xFF,0xE0,0x00,0x7F,0x80,0x00,0x00,0x00},/*"D",36*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x08,0x08,0x04,0x08,0x08,0x04,0x08,0x08,0x04,0x08,0x08,0x04,0x3E,0x08,0x04,0x00,0x08,0x06,0x00,0x18,0x01,0x00,0x60,0x00,0x00,0x00},/*"E",37*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x08,0x08,0x04,0x08,0x00,0x04,0x08,0x00,0x04,0x08,0x00,0x04,0x3E,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00},/*"F",38*/
{0x00,0x00,0x00,0x00,0x3F,0x80,0x01,0xFF,0xE0,0x03,0x80,0x70,0x06,0x00,0x18,0x04,0x00,0x08,0x04,0x02,0x08,0x04,0x02,0x08,0x02,0x03,0xF0,0x07,0x83,0xF0,0x00,0x02,0x00,0x00,0x02,0x00},/*"G",39*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x08,0x08,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x04,0x08,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x00,0x08},/*"H",40*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x08,0x04,0x00,0x08,0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x00,0x08,0x04,0x00,0x08,0x04,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00},/*"I",41*/
{0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x07,0x00,0x00,0x01,0x04,0x00,0x01,0x04,0x00,0x01,0x04,0x00,0x03,0x07,0xFF,0xFE,0x07,0xFF,0xFC,0x04,0x00,0x00,0x04,0x00,0x00,0x04,0x00,0x00},/*"J",42*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x0C,0x08,0x00,0x18,0x00,0x00,0x3E,0x00,0x04,0xC7,0x80,0x05,0x03,0xC8,0x06,0x00,0xF8,0x04,0x00,0x38,0x04,0x00,0x18,0x00,0x00,0x08},/*"K",43*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x18,0x00,0x00,0x60,0x00,0x00,0x00},/*"L",44*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0x80,0x08,0x07,0xFC,0x00,0x00,0x7F,0xC0,0x00,0x03,0xF8,0x00,0x07,0xC0,0x00,0x78,0x00,0x07,0x80,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x00,0x08},/*"M",45*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0x00,0x08,0x03,0xC0,0x00,0x00,0xE0,0x00,0x00,0x38,0x00,0x00,0x1E,0x00,0x00,0x07,0x00,0x00,0x01,0xC0,0x04,0x00,0xF0,0x07,0xFF,0xF8,0x04,0x00,0x00},/*"N",46*/
{0x00,0x00,0x00,0x00,0x7F,0x80,0x01,0xFF,0xE0,0x03,0x80,0x70,0x06,0x00,0x18,0x04,0x00,0x08,0x04,0x00,0x08,0x06,0x00,0x18,0x03,0x00,0x30,0x01,0xFF,0xE0,0x00,0x7F,0x80,0x00,0x00,0x00},/*"O",47*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x04,0x08,0x04,0x04,0x00,0x04,0x04,0x00,0x04,0x04,0x00,0x04,0x04,0x00,0x06,0x0C,0x00,0x03,0xF8,0x00,0x01,0xF0,0x00,0x00,0x00,0x00},/*"P",48*/
{0x00,0x00,0x00,0x00,0x7F,0x80,0x01,0xFF,0xE0,0x03,0x80,0x70,0x06,0x00,0x88,0x04,0x00,0x88,0x04,0x00,0xC8,0x06,0x00,0x3C,0x03,0x00,0x3E,0x01,0xFF,0xE6,0x00,0x7F,0x84,0x00,0x00,0x00},/*"Q",49*/
{0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x08,0x08,0x04,0x08,0x00,0x04,0x0C,0x00,0x04,0x0F,0x00,0x04,0x0B,0xC0,0x06,0x10,0xF0,0x03,0xF0,0x38,0x01,0xE0,0x08,0x00,0x00,0x08},/*"R",50*/
{0x00,0x00,0x00,0x01,0xE0,0xF8,0x03,0xF0,0x30,0x06,0x30,0x10,0x04,0x18,0x08,0x04,0x18,0x08,0x04,0x0C,0x08,0x04,0x0C,0x08,0x02,0x06,0x18,0x02,0x07,0xF0,0x07,0x81,0xE0,0x00,0x00,0x00},/*"S",51*/
{0x01,0x80,0x00,0x06,0x00,0x00,0x04,0x00,0x00,0x04,0x00,0x00,0x04,0x00,0x08,0x07,0xFF,0xF8,0x07,0xFF,0xF8,0x04,0x00,0x08,0x04,0x00,0x00,0x04,0x00,0x00,0x06,0x00,0x00,0x01,0x80,0x00},/*"T",52*/
{0x04,0x00,0x00,0x07,0xFF,0xE0,0x07,0xFF,0xF0,0x04,0x00,0x18,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x04,0x00,0x10,0x07,0xFF,0xE0,0x04,0x00,0x00},/*"U",53*/
{0x04,0x00,0x00,0x06,0x00,0x00,0x07,0xE0,0x00,0x07,0xFE,0x00,0x04,0x1F,0xE0,0x00,0x01,0xF8,0x00,0x00,0x38,0x00,0x01,0xE0,0x04,0x3E,0x00,0x07,0xC0,0x00,0x06,0x00,0x00,0x04,0x00,0x00},/*"V",54*/
{0x04,0x00,0x00,0x07,0xE0,0x00,0x07,0xFF,0xC0,0x04,0x1F,0xF8,0x00,0x07,0xC0,0x07,0xF8,0x00,0x07,0xFF,0x80,0x04,0x3F,0xF8,0x00,0x07,0xC0,0x04,0xF8,0x00,0x07,0x00,0x00,0x04,0x00,0x00},/*"W",55*/
{0x00,0x00,0x00,0x04,0x00,0x08,0x06,0x00,0x18,0x07,0xC0,0x78,0x05,0xF1,0xC8,0x00,0x3E,0x00,0x00,0x1F,0x80,0x04,0x63,0xE8,0x07,0x80,0xF8,0x06,0x00,0x18,0x04,0x00,0x08,0x00,0x00,0x00},/*"X",56*/
{0x04,0x00,0x00,0x06,0x00,0x00,0x07,0x80,0x00,0x07,0xE0,0x08,0x04,0x7C,0x08,0x00,0x1F,0xF8,0x00,0x07,0xF8,0x00,0x18,0x08,0x04,0xE0,0x08,0x07,0x00,0x00,0x06,0x00,0x00,0x04,0x00,0x00},/*"Y",57*/
{0x00,0x00,0x00,0x01,0x00,0x08,0x06,0x00,0x38,0x04,0x00,0xF8,0x04,0x03,0xE8,0x04,0x0F,0x08,0x04,0x7C,0x08,0x05,0xF0,0x08,0x07,0xC0,0x08,0x07,0x00,0x18,0x04,0x00,0x60,0x00,0x00,0x00},/*"Z",58*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFE,0x20,0x00,0x02,0x20,0x00,0x02,0x20,0x00,0x02,0x20,0x00,0x02,0x20,0x00,0x02,0x00,0x00,0x00},/*"[",59*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x07,0x00,0x00,0x00,0xC0,0x00,0x00,0x38,0x00,0x00,0x06,0x00,0x00,0x01,0xC0,0x00,0x00,0x30,0x00,0x00,0x0E,0x00,0x00,0x01,0x00,0x00,0x00},/*"\",60*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x02,0x20,0x00,0x02,0x20,0x00,0x02,0x20,0x00,0x02,0x20,0x00,0x02,0x3F,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"]",61*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x10,0x00,0x00,0x30,0x00,0x00,0x20,0x00,0x00,0x30,0x00,0x00,0x10,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
{0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01},/*"_",63*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
{0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x19,0xF8,0x00,0x1B,0x18,0x00,0x22,0x08,0x00,0x26,0x08,0x00,0x24,0x08,0x00,0x24,0x10,0x00,0x3F,0xF8,0x00,0x1F,0xF8,0x00,0x00,0x08,0x00,0x00,0x18},/*"a",65*/
{0x00,0x00,0x00,0x04,0x00,0x00,0x07,0xFF,0xF8,0x0F,0xFF,0xF0,0x00,0x18,0x18,0x00,0x10,0x08,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x30,0x18,0x00,0x1F,0xF0,0x00,0x0F,0xC0,0x00,0x00,0x00},/*"b",66*/
{0x00,0x00,0x00,0x00,0x07,0xC0,0x00,0x1F,0xF0,0x00,0x18,0x30,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x3C,0x08,0x00,0x1C,0x10,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00},/*"c",67*/
{0x00,0x00,0x00,0x00,0x07,0xC0,0x00,0x1F,0xF0,0x00,0x38,0x18,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x20,0x08,0x04,0x10,0x10,0x07,0xFF,0xF8,0x0F,0xFF,0xF0,0x00,0x00,0x10,0x00,0x00,0x00},/*"d",68*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xC0,0x00,0x1F,0xF0,0x00,0x12,0x30,0x00,0x22,0x18,0x00,0x22,0x08,0x00,0x22,0x08,0x00,0x32,0x08,0x00,0x1E,0x10,0x00,0x0E,0x20,0x00,0x00,0x00},/*"e",69*/
{0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x08,0x00,0x20,0x08,0x01,0xFF,0xF8,0x03,0xFF,0xF8,0x06,0x20,0x08,0x04,0x20,0x08,0x04,0x20,0x08,0x07,0x20,0x00,0x03,0x00,0x00,0x00,0x00,0x00},/*"f",70*/
{0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x0E,0x6E,0x00,0x1F,0xF3,0x00,0x31,0xB1,0x00,0x20,0xB1,0x00,0x20,0xB1,0x00,0x31,0x91,0x00,0x1F,0x13,0x00,0x2E,0x1E,0x00,0x20,0x0E,0x00,0x30,0x00},/*"g",71*/
{0x00,0x00,0x00,0x04,0x00,0x08,0x07,0xFF,0xF8,0x0F,0xFF,0xF8,0x00,0x10,0x08,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0x20,0x08,0x00,0x3F,0xF8,0x00,0x1F,0xF8,0x00,0x00,0x08,0x00,0x00,0x00},/*"h",72*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x20,0x08,0x06,0x3F,0xF8,0x06,0x3F,0xF8,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00},/*"i",73*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x20,0x01,0x00,0x20,0x01,0x00,0x20,0x03,0x06,0x3F,0xFE,0x06,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"j",74*/
{0x00,0x00,0x00,0x04,0x00,0x08,0x07,0xFF,0xF8,0x0F,0xFF,0xF8,0x00,0x01,0x88,0x00,0x03,0x00,0x00,0x2F,0xC0,0x00,0x38,0xF8,0x00,0x20,0x38,0x00,0x20,0x08,0x00,0x00,0x08,0x00,0x00,0x00},/*"k",75*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x08,0x04,0x00,0x08,0x04,0x00,0x08,0x07,0xFF,0xF8,0x0F,0xFF,0xF8,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00},/*"l",76*/
{0x00,0x20,0x08,0x00,0x3F,0xF8,0x00,0x3F,0xF8,0x00,0x10,0x08,0x00,0x20,0x00,0x00,0x3F,0xF8,0x00,0x3F,0xF8,0x00,0x10,0x08,0x00,0x20,0x00,0x00,0x3F,0xF8,0x00,0x3F,0xF8,0x00,0x00,0x08},/*"m",77*/
{0x00,0x00,0x00,0x00,0x20,0x08,0x00,0x3F,0xF8,0x00,0x3F,0xF8,0x00,0x10,0x08,0x00,0x10,0x00,0x00,0x20,0x00,0x00,0x20,0x08,0x00,0x3F,0xF8,0x00,0x1F,0xF8,0x00,0x00,0x08,0x00,0x00,0x00},/*"n",78*/
{0x00,0x00,0x00,0x00,0x07,0xC0,0x00,0x0F,0xF0,0x00,0x18,0x30,0x00,0x30,0x08,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x30,0x08,0x00,0x18,0x30,0x00,0x0F,0xF0,0x00,0x07,0xC0,0x00,0x00,0x00},/*"o",79*/
{0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x3F,0xFF,0x00,0x3F,0xFF,0x00,0x10,0x11,0x00,0x20,0x09,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x30,0x38,0x00,0x1F,0xF0,0x00,0x0F,0xC0,0x00,0x00,0x00},/*"p",80*/
{0x00,0x00,0x00,0x00,0x07,0xC0,0x00,0x1F,0xF0,0x00,0x38,0x18,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x20,0x09,0x00,0x10,0x11,0x00,0x1F,0xFF,0x00,0x3F,0xFF,0x00,0x00,0x01,0x00,0x00,0x00},/*"q",81*/
{0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x3F,0xF8,0x00,0x3F,0xF8,0x00,0x08,0x08,0x00,0x10,0x08,0x00,0x20,0x08,0x00,0x20,0x00,0x00,0x30,0x00,0x00,0x30,0x00,0x00,0x00,0x00},/*"r",82*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x78,0x00,0x1E,0x18,0x00,0x33,0x08,0x00,0x23,0x08,0x00,0x21,0x08,0x00,0x21,0x88,0x00,0x21,0x98,0x00,0x30,0xF0,0x00,0x38,0x60,0x00,0x00,0x00},/*"s",83*/
{0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0xFF,0xF0,0x03,0xFF,0xF8,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00},/*"t",84*/
{0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x3F,0xF0,0x00,0x7F,0xF8,0x00,0x00,0x18,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x20,0x10,0x00,0x3F,0xF8,0x00,0x7F,0xF0,0x00,0x00,0x10,0x00,0x00,0x00},/*"u",85*/
{0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x30,0x00,0x00,0x3C,0x00,0x00,0x3F,0x80,0x00,0x23,0xF0,0x00,0x00,0x78,0x00,0x00,0x70,0x00,0x23,0x80,0x00,0x3C,0x00,0x00,0x30,0x00,0x00,0x20,0x00},/*"v",86*/
{0x00,0x20,0x00,0x00,0x3C,0x00,0x00,0x3F,0xE0,0x00,0x23,0xF8,0x00,0x00,0xE0,0x00,0x27,0x00,0x00,0x3E,0x00,0x00,0x3F,0xE0,0x00,0x21,0xF8,0x00,0x01,0xE0,0x00,0x3E,0x00,0x00,0x20,0x00},/*"w",87*/
{0x00,0x00,0x00,0x00,0x20,0x08,0x00,0x20,0x08,0x00,0x38,0x38,0x00,0x3E,0x68,0x00,0x27,0x80,0x00,0x03,0xC8,0x00,0x2C,0xF8,0x00,0x38,0x38,0x00,0x20,0x18,0x00,0x20,0x08,0x00,0x00,0x00},/*"x",88*/
{0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x30,0x03,0x00,0x3C,0x01,0x00,0x3F,0x83,0x00,0x23,0xEC,0x00,0x00,0x70,0x00,0x23,0x80,0x00,0x3C,0x00,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0x00,0x00},/*"y",89*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x08,0x00,0x20,0x38,0x00,0x20,0xF8,0x00,0x23,0xE8,0x00,0x2F,0x88,0x00,0x3E,0x08,0x00,0x38,0x08,0x00,0x20,0x18,0x00,0x00,0x70,0x00,0x00,0x00},/*"z",90*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x14,0x00,0x1F,0xF7,0xFC,0x30,0x00,0x06,0x20,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00},/*"{",91*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"|",92*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x02,0x30,0x00,0x06,0x1F,0xF7,0xFC,0x00,0x14,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
{0x00,0x00,0x00,0x18,0x00,0x00,0x60,0x00,0x00,0x40,0x00,0x00,0x40,0x00,0x00,0x20,0x00,0x00,0x10,0x00,0x00,0x08,0x00,0x00,0x04,0x00,0x00,0x04,0x00,0x00,0x0C,0x00,0x00,0x10,0x00,0x00},/*"~",94*/
};      
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	   (J " ..\HARDWARE\LED\led.h       ..\SYSTEM\sys\sys.h       ..\USER\stm32f10x.h      ..\CORE\core_cm3.h     9 -D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h     ' ..\USER\system_stm32f10x.h     % ..\USER\stm32f10x_conf.h     =3 '..\STM32F10x_FWLib\inc\stm32f10x_adc.h       ..\USER\stm32f10x.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_bkp.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_can.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_cec.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_crc.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_dac.h     6 *..\STM32F10x_FWLib\inc\stm32f10x_dbgmcu.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_dma.h     4 (..\STM32F10x_FWLib\inc\stm32f10x_exti.h     s5 )..\STM32F10x_FWLib\inc\stm32f10x_flash.h     4 (..\STM32F10x_FWLib\inc\stm32f10x_fsmc.h     4 (..\STM32F10x_FWLib\inc\stm32f10x_gpio.h     33 '..\STM32F10x_FWLib\inc\stm32f10x_i2c.h     14 (..\STM32F10x_FWLib\inc\stm32f10x_iwdg.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_pwr.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_rcc.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_rtc.h     4 (..\STM32F10x_FWLib\inc\stm32f10x_sdio.h     ~3 '..\STM32F10x_FWLib\inc\stm32f10x_spi.h     3 '..\STM32F10x_FWLib\inc\stm32f10x_tim.h     5 )..\STM32F10x_FWLib\inc\stm32f10x_usart.h     4 (..\STM32F10x_FWLib\inc\stm32f10x_wwdg.h     t* ..\STM32F10x_FWLib\inc\misc.h     $ ..\SYSTEM\delay\delay.h     $ ..\SYSTEM\usart\usart.h     8 ,D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h     l" ..\HARDWARE\LCD\lcd.h     9 -D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h     " ..\HARDWARE\KEY\key.h     x" ..\HARDWARE\SPI\spi.h     s) ..\HARDWARE\NRF24L01\24l01.h     n main.c      P    __LED_H  P    __SYS_H Y P    __STM32F10x_H  P   __cplusplus 
 P   STM32F10X_HD n P   USE_STDPERIPH_DRIVER w P   STM32F10X_CL k P    
HSE_VALUE  P    HSE_STARTUP_TIMEOUT  P    
HSI_VALUE + P    #__STM32F10X_STDPERIPH_VERSION_MAIN V+ P    #__STM32F10X_STDPERIPH_VERSION_SUB1 `+ P    #__STM32F10X_STDPERIPH_VERSION_SUB2 _) P    !__STM32F10X_STDPERIPH_VERSION_RC & P    __STM32F10X_STDPERIPH_VERSION  P   STM32F10X_XL V P    __MPU_PRESENT  P    __NVIC_PRIO_BITS  P    __Vendor_SysTickConfig  8"  IRQn ]  "  NonMaskableInt_IRQn s  "  MemoryManagement_IRQn o  "  BusFault_IRQn   "  UsageFault_IRQn    "  SVCall_IRQn   "  DebugMonitor_IRQn   "  PendSV_IRQn   "  SysTick_IRQn -  "  
WWDG_IRQn   "  	PVD_IRQn   "  TAMPER_IRQn 0  "  	RTC_IRQn   "  FLASH_IRQn   "  	RCC_IRQn '  "  EXTI0_IRQn   "  EXTI1_IRQn   "  EXTI2_IRQn   "  EXTI3_IRQn   "  EXTI4_IRQn   "  DMA1_Channel1_IRQn   "  DMA1_Channel2_IRQn   "  DMA1_Channel3_IRQn   "  DMA1_Channel4_IRQn   "  DMA1_Channel5_IRQn   "  DMA1_Channel6_IRQn   "  DMA1_Channel7_IRQn  P   STM32F10X_LD j P   STM32F10X_LD_VL c P   STM32F10X_MD i P   STM32F10X_MD_VL b  "  ADC1_2_IRQn o  "  USB_HP_CAN1_TX_IRQn   "  USB_LP_CAN1_RX0_IRQn g  "  CAN1_RX1_IRQn   "  CAN1_SCE_IRQn   "  EXTI9_5_IRQn   "  TIM1_BRK_IRQn   "  TIM1_UP_IRQn   "  TIM1_TRG_COM_IRQn H  "  TIM1_CC_IRQn   "  
TIM2_IRQn   "  
TIM3_IRQn   "  
TIM4_IRQn   "  I2C1_EV_IRQn   "  I2C1_ER_IRQn   "  I2C2_EV_IRQn   "  I2C2_ER_IRQn   "  
SPI1_IRQn   "  
SPI2_IRQn   "  USART1_IRQn 9  "  USART2_IRQn 8  "  USART3_IRQn 7  "  EXTI15_10_IRQn   "  RTCAlarm_IRQn   "  USBWakeUp_IRQn   "  TIM8_BRK_IRQn   "  TIM8_UP_IRQn   "  TIM8_TRG_COM_IRQn A  "  TIM8_CC_IRQn   "  
ADC3_IRQn   "  
FSMC_IRQn   "  
SDIO_IRQn   "  
TIM5_IRQn   "  
SPI3_IRQn   "  UART4_IRQn   "  UART5_IRQn   "  
TIM6_IRQn   "  
TIM7_IRQn   "  DMA2_Channel1_IRQn   "  DMA2_Channel2_IRQn   "  DMA2_Channel3_IRQn  P   STM32F10X_HD_VL g  "  DMA2_Channel4_5_IRQn     
IRQn_Type  P    __CM3_CORE_H__ A! P    __CM3_CMSIS_VERSION_MAIN 3  P    __CM3_CMSIS_VERSION_SUB p P    __CM3_CMSIS_VERSION  P    __CORTEX_M x P    __stdint_h  P    __ARMCLIB_VERSION l P   __INT64_TYPE__ ; P    __INT64  P    __INT64_C_SUFFIX__   P    	__PASTE2 N P    __PASTE  P    
__INT64_C  P    __UINT64_C  P   __ARMCC_VERSION  P    __LONGLONG  P    __STDINT_DECLS Q P    	__CLIBNS B    int8_t     int16_t n    int32_t p    int64_t k    uint8_t (    	uint16_t     	uint32_t     	uint64_t     int_least8_t     int_least16_t     int_least32_t     int_least64_t     uint_least8_t     uint_least16_t s    uint_least32_t u    uint_least64_t p    int_fast8_t     int_fast16_t W    int_fast32_t Y    int_fast64_t T    uint_fast8_t     uint_fast16_t     uint_fast32_t     uint_fast64_t  P   __sizeof_ptr     	intptr_t }    
uintptr_t     	intmax_t     
uintmax_t  P    	INT8_MIN U P    
INT16_MIN $ P    
INT32_MIN & P    
INT64_MIN ! P    	INT8_MAX S P    
INT16_MAX " P    
INT32_MAX $ P    
INT64_MAX  P    
UINT8_MAX  P    UINT16_MAX  P    UINT32_MAX  P    UINT64_MAX  P    INT_LEAST8_MIN q P    INT_LEAST16_MIN @ P    INT_LEAST32_MIN B P    INT_LEAST64_MIN = P    INT_LEAST8_MAX o P    INT_LEAST16_MAX > P    INT_LEAST32_MAX @ P    INT_LEAST64_MAX ; P    UINT_LEAST8_MAX  P    UINT_LEAST16_MAX  P    UINT_LEAST32_MAX  P    UINT_LEAST64_MAX  P    INT_FAST8_MIN  P    INT_FAST16_MIN  P    INT_FAST32_MIN  P    INT_FAST64_MIN  P    INT_FAST8_MAX  P    INT_FAST16_MAX  P    INT_FAST32_MAX  P    INT_FAST64_MAX  P    UINT_FAST8_MAX e P    UINT_FAST16_MAX 4 P    UINT_FAST32_MAX 6 P    UINT_FAST64_MAX 1 P    INTPTR_MIN  P    INTPTR_MAX  P    UINTPTR_MAX : P    INTMAX_MIN  P    INTMAX_MAX  P    UINTMAX_MAX J P    PTRDIFF_MIN c P    PTRDIFF_MAX a P    SIG_ATOMIC_MIN m P    SIG_ATOMIC_MAX k P    	SIZE_MAX ; P    
WCHAR_MIN  P    
WCHAR_MAX  P    	WINT_MIN 6 P    	WINT_MAX 4 P    INT8_C  P    INT16_C  P    INT32_C  P    INT64_C  P    UINT8_C  P    	UINT16_C r P    	UINT32_C t P    	UINT64_C o P    	INTMAX_C H P    
UINTMAX_C  P    __I  P    __O  P    __IO m 8  
<unnamed> Q  <"  ISER q  <" `
RESERVED0   <"  ICER   <" `	RSERVED1   <"  ISPR f  <" `
RESERVED2   <"  ICPR v  <" `
RESERVED3   <"  IABR   <" 
RESERVED4 D  <" IP =  <" 
RESERVED5   
" STIR     
NVIC_Type  8  
<unnamed> Q  
" CPUID l  
" ICSR   
" VTOR   
" AIRCR p  
" SCR   
" CCR   <" SHP   
" SHCSR ^  
" CFSR   
" HFSR   
" DFSR   
" MMFAR n  
" BFAR   
" AFSR   <" PFR   
" DFR 	  
" ADR   <" MMFR s  <" ISAR r    	SCB_Type " P    SCB_CPUID_IMPLEMENTER_Pos " P    SCB_CPUID_IMPLEMENTER_Msk  P    SCB_CPUID_VARIANT_Pos  P    SCB_CPUID_VARIANT_Msk  P    SCB_CPUID_PARTNO_Pos 3 P    SCB_CPUID_PARTNO_Msk : P    SCB_CPUID_REVISION_Pos  P    SCB_CPUID_REVISION_Msk   P    SCB_ICSR_NMIPENDSET_Pos N  P    SCB_ICSR_NMIPENDSET_Msk U P    SCB_ICSR_PENDSVSET_Pos  P    SCB_ICSR_PENDSVSET_Msk  P    SCB_ICSR_PENDSVCLR_Pos  P    SCB_ICSR_PENDSVCLR_Msk  P    SCB_ICSR_PENDSTSET_Pos  P    SCB_ICSR_PENDSTSET_Msk  P    SCB_ICSR_PENDSTCLR_Pos  P    SCB_ICSR_PENDSTCLR_Msk   P    SCB_ICSR_ISRPREEMPT_Pos :  P    SCB_ICSR_ISRPREEMPT_Msk A  P    SCB_ICSR_ISRPENDING_Pos R  P    SCB_ICSR_ISRPENDING_Msk Y! P    SCB_ICSR_VECTPENDING_Pos ! P    SCB_ICSR_VECTPENDING_Msk  P    SCB_ICSR_RETTOBASE_Pos  P    SCB_ICSR_RETTOBASE_Msk   P    SCB_ICSR_VECTACTIVE_Pos W  P    SCB_ICSR_VECTACTIVE_Msk ^ P    SCB_VTOR_TBLBASE_Pos 4 P    SCB_VTOR_TBLBASE_Msk ; P    SCB_VTOR_TBLOFF_Pos v P    SCB_VTOR_TBLOFF_Msk } P    SCB_AIRCR_VECTKEY_Pos  P    SCB_AIRCR_VECTKEY_Msk " P    SCB_AIRCR_VECTKEYSTAT_Pos " P    SCB_AIRCR_VECTKEYSTAT_Msk   P    SCB_AIRCR_ENDIANESS_Pos k  P    SCB_AIRCR_ENDIANESS_Msk r P    SCB_AIRCR_PRIGROUP_Pos  P    SCB_AIRCR_PRIGROUP_Msk " P    SCB_AIRCR_SYSRESETREQ_Pos " P    SCB_AIRCR_SYSRESETREQ_Msk $ P    SCB_AIRCR_VECTCLRACTIVE_Pos .$ P    SCB_AIRCR_VECTCLRACTIVE_Msk 5  P    SCB_AIRCR_VECTRESET_Pos P  P    SCB_AIRCR_VECTRESET_Msk W P    SCB_SCR_SEVONPEND_Pos  P    SCB_SCR_SEVONPEND_Msk  P    SCB_SCR_SLEEPDEEP_Pos  P    SCB_SCR_SLEEPDEEP_Msk   P    SCB_SCR_SLEEPONEXIT_Pos >  P    SCB_SCR_SLEEPONEXIT_Msk E P    SCB_CCR_STKALIGN_Pos G P    SCB_CCR_STKALIGN_Msk N P    SCB_CCR_BFHFNMIGN_Pos  P    SCB_CCR_BFHFNMIGN_Msk  P    SCB_CCR_DIV_0_TRP_Pos  P    SCB_CCR_DIV_0_TRP_Msk   P    SCB_CCR_UNALIGN_TRP_Pos ;  P    SCB_CCR_UNALIGN_TRP_Msk B! P    SCB_CCR_USERSETMPEND_Pos ! P    SCB_CCR_USERSETMPEND_Msk # P    SCB_CCR_NONBASETHRDENA_Pos # P    SCB_CCR_NONBASETHRDENA_Msk " P    SCB_SHCSR_USGFAULTENA_Pos " P    SCB_SHCSR_USGFAULTENA_Msk " P    SCB_SHCSR_BUSFAULTENA_Pos " P    SCB_SHCSR_BUSFAULTENA_Msk " P    SCB_SHCSR_MEMFAULTENA_Pos " P    SCB_SHCSR_MEMFAULTENA_Msk # P    SCB_SHCSR_SVCALLPENDED_Pos x# P    SCB_SHCSR_SVCALLPENDED_Msk % P    SCB_SHCSR_BUSFAULTPENDED_Pos % P    SCB_SHCSR_BUSFAULTPENDED_Msk % P    SCB_SHCSR_MEMFAULTPENDED_Pos % P    SCB_SHCSR_MEMFAULTPENDED_Msk % P    SCB_SHCSR_USGFAULTPENDED_Pos % P    SCB_SHCSR_USGFAULTPENDED_Msk ! P    SCB_SHCSR_SYSTICKACT_Pos ! P    SCB_SHCSR_SYSTICKACT_Msk   P    SCB_SHCSR_PENDSVACT_Pos K  P    SCB_SHCSR_PENDSVACT_Msk R! P    SCB_SHCSR_MONITORACT_Pos ! P    SCB_SHCSR_MONITORACT_Msk   P    SCB_SHCSR_SVCALLACT_Pos V  P    SCB_SHCSR_SVCALLACT_Msk ]" P    SCB_SHCSR_USGFAULTACT_Pos " P    SCB_SHCSR_USGFAULTACT_Msk " P    SCB_SHCSR_BUSFAULTACT_Pos " P    SCB_SHCSR_BUSFAULTACT_Msk " P    SCB_SHCSR_MEMFAULTACT_Pos " P    SCB_SHCSR_MEMFAULTACT_Msk   P    SCB_CFSR_USGFAULTSR_Pos 8  P    SCB_CFSR_USGFAULTSR_Msk ?  P    SCB_CFSR_BUSFAULTSR_Pos =  P    SCB_CFSR_BUSFAULTSR_Msk D  P    SCB_CFSR_MEMFAULTSR_Pos H  P    SCB_CFSR_MEMFAULTSR_Msk O P    SCB_HFSR_DEBUGEVT_Pos  P    SCB_HFSR_DEBUGEVT_Msk  P    SCB_HFSR_FORCED_Pos  P    SCB_HFSR_FORCED_Msk  P    SCB_HFSR_VECTTBL_Pos 5 P    SCB_HFSR_VECTTBL_Msk < P    SCB_DFSR_EXTERNAL_Pos  P    SCB_DFSR_EXTERNAL_Msk  P    SCB_DFSR_VCATCH_Pos  P    SCB_DFSR_VCATCH_Msk  P    SCB_DFSR_DWTTRAP_Pos ' P    SCB_DFSR_DWTTRAP_Msk . P    SCB_DFSR_BKPT_Pos " P    SCB_DFSR_BKPT_Msk ) P    SCB_DFSR_HALTED_Pos  P    SCB_DFSR_HALTED_Msk  8  
<unnamed> Q  
" CTRL   
" LOAD   
" VAL   
" CALIB ~    SysTick_Type # P    SysTick_CTRL_COUNTFLAG_Pos # P    SysTick_CTRL_COUNTFLAG_Msk # P    SysTick_CTRL_CLKSOURCE_Pos # P    SysTick_CTRL_CLKSOURCE_Msk ! P    SysTick_CTRL_TICKINT_Pos 7! P    SysTick_CTRL_TICKINT_Msk >  P    SysTick_CTRL_ENABLE_Pos   P    SysTick_CTRL_ENABLE_Msk   P    SysTick_LOAD_RELOAD_Pos   P    SysTick_LOAD_RELOAD_Msk   P    SysTick_VAL_CURRENT_Pos ~  P    SysTick_VAL_CURRENT_Msk   P    SysTick_CALIB_NOREF_Pos   P    SysTick_CALIB_NOREF_Msk  P    SysTick_CALIB_SKEW_Pos  P    SysTick_CALIB_SKEW_Msk   P    SysTick_CALIB_TENMS_Pos   P    SysTick_CALIB_TENMS_Msk  8  
<unnamed> Q 8  
<unnamed> S  " u8    " u16   
" u32   <" PORT   <" 
RESERVED0 _  
" TER   <" <
RESERVED1   
" TPR   <" <
RESERVED2   
" TCR   <" t
RESERVED3   
" IWR   
" IRR   
" IMCR   <" 
RESERVED4 I  
" LAR   
" LSR   <" 
RESERVED5   
" PID4   
" PID5   
" PID6   
" PID7   
" PID0   
" PID1   
" PID2   
" PID3   
" CID0   
" CID1   
" CID2   
" CID3     	ITM_Type  P    ITM_TPR_PRIVMASK_Pos  P    ITM_TPR_PRIVMASK_Msk  P    ITM_TCR_BUSY_Pos F P    ITM_TCR_BUSY_Msk M P    ITM_TCR_ATBID_Pos # P    ITM_TCR_ATBID_Msk * P    ITM_TCR_TSPrescale_Pos  P    ITM_TCR_TSPrescale_Msk  P    ITM_TCR_SWOENA_Pos  P    ITM_TCR_SWOENA_Msk  P    ITM_TCR_DWTENA_Pos  P    ITM_TCR_DWTENA_Msk  P    ITM_TCR_SYNCENA_Pos r P    ITM_TCR_SYNCENA_Msk y P    ITM_TCR_TSENA_Pos  P    ITM_TCR_TSENA_Msk  P    ITM_TCR_ITMENA_Pos  P    ITM_TCR_ITMENA_Msk  P    ITM_IWR_ATVALIDM_Pos & P    ITM_IWR_ATVALIDM_Msk - P    ITM_IRR_ATREADYM_Pos & P    ITM_IRR_ATREADYM_Msk -! P    ITM_IMCR_INTEGRATION_Pos ! P    ITM_IMCR_INTEGRATION_Msk  P    ITM_LSR_ByteAcc_Pos  P    ITM_LSR_ByteAcc_Msk  P    ITM_LSR_Access_Pos + P    ITM_LSR_Access_Msk 2 P    ITM_LSR_Present_Pos  P    ITM_LSR_Present_Msk  8  
<unnamed> Q  
" 
RESERVED0 i  
" ICTR   
" 
RESERVED1 h    InterruptType_Type m+ P    #InterruptType_ICTR_INTLINESNUM_Pos A+ P    #InterruptType_ICTR_INTLINESNUM_Msk H( P     InterruptType_ACTLR_DISFOLD_Pos T( P     InterruptType_ACTLR_DISFOLD_Msk [+ P    #InterruptType_ACTLR_DISDEFWBUF_Pos p+ P    #InterruptType_ACTLR_DISDEFWBUF_Msk w+ P    #InterruptType_ACTLR_DISMCYCINT_Pos \+ P    #InterruptType_ACTLR_DISMCYCINT_Msk c 8  
<unnamed> Q  
" DHCSR   
" DCRSR v  
" DCRDR   
" DEMCR     CoreDebug_Type t# P    CoreDebug_DHCSR_DBGKEY_Pos # P    CoreDebug_DHCSR_DBGKEY_Msk ' P    CoreDebug_DHCSR_S_RESET_ST_Pos !' P    CoreDebug_DHCSR_S_RESET_ST_Msk (( P     CoreDebug_DHCSR_S_RETIRE_ST_Pos ( P     CoreDebug_DHCSR_S_RETIRE_ST_Msk % P    CoreDebug_DHCSR_S_LOCKUP_Pos % P    CoreDebug_DHCSR_S_LOCKUP_Msk $ P    CoreDebug_DHCSR_S_SLEEP_Pos 7$ P    CoreDebug_DHCSR_S_SLEEP_Msk ># P    CoreDebug_DHCSR_S_HALT_Pos # P    CoreDebug_DHCSR_S_HALT_Msk % P    CoreDebug_DHCSR_S_REGRDY_Pos % P    CoreDebug_DHCSR_S_REGRDY_Msk ( P     CoreDebug_DHCSR_C_SNAPSTALL_Pos ( P     CoreDebug_DHCSR_C_SNAPSTALL_Msk ' P    CoreDebug_DHCSR_C_MASKINTS_Pos P' P    CoreDebug_DHCSR_C_MASKINTS_Msk W# P    CoreDebug_DHCSR_C_STEP_Pos # P    CoreDebug_DHCSR_C_STEP_Msk # P    CoreDebug_DHCSR_C_HALT_Pos # P    CoreDebug_DHCSR_C_HALT_Msk & P    CoreDebug_DHCSR_C_DEBUGEN_Pos & P    CoreDebug_DHCSR_C_DEBUGEN_Msk # P    CoreDebug_DCRSR_REGWnR_Pos e# P    CoreDebug_DCRSR_REGWnR_Msk l# P    CoreDebug_DCRSR_REGSEL_Pos # P    CoreDebug_DCRSR_REGSEL_Msk # P    CoreDebug_DEMCR_TRCENA_Pos # P    CoreDebug_DEMCR_TRCENA_Msk $ P    CoreDebug_DEMCR_MON_REQ_Pos :$ P    CoreDebug_DEMCR_MON_REQ_Msk A% P    CoreDebug_DEMCR_MON_STEP_Pos % P    CoreDebug_DEMCR_MON_STEP_Msk % P    CoreDebug_DEMCR_MON_PEND_Pos % P    CoreDebug_DEMCR_MON_PEND_Msk  # P    CoreDebug_DEMCR_MON_EN_Pos # P    CoreDebug_DEMCR_MON_EN_Msk ' P    CoreDebug_DEMCR_VC_HARDERR_Pos e' P    CoreDebug_DEMCR_VC_HARDERR_Msk l& P    CoreDebug_DEMCR_VC_INTERR_Pos & P    CoreDebug_DEMCR_VC_INTERR_Msk & P    CoreDebug_DEMCR_VC_BUSERR_Pos & P    CoreDebug_DEMCR_VC_BUSERR_Msk ' P    CoreDebug_DEMCR_VC_STATERR_Pos H' P    CoreDebug_DEMCR_VC_STATERR_Msk O& P    CoreDebug_DEMCR_VC_CHKERR_Pos & P    CoreDebug_DEMCR_VC_CHKERR_Msk ' P    CoreDebug_DEMCR_VC_NOCPERR_Pos T' P    CoreDebug_DEMCR_VC_NOCPERR_Msk [% P    CoreDebug_DEMCR_VC_MMERR_Pos % P    CoreDebug_DEMCR_VC_MMERR_Msk ) P    !CoreDebug_DEMCR_VC_CORERESET_Pos ) P    !CoreDebug_DEMCR_VC_CORERESET_Msk  P    	SCS_BASE X P    	ITM_BASE W P    CoreDebug_BASE  P    SysTick_BASE o P    
NVIC_BASE  P    	SCB_BASE i P    InterruptType B P    SCB  P    SysTick  P    NVIC  P    ITM  P    
CoreDebug I P   	__CC_ARM 6 P    __ASM " P    	__INLINE > P    __enable_fault_irq \ P    __disable_fault_irq  P    __NOP  P    __WFI  P    __WFE ! P    __SEV  P    __ISB % P    __DSB * P    __DMB 0 P    __REV  P    __RBIT  P    	__LDREXB < P    	__LDREXH 6 P    	__LDREXW ' P    	__STREXB % P    	__STREXH  P    	__STREXW    
__get_PSP  ,
 topOfProcStack 1   
__set_PSP z   
__get_MSP  ,
 topOfMainStack @   
__set_MSP } , value    __REV16  , value    __REVSH  P    __CLREX    __get_BASEPRI w 
" __regBasePri p   __set_BASEPRI k ,
" basePri 4 
" __regBasePri n   __get_PRIMASK f 
" __regPriMask Z   __set_PRIMASK Z ,
" priMask  
" __regPriMask X   __get_FAULTMASK  
" __regFaultMask    __set_FAULTMASK  ,
" 
faultMask D 
" __regFaultMask ~   __get_CONTROL \ 
" __regControl &   __set_CONTROL P ,
" control  
" __regControl $!   NVIC_SetPriorityGrouping \ ,
" PriorityGroup m 
" 
reg_value N 
" PriorityGroupTmp Z!   NVIC_GetPriorityGrouping h   NVIC_EnableIRQ  ,"" IRQn z   NVIC_DisableIRQ  ,"" IRQn x   NVIC_GetPendingIRQ p ,"" IRQn v   NVIC_SetPendingIRQ d ,"" IRQn t   NVIC_ClearPendingIRQ  ,"" IRQn r   NVIC_GetActive  ,"" IRQn p   NVIC_SetPriority  ,"" IRQn n ,
" 	priority S   NVIC_GetPriority  ,"" IRQn k   NVIC_EncodePriority  ,
" PriorityGroup W ,
" PreemptPriority  ,
" SubPriority > 
" PriorityGroupTmp D 
" PreemptPriorityBits  
" SubPriorityBits    NVIC_DecodePriority  ,
" 	Priority g ,
" PriorityGroup P ," pPreemptPriority  ," pSubPriority  
" PriorityGroupTmp = 
" PreemptPriorityBits  
" SubPriorityBits    SysTick_Config Y ,
" ticks    NVIC_SystemReset    __dsb   ITM_RxBuffer x P    ITM_RXBUFFER_EMPTY    ITM_SendChar  ,
" ch    ITM_ReceiveChar L " ch     ITM_CheckChar 5 P    __SYSTEM_STM32F10X_H  
 SystemCoreClock    SystemInit    SystemCoreClockUpdate a    s32 #    s16 !    s8 R    sc32     sc16     sc8     vs32     vs16     vs8     vsc32 F    vsc16 D    vsc8 u    u32 !    u16     u8 P    uc32     uc16     uc8     vu32     vu16     vu8     vuc32 D    vuc16 B    vuc8 s    RESET p    SET     FlagStatus     	ITStatus     DISABLE     ENABLE J    FunctionalState  P    IS_FUNCTIONAL_STATE     ERROR i    SUCCESS     ErrorStatus ] P    HSEStartUp_TimeOut  P    
HSE_Value } P    
HSI_Value y 8  
<unnamed> Q  
" SR ~  
" CR1 [  
" CR2 Z  
" SMPR1   
" SMPR2   
" JOFR1   
" JOFR2   
" JOFR3   
" JOFR4   
" HTR 3  
" LTR /  
" SQR1   
" SQR2   
" SQR3   
" JSQR   
" JDR1   
" JDR2   
" JDR3   
" JDR4   
" DR     ADC_TypeDef  8  
<unnamed> Q  
" 
RESERVED0 o  " DR1 B  " 
RESERVED1 l  " DR2 A  " 
RESERVED2 k  " DR3 @  " 
RESERVED3 j  " DR4 ?  " 
RESERVED4 i  " DR5 >  " 
RESERVED5 h  " DR6 =  " 
RESERVED6 g  " DR7 <  " 
RESERVED7 f  " DR8 ;  " 
RESERVED8 e  " DR9 :  " 
RESERVED9 d  " DR10   " RESERVED10 :  " RTCCR   " RESERVED11 9  " CR v  " RESERVED12 8  " CSR !  <" 
RESERVED13   " DR11   " RESERVED14 6  " DR12   " RESERVED15 5  " DR13   " RESERVED16 4  " DR14   " RESERVED17 3  " DR15   " RESERVED18 2  " DR16 
  " RESERVED19 1  " DR17 	  " RESERVED20 9  " DR18   " RESERVED21 8  " DR19   " RESERVED22 7  " DR20   " RESERVED23 6  " DR21   " RESERVED24 5  " DR22   " RESERVED25 4  " DR23   " RESERVED26 3  " DR24   " RESERVED27 2  " DR25 
  " RESERVED28 1  " DR26 	  " RESERVED29 0  " DR27   " RESERVED30 8  " DR28   " RESERVED31 7  " DR29   " RESERVED32 6  " DR30   " RESERVED33 5  " DR31   " RESERVED34 4  " DR32   " RESERVED35 3  " DR33   " RESERVED36 2  " DR34 
  " RESERVED37 1  " DR35 	  " RESERVED38 0  " DR36   " RESERVED39 /  " DR37   " RESERVED40 7  " DR38   " RESERVED41 6  " DR39   " RESERVED42 5  " DR40   " RESERVED43 4  " DR41   " RESERVED44 3  " DR42   " RESERVED45 2    BKP_TypeDef  8  
<unnamed> Q  
" TIR >  
" TDTR   
" TDLR   
" TDHR     CAN_TxMailBox_TypeDef  8  
<unnamed> Q  
" RIR :  
" RDTR   
" RDLR   
" RDHR      CAN_FIFOMailBox_TypeDef  8  
<unnamed> Q  
" FR1 X  
" FR2 W#    CAN_FilterRegister_TypeDef  8  
<unnamed> Q  
" MCR ;  
" MSR +  
" TSR $  
" RF0R   
" RF1R    
" IER =  
" ESR 3  
" BTR 5  <" 
RESERVED0 p  <" 0sTxMailBox   <"  sFIFOMailBox z  <" 0
RESERVED1 "  
" FMR 8  
" FM1R   
" 
RESERVED2   
" FS1R   
" 
RESERVED3 ~  
" FFA1R   
" 
RESERVED4 }  
" FA1R   <"  
RESERVED5 .  <" psFilterRegister I    CAN_TypeDef 	 8  
<unnamed> Q  
" CFGR   
" OAR #  
" PRES   
" ESR   
" CSR   
" TXD   
" RXD     CEC_TypeDef  8  
<unnamed> Q  
" DR h  " IDR $  " 
RESERVED0 g  " 
RESERVED1 ]  
" CR i    CRC_TypeDef  8  
<unnamed> Q  
" CR b  
" SWTRIGR   
" DHR12R1 )  
" DHR12L1 /  
" DHR8R1 V  
" DHR12R2 (  
" DHR12L2 .  
" DHR8R2 U  
" DHR12RD   
" DHR12LD   
" DHR8RD C  
" DOR1   
" DOR2     DAC_TypeDef  8  
<unnamed> Q  
" IDCODE 8  
" CR S    DBGMCU_TypeDef # 8  
<unnamed> Q  
" CCR 
  
" CNDTR c  
" CPAR   
" CMAR     DMA_Channel_TypeDef  8  
<unnamed> Q  
" ISR   
" IFCR     DMA_TypeDef 	 8  
<unnamed> Q  
" MACCR n  
" MACFFR #  
" MACHTHR   
" MACHTLR   
" 	MACMIIAR   
" 	MACMIIDR   
" MACFCR &  
" 
MACVLANTR $  <" 
RESERVED0   
" 
MACRWUFFR   
" 
MACPMTCSR "  <" 
RESERVED1   
" MACSR ^  
" MACIMR   
" MACA0HR   
" MACA0LR   
" MACA1HR   
" MACA1LR   
" MACA2HR   
" MACA2LR   
" MACA3HR   
" MACA3LR   <" 
RESERVED2 j  
" MMCCR b  
" MMCRIR   
" MMCTIR   
" MMCRIMR   
" MMCTIMR   <" 8
RESERVED3   
" MMCTGFSCCR   
" MMCTGFMSCCR   <" 
RESERVED4   
" 	MMCTGFCR {  <" (
RESERVED5   
" 
MMCRFCECR :  
" 
MMCRFAECR <  <" (
RESERVED6   
" 
MMCRGUFCR &  <" 

RESERVED7 D  
" PTPTSCR   
" PTPSSIR   
" PTPTSHR   
" PTPTSLR   
" 	PTPTSHUR D  
" 	PTPTSLUR @  
" PTPTSAR   
" PTPTTHR   
" PTPTTLR   <" 
RESERVED8   
" DMABMR   
" DMATPDR   
" DMARPDR   
" 	DMARDLAR   
" 	DMATDLAR   
" DMASR ]  
" DMAOMR   
" DMAIER    
" 
DMAMFBOCR A  <" $
RESERVED9   
" 	DMACHTDR   
" 	DMACHRDR   
" 
DMACHTBAR F  
" 
DMACHRBAR H    ETH_TypeDef  8  
<unnamed> Q  
" IMR .  
" EMR 2  
" RTSR   
" FTSR   
" SWIER   
" PR v    EXTI_TypeDef  8  
<unnamed> Q  
" ACR 8  
" KEYR   
" OPTKEYR   
" SR k  
" CR {  
" AR }  
" 	RESERVED   
" OBR +  
" WRPR     FLASH_TypeDef i 8  
<unnamed> Q  " RDP   " USER   " Data0 S  " Data1 R  " WRP0   " WRP1   " WRP2   " WRP3     OB_TypeDef L 8  
<unnamed> Q  <"  BTCR ~    FSMC_Bank1_TypeDef  8  
<unnamed> Q  <" BWTR k    FSMC_Bank1E_TypeDef Q 8  
<unnamed> Q  
" PCR2   
" SR2   
" PMEM2   
" PATT2   
" 
RESERVED0 W  
" ECCR2     FSMC_Bank2_TypeDef  8  
<unnamed> Q  
" PCR3   
" SR3   
" PMEM3   
" PATT3 {  
" 
RESERVED0 O  
" ECCR3     FSMC_Bank3_TypeDef  8  
<unnamed> Q  
" PCR4   
" SR4 
  
" PMEM4 |  
" PATT4 r  
" PIO4     FSMC_Bank4_TypeDef  8  
<unnamed> Q  
" CRL   
" CRH   
" IDR   
" ODR   
" BSRR   
" BRR   
" LCKR     GPIO_TypeDef  8  
<unnamed> Q  
" EVCR   
" MAPR   <" EXTICR   
" 
RESERVED0 7  
" MAPR2 m    AFIO_TypeDef  8  
<unnamed> Q  " CR1   " 
RESERVED0 .  " CR2   " 
RESERVED1 -  " OAR1   " 
RESERVED2 ,  " OAR2   " 
RESERVED3 +  " DR 6  " 
RESERVED4 *  " SR1   " 
RESERVED5 )  " SR2   " 
RESERVED6 (  " CCR   " 
RESERVED7 '  " TRISE ?  " 
RESERVED8 &    I2C_TypeDef  8  
<unnamed> Q  
" KR   
" PR   
" RLR G  
" SR     IWDG_TypeDef  8  
<unnamed> Q  
" CR   
" CSR I    PWR_TypeDef  8  
<unnamed> Q  
" CR   
" CFGR 	  
" CIR O  
" 	APB2RSTR   
" 	APB1RSTR   
" AHBENR w  
" APB2ENR ;  
" APB1ENR <  
" BDCR   
" CSR E    RCC_TypeDef  8  
<unnamed> Q  " CRH B  " 
RESERVED0   " CRL >  " 
RESERVED1   " PRLH   " 
RESERVED2   " PRLL   " 
RESERVED3   " DIVH   " 
RESERVED4   " DIVL   " 
RESERVED5 ~  " CNTH   " 
RESERVED6 }  " CNTL   " 
RESERVED7 |  " ALRH   " 
RESERVED8 {  " ALRL   " 
RESERVED9 z    RTC_TypeDef  8  
<unnamed> Q  
" POWER z  
" CLKCR   
" ARG 1  
" CMD 7  
" RESPCMD   
" RESP1   
" RESP2   
" RESP3   
" RESP4   
" DTIMER @  
" DLEN   
" DCTRL   
" DCOUNT 8  
" STA #  
" ICR -  
" MASK   <" 
RESERVED0 9  
" FIFOCNT   <" 4
RESERVED1   
" FIFO     SDIO_TypeDef  8  
<unnamed> Q  " CR1 -  " 
RESERVED0 W  " CR2 ,  " 
RESERVED1 V  " SR P  " 
RESERVED2 U  " DR _  " 
RESERVED3 T  " CRCPR u  " 
RESERVED4 S  " RXCRCR   " 
RESERVED5 R  " TXCRCR   " 
RESERVED6 Q  " I2SCFGR   " 
RESERVED7 P  " I2SPR   " 
RESERVED8 O    SPI_TypeDef  8  
<unnamed> Q  " CR1   " 
RESERVED0 C  " CR2   " 
RESERVED1 B  " SMCR   " 
RESERVED2 A  " DIER   " 
RESERVED3 @  " SR <  " 
RESERVED4 ?  " EGR   " 
RESERVED5 >  " CCMR1   " 
RESERVED6 =  " CCMR2   " 
RESERVED7 <  " CCER   " 
RESERVED8 ;  " CNT   " 
RESERVED9 :  " PSC   " RESERVED10   " ARR   " RESERVED11   " RCR   " RESERVED12   " CCR1   " RESERVED13   " CCR2   " RESERVED14   " CCR3   " RESERVED15   " CCR4   " RESERVED16 
  " BDTR   " RESERVED17 	  " DCR   " RESERVED18   " DMAR   " RESERVED19     TIM_TypeDef  8  
<unnamed> Q  " 	SR   " 	
RESERVED0   " 	DR   " 	
RESERVED1   " 	BRR N  " 	
RESERVED2   " 	CR1 n  " 	
RESERVED3   " 	CR2 m  " 	
RESERVED4   " 	CR3 l  " 	
RESERVED5   " 	GTPR   " 	
RESERVED6     USART_TypeDef H 8  
<unnamed> Q  
" 	CR   
" 	CFR K  
" 	SR     WWDG_TypeDef  P    FLASH_BASE  P    
SRAM_BASE  P    PERIPH_BASE s P    SRAM_BB_BASE # P    PERIPH_BB_BASE  P    FSMC_R_BASE a P    APB1PERIPH_BASE g P    APB2PERIPH_BASE f P    AHBPERIPH_BASE  P    
TIM2_BASE # P    
TIM3_BASE " P    
TIM4_BASE ! P    
TIM5_BASE   P    
TIM6_BASE  P    
TIM7_BASE  P    TIM12_BASE  P    TIM13_BASE  P    TIM14_BASE  P    	RTC_BASE X P    
WWDG_BASE  P    
IWDG_BASE  P    
SPI2_BASE ! P    
SPI3_BASE   P    USART2_BASE z P    USART3_BASE y P    UART4_BASE  P    UART5_BASE  P    
I2C1_BASE P P    
I2C2_BASE O P    
CAN1_BASE < P    
CAN2_BASE ; P    	BKP_BASE d P    	PWR_BASE H P    	DAC_BASE y P    	CEC_BASE v P    
AFIO_BASE   P    
EXTI_BASE  P    GPIOA_BASE  P    GPIOB_BASE  P    GPIOC_BASE  P    GPIOD_BASE  P    GPIOE_BASE  P    GPIOF_BASE  P    GPIOG_BASE  P    
ADC1_BASE F P    
ADC2_BASE E P    
TIM1_BASE $ P    
SPI1_BASE " P    
TIM8_BASE  P    USART1_BASE { P    
ADC3_BASE D P    TIM15_BASE  P    TIM16_BASE  P    TIM17_BASE  P    
TIM9_BASE  P    TIM10_BASE  P    TIM11_BASE  P    
SDIO_BASE  P    
DMA1_BASE < P    DMA1_Channel1_BASE  P    DMA1_Channel2_BASE  P    DMA1_Channel3_BASE  P    DMA1_Channel4_BASE  P    DMA1_Channel5_BASE  P    DMA1_Channel6_BASE  P    DMA1_Channel7_BASE  P    
DMA2_BASE ; P    DMA2_Channel1_BASE  P    DMA2_Channel2_BASE  P    DMA2_Channel3_BASE  P    DMA2_Channel4_BASE  P    DMA2_Channel5_BASE  P    	RCC_BASE i P    	CRC_BASE i P    FLASH_R_BASE  P    OB_BASE  P    	ETH_BASE ` P    ETH_MAC_BASE ( P    ETH_MMC_BASE  P    ETH_PTP_BASE  P    ETH_DMA_BASE ' P    FSMC_Bank1_R_BASE I P    FSMC_Bank1E_R_BASE  P    FSMC_Bank2_R_BASE H P    FSMC_Bank3_R_BASE G P    FSMC_Bank4_R_BASE F P    DBGMCU_BASE  P    TIM2  P    TIM3  P    TIM4  P    TIM5  P    TIM6  P    TIM7  P    TIM12 t P    TIM13 s P    TIM14 r P    RTC  P    WWDG  P    IWDG  P    SPI2  P    SPI3  P    USART2  P    USART3  P    UART4 Q P    UART5 P P    I2C1  P    I2C2  P    CAN1  P    CAN2  P    BKP  P    PWR  P    DAC  P    CEC  P    AFIO  P    EXTI  P    GPIOA Q P    GPIOB P P    GPIOC O P    GPIOD N P    GPIOE M P    GPIOF L P    GPIOG K P    ADC1  P    ADC2  P    TIM1  P    SPI1  P    TIM8  P    USART1  P    ADC3  P    TIM15 q P    TIM16 p P    TIM17 o P    TIM9  P    TIM10 v P    TIM11 u P    SDIO  P    DMA1  P    DMA2  P    DMA1_Channel1 e P    DMA1_Channel2 d P    DMA1_Channel3 c P    DMA1_Channel4 b P    DMA1_Channel5 a P    DMA1_Channel6 ` P    DMA1_Channel7 _ P    DMA2_Channel1 d P    DMA2_Channel2 c P    DMA2_Channel3 b P    DMA2_Channel4 a P    DMA2_Channel5 ` P    RCC  P    CRC  P    FLASH S P    OB 6 P    ETH  P    FSMC_Bank1  P    FSMC_Bank1E ; P    FSMC_Bank2  P    FSMC_Bank3  P    FSMC_Bank4  P    DBGMCU  P    
CRC_DR_DR  P    CRC_IDR_IDR a P    CRC_CR_RESET  P    PWR_CR_LPDS 6 P    PWR_CR_PDDS > P    PWR_CR_CWUF 4 P    PWR_CR_CSBF K P    PWR_CR_PVDE : P    PWR_CR_PLS | P    PWR_CR_PLS_0  P    PWR_CR_PLS_1  P    PWR_CR_PLS_2  P    PWR_CR_PLS_2V2 [ P    PWR_CR_PLS_2V3 Z P    PWR_CR_PLS_2V4 Y P    PWR_CR_PLS_2V5 X P    PWR_CR_PLS_2V6 W P    PWR_CR_PLS_2V7 V P    PWR_CR_PLS_2V8 U P    PWR_CR_PLS_2V9 T P    PWR_CR_DBP  P    PWR_CSR_WUF $ P    PWR_CSR_SBF ; P    PWR_CSR_PVDO  P    PWR_CSR_EWUP  P    
BKP_DR1_D  P    
BKP_DR2_D  P    
BKP_DR3_D  P    
BKP_DR4_D  P    
BKP_DR5_D  P    
BKP_DR6_D  P    
BKP_DR7_D  P    
BKP_DR8_D  P    
BKP_DR9_D  P    BKP_DR10_D  P    BKP_DR11_D  P    BKP_DR12_D  P    BKP_DR13_D  P    BKP_DR14_D  P    BKP_DR15_D  P    BKP_DR16_D  P    BKP_DR17_D  P    BKP_DR18_D  P    BKP_DR19_D  P    BKP_DR20_D  P    BKP_DR21_D  P    BKP_DR22_D  P    BKP_DR23_D  P    BKP_DR24_D  P    BKP_DR25_D  P    BKP_DR26_D  P    BKP_DR27_D  P    BKP_DR28_D  P    BKP_DR29_D  P    BKP_DR30_D  P    BKP_DR31_D  P    BKP_DR32_D  P    BKP_DR33_D  P    BKP_DR34_D  P    BKP_DR35_D  P    BKP_DR36_D  P    BKP_DR37_D  P    BKP_DR38_D  P    BKP_DR39_D  P    BKP_DR40_D  P    BKP_DR41_D  P    BKP_DR42_D  P    BKP_RTCCR_CAL  P    BKP_RTCCR_CCO  P    BKP_RTCCR_ASOE n P    BKP_RTCCR_ASOS ` P    BKP_CR_TPE  P    BKP_CR_TPAL T P    BKP_CSR_CTE V P    BKP_CSR_CTI R P    BKP_CSR_TPIE  P    BKP_CSR_TEF S P    BKP_CSR_TIF O P    RCC_CR_HSION  P    RCC_CR_HSIRDY  P    RCC_CR_HSITRIM d P    RCC_CR_HSICAL  P    RCC_CR_HSEON  P    RCC_CR_HSERDY  P    RCC_CR_HSEBYP  P    RCC_CR_CSSON  P    RCC_CR_PLLON  P    RCC_CR_PLLRDY  P    RCC_CFGR_SW S P    RCC_CFGR_SW_0  P    RCC_CFGR_SW_1  P    RCC_CFGR_SW_HSI  P    RCC_CFGR_SW_HSE  P    RCC_CFGR_SW_PLL  P    RCC_CFGR_SWS  P    RCC_CFGR_SWS_0 k P    RCC_CFGR_SWS_1 j P    RCC_CFGR_SWS_HSI  P    RCC_CFGR_SWS_HSE  P    RCC_CFGR_SWS_PLL  P    RCC_CFGR_HPRE  P    RCC_CFGR_HPRE_0 7 P    RCC_CFGR_HPRE_1 6 P    RCC_CFGR_HPRE_2 5 P    RCC_CFGR_HPRE_3 4 P    RCC_CFGR_HPRE_DIV1 M P    RCC_CFGR_HPRE_DIV2 L P    RCC_CFGR_HPRE_DIV4 J P    RCC_CFGR_HPRE_DIV8 F P    RCC_CFGR_HPRE_DIV16  P    RCC_CFGR_HPRE_DIV64  P    RCC_CFGR_HPRE_DIV128  P    RCC_CFGR_HPRE_DIV256  P    RCC_CFGR_HPRE_DIV512  P    RCC_CFGR_PPRE1  P    RCC_CFGR_PPRE1_0  P    RCC_CFGR_PPRE1_1  P    RCC_CFGR_PPRE1_2  P    RCC_CFGR_PPRE1_DIV1  P    RCC_CFGR_PPRE1_DIV2  P    RCC_CFGR_PPRE1_DIV4  P    RCC_CFGR_PPRE1_DIV8  P    RCC_CFGR_PPRE1_DIV16  P    RCC_CFGR_PPRE2  P    RCC_CFGR_PPRE2_0  P    RCC_CFGR_PPRE2_1  P    RCC_CFGR_PPRE2_2  P    RCC_CFGR_PPRE2_DIV1  P    RCC_CFGR_PPRE2_DIV2  P    RCC_CFGR_PPRE2_DIV4  P    RCC_CFGR_PPRE2_DIV8 
 P    RCC_CFGR_PPRE2_DIV16  P    RCC_CFGR_ADCPRE F P    RCC_CFGR_ADCPRE_0  P    RCC_CFGR_ADCPRE_1  P    RCC_CFGR_ADCPRE_DIV2  P    RCC_CFGR_ADCPRE_DIV4  P    RCC_CFGR_ADCPRE_DIV6  P    RCC_CFGR_ADCPRE_DIV8  P    RCC_CFGR_PLLSRC % P    RCC_CFGR_PLLXTPRE v P    RCC_CFGR_PLLMULL  P    RCC_CFGR_PLLMULL_0 > P    RCC_CFGR_PLLMULL_1 = P    RCC_CFGR_PLLMULL_2 < P    RCC_CFGR_PLLMULL_3 ;! P    RCC_CFGR_PLLSRC_HSI_Div2  P    RCC_CFGR_PLLSRC_HSE  P    RCC_CFGR_PLLXTPRE_HSE /# P    RCC_CFGR_PLLXTPRE_HSE_Div2 q P    RCC_CFGR_PLLMULL2  P    RCC_CFGR_PLLMULL3  P    RCC_CFGR_PLLMULL4  P    RCC_CFGR_PLLMULL5  P    RCC_CFGR_PLLMULL6  P    RCC_CFGR_PLLMULL7  P    RCC_CFGR_PLLMULL8  P    RCC_CFGR_PLLMULL9  P    RCC_CFGR_PLLMULL10 l P    RCC_CFGR_PLLMULL11 k P    RCC_CFGR_PLLMULL12 j P    RCC_CFGR_PLLMULL13 i P    RCC_CFGR_PLLMULL14 h P    RCC_CFGR_PLLMULL15 g P    RCC_CFGR_PLLMULL16 f P    RCC_CFGR_USBPRE $ P    RCC_CFGR_MCO  P    RCC_CFGR_MCO_0  P    RCC_CFGR_MCO_1  P    RCC_CFGR_MCO_2  P    RCC_CFGR_MCO_NOCLOCK  P    RCC_CFGR_MCO_SYSCLK  P    RCC_CFGR_MCO_HSI  P    RCC_CFGR_MCO_HSE  P    RCC_CFGR_MCO_PLL  P    RCC_CIR_LSIRDYF  P    RCC_CIR_LSERDYF   P    RCC_CIR_HSIRDYF   P    RCC_CIR_HSERDYF $ P    RCC_CIR_PLLRDYF  P    RCC_CIR_CSSF  P    RCC_CIR_LSIRDYIE  P    RCC_CIR_LSERDYIE  P    RCC_CIR_HSIRDYIE  P    RCC_CIR_HSERDYIE  P    RCC_CIR_PLLRDYIE  P    RCC_CIR_LSIRDYC  P    RCC_CIR_LSERDYC # P    RCC_CIR_HSIRDYC # P    RCC_CIR_HSERDYC ' P    RCC_CIR_PLLRDYC  P    RCC_CIR_CSSC  P    RCC_APB2RSTR_AFIORST  P    RCC_APB2RSTR_IOPARST  P    RCC_APB2RSTR_IOPBRST  P    RCC_APB2RSTR_IOPCRST  P    RCC_APB2RSTR_IOPDRST  P    RCC_APB2RSTR_ADC1RST  P    RCC_APB2RSTR_ADC2RST  P    RCC_APB2RSTR_TIM1RST  P    RCC_APB2RSTR_SPI1RST  P    RCC_APB2RSTR_USART1RST   P    RCC_APB2RSTR_IOPERST  P    RCC_APB2RSTR_IOPFRST  P    RCC_APB2RSTR_IOPGRST  P    RCC_APB2RSTR_TIM8RST  P    RCC_APB2RSTR_ADC3RST  P    RCC_APB1RSTR_TIM2RST  P    RCC_APB1RSTR_TIM3RST  P    RCC_APB1RSTR_WWDGRST  P    RCC_APB1RSTR_USART2RST   P    RCC_APB1RSTR_I2C1RST  P    RCC_APB1RSTR_CAN1RST  P    RCC_APB1RSTR_BKPRST  P    RCC_APB1RSTR_PWRRST  P    RCC_APB1RSTR_TIM4RST  P    RCC_APB1RSTR_SPI2RST  P    RCC_APB1RSTR_USART3RST  P    RCC_APB1RSTR_I2C2RST  P    RCC_APB1RSTR_USBRST  P    RCC_APB1RSTR_TIM5RST  P    RCC_APB1RSTR_TIM6RST  P    RCC_APB1RSTR_TIM7RST  P    RCC_APB1RSTR_SPI3RST  P    RCC_APB1RSTR_UART4RST S P    RCC_APB1RSTR_UART5RST R P    RCC_APB1RSTR_DACRST  P    RCC_AHBENR_DMA1EN  P    RCC_AHBENR_SRAMEN  P    RCC_AHBENR_FLITFEN Y P    RCC_AHBENR_CRCEN  P    RCC_AHBENR_DMA2EN  P    RCC_AHBENR_FSMCEN  P    RCC_AHBENR_SDIOEN  P    RCC_APB2ENR_AFIOEN u P    RCC_APB2ENR_IOPAEN k P    RCC_APB2ENR_IOPBEN j P    RCC_APB2ENR_IOPCEN i P    RCC_APB2ENR_IOPDEN h P    RCC_APB2ENR_ADC1EN  P    RCC_APB2ENR_ADC2EN  P    RCC_APB2ENR_TIM1EN y P    RCC_APB2ENR_SPI1EN w P    RCC_APB2ENR_USART1EN  P    RCC_APB2ENR_IOPEEN g P    RCC_APB2ENR_IOPFEN f P    RCC_APB2ENR_IOPGEN e P    RCC_APB2ENR_TIM8EN r P    RCC_APB2ENR_ADC3EN  P    RCC_APB1ENR_TIM2EN y P    RCC_APB1ENR_TIM3EN x P    RCC_APB1ENR_WWDGEN \ P    RCC_APB1ENR_USART2EN  P    RCC_APB1ENR_I2C1EN  P    RCC_APB1ENR_CAN1EN  P    RCC_APB1ENR_BKPEN  P    RCC_APB1ENR_PWREN  P    RCC_APB1ENR_TIM4EN w P    RCC_APB1ENR_SPI2EN w P    RCC_APB1ENR_USART3EN  P    RCC_APB1ENR_I2C2EN  P    RCC_APB1ENR_USBEN  P    RCC_APB1ENR_TIM5EN v P    RCC_APB1ENR_TIM6EN u P    RCC_APB1ENR_TIM7EN t P    RCC_APB1ENR_SPI3EN v P    RCC_APB1ENR_UART4EN # P    RCC_APB1ENR_UART5EN " P    RCC_APB1ENR_DACEN  P    RCC_BDCR_LSEON } P    RCC_BDCR_LSERDY ) P    RCC_BDCR_LSEBYP - P    RCC_BDCR_RTCSEL / P    RCC_BDCR_RTCSEL_0  P    RCC_BDCR_RTCSEL_1   P    RCC_BDCR_RTCSEL_NOCLOCK  P    RCC_BDCR_RTCSEL_LSE  P    RCC_BDCR_RTCSEL_LSI  P    RCC_BDCR_RTCSEL_HSE  P    RCC_BDCR_RTCEN  P    RCC_BDCR_BDRST  P    RCC_CSR_LSION  P    RCC_CSR_LSIRDY Z P    RCC_CSR_RMVF  P    RCC_CSR_PINRSTF 	 P    RCC_CSR_PORRSTF  P    RCC_CSR_SFTRSTF  P    RCC_CSR_IWDGRSTF  P    RCC_CSR_WWDGRSTF  P    RCC_CSR_LPWRRSTF  P    GPIO_CRL_MODE  P    GPIO_CRL_MODE0  P    GPIO_CRL_MODE0_0  P    GPIO_CRL_MODE0_1  P    GPIO_CRL_MODE1  P    GPIO_CRL_MODE1_0  P    GPIO_CRL_MODE1_1  P    GPIO_CRL_MODE2  P    GPIO_CRL_MODE2_0  P    GPIO_CRL_MODE2_1  P    GPIO_CRL_MODE3  P    GPIO_CRL_MODE3_0  P    GPIO_CRL_MODE3_1  P    GPIO_CRL_MODE4  P    GPIO_CRL_MODE4_0  P    GPIO_CRL_MODE4_1  P    GPIO_CRL_MODE5  P    GPIO_CRL_MODE5_0  P    GPIO_CRL_MODE5_1  P    GPIO_CRL_MODE6  P    GPIO_CRL_MODE6_0  P    GPIO_CRL_MODE6_1  P    GPIO_CRL_MODE7  P    GPIO_CRL_MODE7_0  P    GPIO_CRL_MODE7_1  P    GPIO_CRL_CNF  P    GPIO_CRL_CNF0  P    GPIO_CRL_CNF0_0 I P    GPIO_CRL_CNF0_1 H P    GPIO_CRL_CNF1  P    GPIO_CRL_CNF1_0 H P    GPIO_CRL_CNF1_1 G P    GPIO_CRL_CNF2  P    GPIO_CRL_CNF2_0 G P    GPIO_CRL_CNF2_1 F P    GPIO_CRL_CNF3  P    GPIO_CRL_CNF3_0 F P    GPIO_CRL_CNF3_1 E P    GPIO_CRL_CNF4  P    GPIO_CRL_CNF4_0 E P    GPIO_CRL_CNF4_1 D P    GPIO_CRL_CNF5  P    GPIO_CRL_CNF5_0 D P    GPIO_CRL_CNF5_1 C P    GPIO_CRL_CNF6  P    GPIO_CRL_CNF6_0 C P    GPIO_CRL_CNF6_1 B P    GPIO_CRL_CNF7  P    GPIO_CRL_CNF7_0 B P    GPIO_CRL_CNF7_1 A P    GPIO_CRH_MODE  P    GPIO_CRH_MODE8  P    GPIO_CRH_MODE8_0  P    GPIO_CRH_MODE8_1  P    GPIO_CRH_MODE9  P    GPIO_CRH_MODE9_0  P    GPIO_CRH_MODE9_1  P    GPIO_CRH_MODE10 ] P    GPIO_CRH_MODE10_0  P    GPIO_CRH_MODE10_1  P    GPIO_CRH_MODE11 \ P    GPIO_CRH_MODE11_0  P    GPIO_CRH_MODE11_1  P    GPIO_CRH_MODE12 [ P    GPIO_CRH_MODE12_0  P    GPIO_CRH_MODE12_1  P    GPIO_CRH_MODE13 Z P    GPIO_CRH_MODE13_0  P    GPIO_CRH_MODE13_1  P    GPIO_CRH_MODE14 Y P    GPIO_CRH_MODE14_0  P    GPIO_CRH_MODE14_1  P    GPIO_CRH_MODE15 X P    GPIO_CRH_MODE15_0  P    GPIO_CRH_MODE15_1  P    GPIO_CRH_CNF  P    GPIO_CRH_CNF8  P    GPIO_CRH_CNF8_0 E P    GPIO_CRH_CNF8_1 D P    GPIO_CRH_CNF9  P    GPIO_CRH_CNF9_0 D P    GPIO_CRH_CNF9_1 C P    GPIO_CRH_CNF10  P    GPIO_CRH_CNF10_0  P    GPIO_CRH_CNF10_1  P    GPIO_CRH_CNF11  P    GPIO_CRH_CNF11_0  P    GPIO_CRH_CNF11_1  P    GPIO_CRH_CNF12  P    GPIO_CRH_CNF12_0  P    GPIO_CRH_CNF12_1  P    GPIO_CRH_CNF13  P    GPIO_CRH_CNF13_0  P    GPIO_CRH_CNF13_1  P    GPIO_CRH_CNF14  P    GPIO_CRH_CNF14_0  P    GPIO_CRH_CNF14_1  P    GPIO_CRH_CNF15  P    GPIO_CRH_CNF15_0  P    GPIO_CRH_CNF15_1  P    GPIO_IDR_IDR0  P    GPIO_IDR_IDR1  P    GPIO_IDR_IDR2  P    GPIO_IDR_IDR3  P    GPIO_IDR_IDR4  P    GPIO_IDR_IDR5  P    GPIO_IDR_IDR6  P    GPIO_IDR_IDR7  P    GPIO_IDR_IDR8  P    GPIO_IDR_IDR9  P    GPIO_IDR_IDR10  P    GPIO_IDR_IDR11  P    GPIO_IDR_IDR12  P    GPIO_IDR_IDR13  P    GPIO_IDR_IDR14  P    GPIO_IDR_IDR15  P    GPIO_ODR_ODR0  P    GPIO_ODR_ODR1  P    GPIO_ODR_ODR2  P    GPIO_ODR_ODR3  P    GPIO_ODR_ODR4  P    GPIO_ODR_ODR5  P    GPIO_ODR_ODR6  P    GPIO_ODR_ODR7  P    GPIO_ODR_ODR8  P    GPIO_ODR_ODR9  P    GPIO_ODR_ODR10  P    GPIO_ODR_ODR11  P    GPIO_ODR_ODR12  P    GPIO_ODR_ODR13  P    GPIO_ODR_ODR14  P    GPIO_ODR_ODR15  P    GPIO_BSRR_BS0  P    GPIO_BSRR_BS1  P    GPIO_BSRR_BS2  P    GPIO_BSRR_BS3  P    GPIO_BSRR_BS4  P    GPIO_BSRR_BS5  P    GPIO_BSRR_BS6  P    GPIO_BSRR_BS7  P    GPIO_BSRR_BS8  P    GPIO_BSRR_BS9  P    GPIO_BSRR_BS10  P    GPIO_BSRR_BS11  P    GPIO_BSRR_BS12  P    GPIO_BSRR_BS13  P    GPIO_BSRR_BS14  P    GPIO_BSRR_BS15  P    GPIO_BSRR_BR0  P    GPIO_BSRR_BR1  P    GPIO_BSRR_BR2  P    GPIO_BSRR_BR3  P    GPIO_BSRR_BR4  P    GPIO_BSRR_BR5  P    GPIO_BSRR_BR6  P    GPIO_BSRR_BR7  P    GPIO_BSRR_BR8  P    GPIO_BSRR_BR9  P    GPIO_BSRR_BR10  P    GPIO_BSRR_BR11  P    GPIO_BSRR_BR12  P    GPIO_BSRR_BR13  P    GPIO_BSRR_BR14  P    GPIO_BSRR_BR15  P    GPIO_BRR_BR0  P    GPIO_BRR_BR1  P    GPIO_BRR_BR2  P    GPIO_BRR_BR3  P    GPIO_BRR_BR4  P    GPIO_BRR_BR5  P    GPIO_BRR_BR6  P    GPIO_BRR_BR7  P    GPIO_BRR_BR8  P    GPIO_BRR_BR9  P    GPIO_BRR_BR10  P    GPIO_BRR_BR11  P    GPIO_BRR_BR12  P    GPIO_BRR_BR13  P    GPIO_BRR_BR14  P    GPIO_BRR_BR15  P    GPIO_LCKR_LCK0  P    GPIO_LCKR_LCK1  P    GPIO_LCKR_LCK2  P    GPIO_LCKR_LCK3  P    GPIO_LCKR_LCK4  P    GPIO_LCKR_LCK5  P    GPIO_LCKR_LCK6  P    GPIO_LCKR_LCK7  P    GPIO_LCKR_LCK8  P    GPIO_LCKR_LCK9  P    GPIO_LCKR_LCK10 Y P    GPIO_LCKR_LCK11 X P    GPIO_LCKR_LCK12 W P    GPIO_LCKR_LCK13 V P    GPIO_LCKR_LCK14 U P    GPIO_LCKR_LCK15 T P    GPIO_LCKR_LCKK q P    AFIO_EVCR_PIN  P    AFIO_EVCR_PIN_0 * P    AFIO_EVCR_PIN_1 ) P    AFIO_EVCR_PIN_2 ( P    AFIO_EVCR_PIN_3 ' P    AFIO_EVCR_PIN_PX0 ~ P    AFIO_EVCR_PIN_PX1 } P    AFIO_EVCR_PIN_PX2 | P    AFIO_EVCR_PIN_PX3 { P    AFIO_EVCR_PIN_PX4 z P    AFIO_EVCR_PIN_PX5 y P    AFIO_EVCR_PIN_PX6 x P    AFIO_EVCR_PIN_PX7 w P    AFIO_EVCR_PIN_PX8 v P    AFIO_EVCR_PIN_PX9 u P    AFIO_EVCR_PIN_PX10 K P    AFIO_EVCR_PIN_PX11 J P    AFIO_EVCR_PIN_PX12 I P    AFIO_EVCR_PIN_PX13 H P    AFIO_EVCR_PIN_PX14 G P    AFIO_EVCR_PIN_PX15 F P    AFIO_EVCR_PORT ] P    AFIO_EVCR_PORT_0  P    AFIO_EVCR_PORT_1  P    AFIO_EVCR_PORT_2  P    AFIO_EVCR_PORT_PA g P    AFIO_EVCR_PORT_PB f P    AFIO_EVCR_PORT_PC e P    AFIO_EVCR_PORT_PD d P    AFIO_EVCR_PORT_PE c P    AFIO_EVCR_EVOE s P    AFIO_MAPR_SPI1_REMAP  P    AFIO_MAPR_I2C1_REMAP  P    AFIO_MAPR_USART1_REMAP  P    AFIO_MAPR_USART2_REMAP  P    AFIO_MAPR_USART3_REMAP ! P    AFIO_MAPR_USART3_REMAP_0 i! P    AFIO_MAPR_USART3_REMAP_1 h' P    AFIO_MAPR_USART3_REMAP_NOREMAP {, P    $AFIO_MAPR_USART3_REMAP_PARTIALREMAP ) P    !AFIO_MAPR_USART3_REMAP_FULLREMAP  P    AFIO_MAPR_TIM1_REMAP  P    AFIO_MAPR_TIM1_REMAP_0  P    AFIO_MAPR_TIM1_REMAP_1 % P    AFIO_MAPR_TIM1_REMAP_NOREMAP &* P    "AFIO_MAPR_TIM1_REMAP_PARTIALREMAP ' P    AFIO_MAPR_TIM1_REMAP_FULLREMAP  P    AFIO_MAPR_TIM2_REMAP  P    AFIO_MAPR_TIM2_REMAP_0  P    AFIO_MAPR_TIM2_REMAP_1 % P    AFIO_MAPR_TIM2_REMAP_NOREMAP %+ P    #AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1 x+ P    #AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2 w' P    AFIO_MAPR_TIM2_REMAP_FULLREMAP  P    AFIO_MAPR_TIM3_REMAP  P    AFIO_MAPR_TIM3_REMAP_0  P    AFIO_MAPR_TIM3_REMAP_1 % P    AFIO_MAPR_TIM3_REMAP_NOREMAP $* P    "AFIO_MAPR_TIM3_REMAP_PARTIALREMAP ' P    AFIO_MAPR_TIM3_REMAP_FULLREMAP  P    AFIO_MAPR_TIM4_REMAP  P    AFIO_MAPR_CAN_REMAP  P    AFIO_MAPR_CAN_REMAP_0 _ P    AFIO_MAPR_CAN_REMAP_1 ^# P    AFIO_MAPR_CAN_REMAP_REMAP1 # P    AFIO_MAPR_CAN_REMAP_REMAP2 # P    AFIO_MAPR_CAN_REMAP_REMAP3  P    AFIO_MAPR_PD01_REMAP ! P    AFIO_MAPR_TIM5CH4_IREMAP % P    AFIO_MAPR_ADC1_ETRGINJ_REMAP G% P    AFIO_MAPR_ADC1_ETRGREG_REMAP J% P    AFIO_MAPR_ADC2_ETRGINJ_REMAP F% P    AFIO_MAPR_ADC2_ETRGREG_REMAP I P    AFIO_MAPR_SWJ_CFG y P    AFIO_MAPR_SWJ_CFG_0  P    AFIO_MAPR_SWJ_CFG_1  P    AFIO_MAPR_SWJ_CFG_2   P    AFIO_MAPR_SWJ_CFG_RESET # P    AFIO_MAPR_SWJ_CFG_NOJNTRST & P    AFIO_MAPR_SWJ_CFG_JTAGDISABLE " P    AFIO_MAPR_SWJ_CFG_DISABLE  P    AFIO_EXTICR1_EXTI0 ` P    AFIO_EXTICR1_EXTI1 _ P    AFIO_EXTICR1_EXTI2 ^ P    AFIO_EXTICR1_EXTI3 ] P    AFIO_EXTICR1_EXTI0_PA j P    AFIO_EXTICR1_EXTI0_PB i P    AFIO_EXTICR1_EXTI0_PC h P    AFIO_EXTICR1_EXTI0_PD g P    AFIO_EXTICR1_EXTI0_PE f P    AFIO_EXTICR1_EXTI0_PF e P    AFIO_EXTICR1_EXTI0_PG d P    AFIO_EXTICR1_EXTI1_PA i P    AFIO_EXTICR1_EXTI1_PB h P    AFIO_EXTICR1_EXTI1_PC g P    AFIO_EXTICR1_EXTI1_PD f P    AFIO_EXTICR1_EXTI1_PE e P    AFIO_EXTICR1_EXTI1_PF d P    AFIO_EXTICR1_EXTI1_PG c P    AFIO_EXTICR1_EXTI2_PA h P    AFIO_EXTICR1_EXTI2_PB g P    AFIO_EXTICR1_EXTI2_PC f P    AFIO_EXTICR1_EXTI2_PD e P    AFIO_EXTICR1_EXTI2_PE d P    AFIO_EXTICR1_EXTI2_PF c P    AFIO_EXTICR1_EXTI2_PG b P    AFIO_EXTICR1_EXTI3_PA g P    AFIO_EXTICR1_EXTI3_PB f P    AFIO_EXTICR1_EXTI3_PC e P    AFIO_EXTICR1_EXTI3_PD d P    AFIO_EXTICR1_EXTI3_PE c P    AFIO_EXTICR1_EXTI3_PF b P    AFIO_EXTICR1_EXTI3_PG a P    AFIO_EXTICR2_EXTI4 [ P    AFIO_EXTICR2_EXTI5 Z P    AFIO_EXTICR2_EXTI6 Y P    AFIO_EXTICR2_EXTI7 X P    AFIO_EXTICR2_EXTI4_PA e P    AFIO_EXTICR2_EXTI4_PB d P    AFIO_EXTICR2_EXTI4_PC c P    AFIO_EXTICR2_EXTI4_PD b P    AFIO_EXTICR2_EXTI4_PE a P    AFIO_EXTICR2_EXTI4_PF ` P    AFIO_EXTICR2_EXTI4_PG _ P    AFIO_EXTICR2_EXTI5_PA d P    AFIO_EXTICR2_EXTI5_PB c P    AFIO_EXTICR2_EXTI5_PC b P    AFIO_EXTICR2_EXTI5_PD a P    AFIO_EXTICR2_EXTI5_PE ` P    AFIO_EXTICR2_EXTI5_PF _ P    AFIO_EXTICR2_EXTI5_PG ^ P    AFIO_EXTICR2_EXTI6_PA c P    AFIO_EXTICR2_EXTI6_PB b P    AFIO_EXTICR2_EXTI6_PC a P    AFIO_EXTICR2_EXTI6_PD ` P    AFIO_EXTICR2_EXTI6_PE _ P    AFIO_EXTICR2_EXTI6_PF ^ P    AFIO_EXTICR2_EXTI6_PG ] P    AFIO_EXTICR2_EXTI7_PA b P    AFIO_EXTICR2_EXTI7_PB a P    AFIO_EXTICR2_EXTI7_PC ` P    AFIO_EXTICR2_EXTI7_PD _ P    AFIO_EXTICR2_EXTI7_PE ^ P    AFIO_EXTICR2_EXTI7_PF ] P    AFIO_EXTICR2_EXTI7_PG \ P    AFIO_EXTICR3_EXTI8 V P    AFIO_EXTICR3_EXTI9 U P    AFIO_EXTICR3_EXTI10 + P    AFIO_EXTICR3_EXTI11 * P    AFIO_EXTICR3_EXTI8_PA ` P    AFIO_EXTICR3_EXTI8_PB _ P    AFIO_EXTICR3_EXTI8_PC ^ P    AFIO_EXTICR3_EXTI8_PD ] P    AFIO_EXTICR3_EXTI8_PE \ P    AFIO_EXTICR3_EXTI8_PF [ P    AFIO_EXTICR3_EXTI8_PG Z P    AFIO_EXTICR3_EXTI9_PA _ P    AFIO_EXTICR3_EXTI9_PB ^ P    AFIO_EXTICR3_EXTI9_PC ] P    AFIO_EXTICR3_EXTI9_PD \ P    AFIO_EXTICR3_EXTI9_PE [ P    AFIO_EXTICR3_EXTI9_PF Z P    AFIO_EXTICR3_EXTI9_PG Y P    AFIO_EXTICR3_EXTI10_PA 5 P    AFIO_EXTICR3_EXTI10_PB 4 P    AFIO_EXTICR3_EXTI10_PC 3 P    AFIO_EXTICR3_EXTI10_PD 2 P    AFIO_EXTICR3_EXTI10_PE 1 P    AFIO_EXTICR3_EXTI10_PF 0 P    AFIO_EXTICR3_EXTI10_PG / P    AFIO_EXTICR3_EXTI11_PA 4 P    AFIO_EXTICR3_EXTI11_PB 3 P    AFIO_EXTICR3_EXTI11_PC 2 P    AFIO_EXTICR3_EXTI11_PD 1 P    AFIO_EXTICR3_EXTI11_PE 0 P    AFIO_EXTICR3_EXTI11_PF / P    AFIO_EXTICR3_EXTI11_PG . P    AFIO_EXTICR4_EXTI12 ( P    AFIO_EXTICR4_EXTI13 ' P    AFIO_EXTICR4_EXTI14 & P    AFIO_EXTICR4_EXTI15 % P    AFIO_EXTICR4_EXTI12_PA 2 P    AFIO_EXTICR4_EXTI12_PB 1 P    AFIO_EXTICR4_EXTI12_PC 0 P    AFIO_EXTICR4_EXTI12_PD / P    AFIO_EXTICR4_EXTI12_PE . P    AFIO_EXTICR4_EXTI12_PF - P    AFIO_EXTICR4_EXTI12_PG , P    AFIO_EXTICR4_EXTI13_PA 1 P    AFIO_EXTICR4_EXTI13_PB 0 P    AFIO_EXTICR4_EXTI13_PC / P    AFIO_EXTICR4_EXTI13_PD . P    AFIO_EXTICR4_EXTI13_PE - P    AFIO_EXTICR4_EXTI13_PF , P    AFIO_EXTICR4_EXTI13_PG + P    AFIO_EXTICR4_EXTI14_PA 0 P    AFIO_EXTICR4_EXTI14_PB / P    AFIO_EXTICR4_EXTI14_PC . P    AFIO_EXTICR4_EXTI14_PD - P    AFIO_EXTICR4_EXTI14_PE , P    AFIO_EXTICR4_EXTI14_PF + P    AFIO_EXTICR4_EXTI14_PG * P    AFIO_EXTICR4_EXTI15_PA / P    AFIO_EXTICR4_EXTI15_PB . P    AFIO_EXTICR4_EXTI15_PC - P    AFIO_EXTICR4_EXTI15_PD , P    AFIO_EXTICR4_EXTI15_PE + P    AFIO_EXTICR4_EXTI15_PF * P    AFIO_EXTICR4_EXTI15_PG ) P    SysTick_CTRL_ENABLE A P    SysTick_CTRL_TICKINT  P    SysTick_CTRL_CLKSOURCE 7 P    SysTick_CTRL_COUNTFLAG ? P    SysTick_LOAD_RELOAD F P    SysTick_VAL_CURRENT  P    SysTick_CALIB_TENMS ; P    SysTick_CALIB_SKEW  P    SysTick_CALIB_NOREF H P    NVIC_ISER_SETENA  P    NVIC_ISER_SETENA_0 7 P    NVIC_ISER_SETENA_1 6 P    NVIC_ISER_SETENA_2 5 P    NVIC_ISER_SETENA_3 4 P    NVIC_ISER_SETENA_4 3 P    NVIC_ISER_SETENA_5 2 P    NVIC_ISER_SETENA_6 1 P    NVIC_ISER_SETENA_7 0 P    NVIC_ISER_SETENA_8 / P    NVIC_ISER_SETENA_9 . P    NVIC_ISER_SETENA_10  P    NVIC_ISER_SETENA_11  P    NVIC_ISER_SETENA_12  P    NVIC_ISER_SETENA_13  P    NVIC_ISER_SETENA_14   P    NVIC_ISER_SETENA_15  P    NVIC_ISER_SETENA_16  P    NVIC_ISER_SETENA_17  P    NVIC_ISER_SETENA_18  P    NVIC_ISER_SETENA_19  P    NVIC_ISER_SETENA_20  P    NVIC_ISER_SETENA_21  P    NVIC_ISER_SETENA_22  P    NVIC_ISER_SETENA_23   P    NVIC_ISER_SETENA_24  P    NVIC_ISER_SETENA_25  P    NVIC_ISER_SETENA_26  P    NVIC_ISER_SETENA_27  P    NVIC_ISER_SETENA_28  P    NVIC_ISER_SETENA_29  P    NVIC_ISER_SETENA_30  P    NVIC_ISER_SETENA_31  P    NVIC_ICER_CLRENA  P    NVIC_ICER_CLRENA_0 R P    NVIC_ICER_CLRENA_1 Q P    NVIC_ICER_CLRENA_2 P P    NVIC_ICER_CLRENA_3 O P    NVIC_ICER_CLRENA_4 N P    NVIC_ICER_CLRENA_5 M P    NVIC_ICER_CLRENA_6 L P    NVIC_ICER_CLRENA_7 K P    NVIC_ICER_CLRENA_8 J P    NVIC_ICER_CLRENA_9 I P    NVIC_ICER_CLRENA_10  P    NVIC_ICER_CLRENA_11  P    NVIC_ICER_CLRENA_12  P    NVIC_ICER_CLRENA_13  P    NVIC_ICER_CLRENA_14  P    NVIC_ICER_CLRENA_15  P    NVIC_ICER_CLRENA_16  P    NVIC_ICER_CLRENA_17  P    NVIC_ICER_CLRENA_18  P    NVIC_ICER_CLRENA_19  P    NVIC_ICER_CLRENA_20  P    NVIC_ICER_CLRENA_21  P    NVIC_ICER_CLRENA_22  P    NVIC_ICER_CLRENA_23  P    NVIC_ICER_CLRENA_24  P    NVIC_ICER_CLRENA_25  P    NVIC_ICER_CLRENA_26  P    NVIC_ICER_CLRENA_27  P    NVIC_ICER_CLRENA_28  P    NVIC_ICER_CLRENA_29  P    NVIC_ICER_CLRENA_30  P    NVIC_ICER_CLRENA_31  P    NVIC_ISPR_SETPEND j P    NVIC_ISPR_SETPEND_0  P    NVIC_ISPR_SETPEND_1  P    NVIC_ISPR_SETPEND_2  P    NVIC_ISPR_SETPEND_3  P    NVIC_ISPR_SETPEND_4  P    NVIC_ISPR_SETPEND_5  P    NVIC_ISPR_SETPEND_6  P    NVIC_ISPR_SETPEND_7  P    NVIC_ISPR_SETPEND_8  P    NVIC_ISPR_SETPEND_9  P    NVIC_ISPR_SETPEND_10  P    NVIC_ISPR_SETPEND_11  P    NVIC_ISPR_SETPEND_12  P    NVIC_ISPR_SETPEND_13  P    NVIC_ISPR_SETPEND_14  P    NVIC_ISPR_SETPEND_15  P    NVIC_ISPR_SETPEND_16  P    NVIC_ISPR_SETPEND_17  P    NVIC_ISPR_SETPEND_18  P    NVIC_ISPR_SETPEND_19  P    NVIC_ISPR_SETPEND_20  P    NVIC_ISPR_SETPEND_21  P    NVIC_ISPR_SETPEND_22  P    NVIC_ISPR_SETPEND_23  P    NVIC_ISPR_SETPEND_24  P    NVIC_ISPR_SETPEND_25  P    NVIC_ISPR_SETPEND_26  P    NVIC_ISPR_SETPEND_27  P    NVIC_ISPR_SETPEND_28  P    NVIC_ISPR_SETPEND_29  P    NVIC_ISPR_SETPEND_30  P    NVIC_ISPR_SETPEND_31  P    NVIC_ICPR_CLRPEND  P    NVIC_ICPR_CLRPEND_0  P    NVIC_ICPR_CLRPEND_1  P    NVIC_ICPR_CLRPEND_2  P    NVIC_ICPR_CLRPEND_3  P    NVIC_ICPR_CLRPEND_4  P    NVIC_ICPR_CLRPEND_5  P    NVIC_ICPR_CLRPEND_6  P    NVIC_ICPR_CLRPEND_7  P    NVIC_ICPR_CLRPEND_8  P    NVIC_ICPR_CLRPEND_9  P    NVIC_ICPR_CLRPEND_10  P    NVIC_ICPR_CLRPEND_11  P    NVIC_ICPR_CLRPEND_12  P    NVIC_ICPR_CLRPEND_13  P    NVIC_ICPR_CLRPEND_14  P    NVIC_ICPR_CLRPEND_15  P    NVIC_ICPR_CLRPEND_16  P    NVIC_ICPR_CLRPEND_17  P    NVIC_ICPR_CLRPEND_18  P    NVIC_ICPR_CLRPEND_19  P    NVIC_ICPR_CLRPEND_20  P    NVIC_ICPR_CLRPEND_21  P    NVIC_ICPR_CLRPEND_22  P    NVIC_ICPR_CLRPEND_23  P    NVIC_ICPR_CLRPEND_24  P    NVIC_ICPR_CLRPEND_25  P    NVIC_ICPR_CLRPEND_26  P    NVIC_ICPR_CLRPEND_27  P    NVIC_ICPR_CLRPEND_28  P    NVIC_ICPR_CLRPEND_29  P    NVIC_ICPR_CLRPEND_30  P    NVIC_ICPR_CLRPEND_31  P    NVIC_IABR_ACTIVE  P    NVIC_IABR_ACTIVE_0 P P    NVIC_IABR_ACTIVE_1 O P    NVIC_IABR_ACTIVE_2 N P    NVIC_IABR_ACTIVE_3 M P    NVIC_IABR_ACTIVE_4 L P    NVIC_IABR_ACTIVE_5 K P    NVIC_IABR_ACTIVE_6 J P    NVIC_IABR_ACTIVE_7 I P    NVIC_IABR_ACTIVE_8 H P    NVIC_IABR_ACTIVE_9 G P    NVIC_IABR_ACTIVE_10  P    NVIC_IABR_ACTIVE_11  P    NVIC_IABR_ACTIVE_12  P    NVIC_IABR_ACTIVE_13  P    NVIC_IABR_ACTIVE_14  P    NVIC_IABR_ACTIVE_15  P    NVIC_IABR_ACTIVE_16  P    NVIC_IABR_ACTIVE_17  P    NVIC_IABR_ACTIVE_18  P    NVIC_IABR_ACTIVE_19  P    NVIC_IABR_ACTIVE_20  P    NVIC_IABR_ACTIVE_21  P    NVIC_IABR_ACTIVE_22  P    NVIC_IABR_ACTIVE_23  P    NVIC_IABR_ACTIVE_24  P    NVIC_IABR_ACTIVE_25  P    NVIC_IABR_ACTIVE_26  P    NVIC_IABR_ACTIVE_27  P    NVIC_IABR_ACTIVE_28  P    NVIC_IABR_ACTIVE_29  P    NVIC_IABR_ACTIVE_30  P    NVIC_IABR_ACTIVE_31  P    NVIC_IPR0_PRI_0 * P    NVIC_IPR0_PRI_1 ) P    NVIC_IPR0_PRI_2 ( P    NVIC_IPR0_PRI_3 ' P    NVIC_IPR1_PRI_4 % P    NVIC_IPR1_PRI_5 $ P    NVIC_IPR1_PRI_6 # P    NVIC_IPR1_PRI_7 " P    NVIC_IPR2_PRI_8   P    NVIC_IPR2_PRI_9  P    NVIC_IPR2_PRI_10  P    NVIC_IPR2_PRI_11  P    NVIC_IPR3_PRI_12  P    NVIC_IPR3_PRI_13  P    NVIC_IPR3_PRI_14  P    NVIC_IPR3_PRI_15  P    NVIC_IPR4_PRI_16  P    NVIC_IPR4_PRI_17  P    NVIC_IPR4_PRI_18  P    NVIC_IPR4_PRI_19  P    NVIC_IPR5_PRI_20  P    NVIC_IPR5_PRI_21  P    NVIC_IPR5_PRI_22  P    NVIC_IPR5_PRI_23  P    NVIC_IPR6_PRI_24  P    NVIC_IPR6_PRI_25  P    NVIC_IPR6_PRI_26  P    NVIC_IPR6_PRI_27  P    NVIC_IPR7_PRI_28  P    NVIC_IPR7_PRI_29  P    NVIC_IPR7_PRI_30  P    NVIC_IPR7_PRI_31  P    SCB_CPUID_REVISION - P    SCB_CPUID_PARTNO  P    SCB_CPUID_Constant R P    SCB_CPUID_VARIANT  P    SCB_CPUID_IMPLEMENTER T P    SCB_ICSR_VECTACTIVE  P    SCB_ICSR_RETTOBASE 7 P    SCB_ICSR_VECTPENDING  P    SCB_ICSR_ISRPENDING  P    SCB_ICSR_ISRPREEMPT  P    SCB_ICSR_PENDSTCLR 1 P    SCB_ICSR_PENDSTSET & P    SCB_ICSR_PENDSVCLR / P    SCB_ICSR_PENDSVSET $ P    SCB_ICSR_NMIPENDSET  P    SCB_VTOR_TBLOFF  P    SCB_VTOR_TBLBASE  P    SCB_AIRCR_VECTRESET   P    SCB_AIRCR_VECTCLRACTIVE  P    SCB_AIRCR_SYSRESETREQ 0 P    SCB_AIRCR_PRIGROUP ( P    SCB_AIRCR_PRIGROUP_0  P    SCB_AIRCR_PRIGROUP_1  P    SCB_AIRCR_PRIGROUP_2  P    SCB_AIRCR_PRIGROUP0  P    SCB_AIRCR_PRIGROUP1  P    SCB_AIRCR_PRIGROUP2  P    SCB_AIRCR_PRIGROUP3  P    SCB_AIRCR_PRIGROUP4  P    SCB_AIRCR_PRIGROUP5  P    SCB_AIRCR_PRIGROUP6  P    SCB_AIRCR_PRIGROUP7  P    SCB_AIRCR_ENDIANESS  P    SCB_AIRCR_VECTKEY  P    SCB_SCR_SLEEPONEXIT  P    SCB_SCR_SLEEPDEEP  P    SCB_SCR_SEVONPEND y P    SCB_CCR_NONBASETHRDENA % P    SCB_CCR_USERSETMPEND  P    SCB_CCR_UNALIGN_TRP  P    SCB_CCR_DIV_0_TRP t P    SCB_CCR_BFHFNMIGN  P    SCB_CCR_STKALIGN  P    SCB_SHPR_PRI_N D P    SCB_SHPR_PRI_N1  P    SCB_SHPR_PRI_N2  P    SCB_SHPR_PRI_N3  P    SCB_SHCSR_MEMFAULTACT U P    SCB_SHCSR_BUSFAULTACT J P    SCB_SHCSR_USGFAULTACT E P    SCB_SHCSR_SVCALLACT  P    SCB_SHCSR_MONITORACT  P    SCB_SHCSR_PENDSVACT  P    SCB_SHCSR_SYSTICKACT ! P    SCB_SHCSR_USGFAULTPENDED g! P    SCB_SHCSR_MEMFAULTPENDED w! P    SCB_SHCSR_BUSFAULTPENDED l P    SCB_SHCSR_SVCALLPENDED  P    SCB_SHCSR_MEMFAULTENA Y P    SCB_SHCSR_BUSFAULTENA N P    SCB_SHCSR_USGFAULTENA I P    SCB_CFSR_IACCVIOL  P    SCB_CFSR_DACCVIOL  P    SCB_CFSR_MUNSTKERR  P    SCB_CFSR_MSTKERR  P    SCB_CFSR_MMARVALID F P    SCB_CFSR_IBUSERR  P    SCB_CFSR_PRECISERR 4 P    SCB_CFSR_IMPRECISERR  P    SCB_CFSR_UNSTKERR g P    SCB_CFSR_STKERR  P    SCB_CFSR_BFARVALID X P    SCB_CFSR_UNDEFINSTR  P    SCB_CFSR_INVSTATE w P    SCB_CFSR_INVPC k P    SCB_CFSR_NOCP  P    SCB_CFSR_UNALIGNED L P    SCB_CFSR_DIVBYZERO % P    SCB_HFSR_VECTTBL  P    SCB_HFSR_FORCED 1 P    SCB_HFSR_DEBUGEVT  P    SCB_DFSR_HALTED 6 P    SCB_DFSR_BKPT  P    SCB_DFSR_DWTTRAP  P    SCB_DFSR_VCATCH / P    SCB_DFSR_EXTERNAL  P    SCB_MMFAR_ADDRESS  P    SCB_BFAR_ADDRESS  P    SCB_AFSR_IMPDEF 6 P    EXTI_IMR_MR0  P    EXTI_IMR_MR1  P    EXTI_IMR_MR2  P    EXTI_IMR_MR3  P    EXTI_IMR_MR4   P    EXTI_IMR_MR5  P    EXTI_IMR_MR6  P    EXTI_IMR_MR7  P    EXTI_IMR_MR8  P    EXTI_IMR_MR9  P    EXTI_IMR_MR10  P    EXTI_IMR_MR11  P    EXTI_IMR_MR12  P    EXTI_IMR_MR13  P    EXTI_IMR_MR14  P    EXTI_IMR_MR15  P    EXTI_IMR_MR16  P    EXTI_IMR_MR17  P    EXTI_IMR_MR18  P    EXTI_IMR_MR19  P    EXTI_EMR_MR0  P    EXTI_EMR_MR1  P    EXTI_EMR_MR2  P    EXTI_EMR_MR3  P    EXTI_EMR_MR4  P    EXTI_EMR_MR5  P    EXTI_EMR_MR6  P    EXTI_EMR_MR7  P    EXTI_EMR_MR8   P    EXTI_EMR_MR9  P    EXTI_EMR_MR10  P    EXTI_EMR_MR11  P    EXTI_EMR_MR12  P    EXTI_EMR_MR13  P    EXTI_EMR_MR14  P    EXTI_EMR_MR15  P    EXTI_EMR_MR16  P    EXTI_EMR_MR17  P    EXTI_EMR_MR18  P    EXTI_EMR_MR19  P    EXTI_RTSR_TR0  P    EXTI_RTSR_TR1  P    EXTI_RTSR_TR2  P    EXTI_RTSR_TR3  P    EXTI_RTSR_TR4  P    EXTI_RTSR_TR5  P    EXTI_RTSR_TR6  P    EXTI_RTSR_TR7  P    EXTI_RTSR_TR8  P    EXTI_RTSR_TR9  P    EXTI_RTSR_TR10 e P    EXTI_RTSR_TR11 d P    EXTI_RTSR_TR12 c P    EXTI_RTSR_TR13 b P    EXTI_RTSR_TR14 a P    EXTI_RTSR_TR15 ` P    EXTI_RTSR_TR16 _ P    EXTI_RTSR_TR17 ^ P    EXTI_RTSR_TR18 ] P    EXTI_RTSR_TR19 \ P    EXTI_FTSR_TR0  P    EXTI_FTSR_TR1  P    EXTI_FTSR_TR2  P    EXTI_FTSR_TR3  P    EXTI_FTSR_TR4  P    EXTI_FTSR_TR5  P    EXTI_FTSR_TR6  P    EXTI_FTSR_TR7  P    EXTI_FTSR_TR8  P    EXTI_FTSR_TR9  P    EXTI_FTSR_TR10 q P    EXTI_FTSR_TR11 p P    EXTI_FTSR_TR12 o P    EXTI_FTSR_TR13 n P    EXTI_FTSR_TR14 m P    EXTI_FTSR_TR15 l P    EXTI_FTSR_TR16 k P    EXTI_FTSR_TR17 j P    EXTI_FTSR_TR18 i P    EXTI_FTSR_TR19 h P    EXTI_SWIER_SWIER0 m P    EXTI_SWIER_SWIER1 l P    EXTI_SWIER_SWIER2 k P    EXTI_SWIER_SWIER3 j P    EXTI_SWIER_SWIER4 i P    EXTI_SWIER_SWIER5 h P    EXTI_SWIER_SWIER6 g P    EXTI_SWIER_SWIER7 f P    EXTI_SWIER_SWIER8 e P    EXTI_SWIER_SWIER9 d P    EXTI_SWIER_SWIER10 : P    EXTI_SWIER_SWIER11 9 P    EXTI_SWIER_SWIER12 8 P    EXTI_SWIER_SWIER13 7 P    EXTI_SWIER_SWIER14 6 P    EXTI_SWIER_SWIER15 5 P    EXTI_SWIER_SWIER16 4 P    EXTI_SWIER_SWIER17 3 P    EXTI_SWIER_SWIER18 2 P    EXTI_SWIER_SWIER19 1 P    EXTI_PR_PR0 I P    EXTI_PR_PR1 H P    EXTI_PR_PR2 G P    EXTI_PR_PR3 F P    EXTI_PR_PR4 E P    EXTI_PR_PR5 D P    EXTI_PR_PR6 C P    EXTI_PR_PR7 B P    EXTI_PR_PR8 A P    EXTI_PR_PR9 @ P    EXTI_PR_PR10  P    EXTI_PR_PR11  P    EXTI_PR_PR12  P    EXTI_PR_PR13  P    EXTI_PR_PR14  P    EXTI_PR_PR15  P    EXTI_PR_PR16  P    EXTI_PR_PR17  P    EXTI_PR_PR18  P    EXTI_PR_PR19  P    DMA_ISR_GIF1 . P    DMA_ISR_TCIF1  P    DMA_ISR_HTIF1  P    DMA_ISR_TEIF1  P    DMA_ISR_GIF2 - P    DMA_ISR_TCIF2  P    DMA_ISR_HTIF2  P    DMA_ISR_TEIF2  P    DMA_ISR_GIF3 , P    DMA_ISR_TCIF3  P    DMA_ISR_HTIF3  P    DMA_ISR_TEIF3  P    DMA_ISR_GIF4 + P    DMA_ISR_TCIF4  P    DMA_ISR_HTIF4  P    DMA_ISR_TEIF4  P    DMA_ISR_GIF5 * P    DMA_ISR_TCIF5  P    DMA_ISR_HTIF5  P    DMA_ISR_TEIF5  P    DMA_ISR_GIF6 ) P    DMA_ISR_TCIF6  P    DMA_ISR_HTIF6  P    DMA_ISR_TEIF6  P    DMA_ISR_GIF7 ( P    DMA_ISR_TCIF7  P    DMA_ISR_HTIF7  P    DMA_ISR_TEIF7  P    DMA_IFCR_CGIF1  P    DMA_IFCR_CTCIF1 _ P    DMA_IFCR_CHTIF1 Z P    DMA_IFCR_CTEIF1 ] P    DMA_IFCR_CGIF2  P    DMA_IFCR_CTCIF2 ^ P    DMA_IFCR_CHTIF2 Y P    DMA_IFCR_CTEIF2 \ P    DMA_IFCR_CGIF3  P    DMA_IFCR_CTCIF3 ] P    DMA_IFCR_CHTIF3 X P    DMA_IFCR_CTEIF3 [ P    DMA_IFCR_CGIF4  P    DMA_IFCR_CTCIF4 \ P    DMA_IFCR_CHTIF4 W P    DMA_IFCR_CTEIF4 Z P    DMA_IFCR_CGIF5  P    DMA_IFCR_CTCIF5 [ P    DMA_IFCR_CHTIF5 V P    DMA_IFCR_CTEIF5 Y P    DMA_IFCR_CGIF6  P    DMA_IFCR_CTCIF6 Z P    DMA_IFCR_CHTIF6 U P    DMA_IFCR_CTEIF6 X P    DMA_IFCR_CGIF7  P    DMA_IFCR_CTCIF7 Y P    DMA_IFCR_CHTIF7 T P    DMA_IFCR_CTEIF7 W P    DMA_CCR1_EN  P    DMA_CCR1_TCIE  P    DMA_CCR1_HTIE  P    DMA_CCR1_TEIE  P    DMA_CCR1_DIR ; P    DMA_CCR1_CIRC  P    DMA_CCR1_PINC  P    DMA_CCR1_MINC  P    DMA_CCR1_PSIZE  P    DMA_CCR1_PSIZE_0  P    DMA_CCR1_PSIZE_1  P    DMA_CCR1_MSIZE  P    DMA_CCR1_MSIZE_0  P    DMA_CCR1_MSIZE_1  P    DMA_CCR1_PL  P    DMA_CCR1_PL_0  P    DMA_CCR1_PL_1  P    DMA_CCR1_MEM2MEM " P    DMA_CCR2_EN  P    DMA_CCR2_TCIE  P    DMA_CCR2_HTIE  P    DMA_CCR2_TEIE  P    DMA_CCR2_DIR : P    DMA_CCR2_CIRC  P    DMA_CCR2_PINC  P    DMA_CCR2_MINC  P    DMA_CCR2_PSIZE  P    DMA_CCR2_PSIZE_0  P    DMA_CCR2_PSIZE_1  P    DMA_CCR2_MSIZE  P    DMA_CCR2_MSIZE_0  P    DMA_CCR2_MSIZE_1  P    DMA_CCR2_PL  P    DMA_CCR2_PL_0  P    DMA_CCR2_PL_1  P    DMA_CCR2_MEM2MEM ! P    DMA_CCR3_EN  P    DMA_CCR3_TCIE  P    DMA_CCR3_HTIE  P    DMA_CCR3_TEIE  P    DMA_CCR3_DIR 9 P    DMA_CCR3_CIRC  P    DMA_CCR3_PINC  P    DMA_CCR3_MINC  P    DMA_CCR3_PSIZE  P    DMA_CCR3_PSIZE_0  P    DMA_CCR3_PSIZE_1  P    DMA_CCR3_MSIZE  P    DMA_CCR3_MSIZE_0  P    DMA_CCR3_MSIZE_1  P    DMA_CCR3_PL ~ P    DMA_CCR3_PL_0  P    DMA_CCR3_PL_1  P    DMA_CCR3_MEM2MEM   P    DMA_CCR4_EN  P    DMA_CCR4_TCIE  P    DMA_CCR4_HTIE  P    DMA_CCR4_TEIE  P    DMA_CCR4_DIR 8 P    DMA_CCR4_CIRC  P    DMA_CCR4_PINC  P    DMA_CCR4_MINC  P    DMA_CCR4_PSIZE  P    DMA_CCR4_PSIZE_0  P    DMA_CCR4_PSIZE_1  P    DMA_CCR4_MSIZE  P    DMA_CCR4_MSIZE_0  P    DMA_CCR4_MSIZE_1  P    DMA_CCR4_PL } P    DMA_CCR4_PL_0  P    DMA_CCR4_PL_1  P    DMA_CCR4_MEM2MEM  P    DMA_CCR5_EN  P    DMA_CCR5_TCIE  P    DMA_CCR5_HTIE  P    DMA_CCR5_TEIE  P    DMA_CCR5_DIR 7 P    DMA_CCR5_CIRC  P    DMA_CCR5_PINC  P    DMA_CCR5_MINC  P    DMA_CCR5_PSIZE  P    DMA_CCR5_PSIZE_0  P    DMA_CCR5_PSIZE_1  P    DMA_CCR5_MSIZE  P    DMA_CCR5_MSIZE_0  P    DMA_CCR5_MSIZE_1  P    DMA_CCR5_PL | P    DMA_CCR5_PL_0  P    DMA_CCR5_PL_1  P    DMA_CCR5_MEM2MEM  P    DMA_CCR6_EN  P    DMA_CCR6_TCIE  P    DMA_CCR6_HTIE  P    DMA_CCR6_TEIE  P    DMA_CCR6_DIR 6 P    DMA_CCR6_CIRC  P    DMA_CCR6_PINC  P    DMA_CCR6_MINC  P    DMA_CCR6_PSIZE  P    DMA_CCR6_PSIZE_0  P    DMA_CCR6_PSIZE_1  P    DMA_CCR6_MSIZE  P    DMA_CCR6_MSIZE_0  P    DMA_CCR6_MSIZE_1  P    DMA_CCR6_PL { P    DMA_CCR6_PL_0  P    DMA_CCR6_PL_1  P    DMA_CCR6_MEM2MEM  P    DMA_CCR7_EN  P    DMA_CCR7_TCIE  P    DMA_CCR7_HTIE  P    DMA_CCR7_TEIE  P    DMA_CCR7_DIR 5 P    DMA_CCR7_CIRC  P    DMA_CCR7_PINC  P    DMA_CCR7_MINC  P    DMA_CCR7_PSIZE  P    DMA_CCR7_PSIZE_0  P    DMA_CCR7_PSIZE_1  P    DMA_CCR7_MSIZE  P    DMA_CCR7_MSIZE_0  P    DMA_CCR7_MSIZE_1  P    DMA_CCR7_PL z P    DMA_CCR7_PL_0  P    DMA_CCR7_PL_1  P    DMA_CCR7_MEM2MEM  P    DMA_CNDTR1_NDT  P    DMA_CNDTR2_NDT  P    DMA_CNDTR3_NDT  P    DMA_CNDTR4_NDT  P    DMA_CNDTR5_NDT  P    DMA_CNDTR6_NDT  P    DMA_CNDTR7_NDT  P    DMA_CPAR1_PA ; P    DMA_CPAR2_PA : P    DMA_CPAR3_PA 9 P    DMA_CPAR4_PA 8 P    DMA_CPAR5_PA 7 P    DMA_CPAR6_PA 6 P    DMA_CPAR7_PA 5 P    DMA_CMAR1_MA A P    DMA_CMAR2_MA @ P    DMA_CMAR3_MA ? P    DMA_CMAR4_MA > P    DMA_CMAR5_MA = P    DMA_CMAR6_MA < P    DMA_CMAR7_MA ; P    ADC_SR_AWD  P    ADC_SR_EOC  P    ADC_SR_JEOC i P    ADC_SR_JSTRT  P    ADC_SR_STRT = P    ADC_CR1_AWDCH  P    ADC_CR1_AWDCH_0 k P    ADC_CR1_AWDCH_1 j P    ADC_CR1_AWDCH_2 i P    ADC_CR1_AWDCH_3 h P    ADC_CR1_AWDCH_4 g P    ADC_CR1_EOCIE   P    ADC_CR1_AWDIE  P    ADC_CR1_JEOCIE  P    ADC_CR1_SCAN B P    ADC_CR1_AWDSGL  P    ADC_CR1_JAUTO  P    ADC_CR1_DISCEN  P    ADC_CR1_JDISCEN a P    ADC_CR1_DISCNUM N P    ADC_CR1_DISCNUM_0  P    ADC_CR1_DISCNUM_1  P    ADC_CR1_DISCNUM_2  P    ADC_CR1_DUALMOD [ P    ADC_CR1_DUALMOD_0  P    ADC_CR1_DUALMOD_1  P    ADC_CR1_DUALMOD_2  P    ADC_CR1_DUALMOD_3  P    ADC_CR1_JAWDEN  P    ADC_CR1_AWDEN  P    ADC_CR2_ADON D P    ADC_CR2_CONT 2 P    ADC_CR2_CAL  P    ADC_CR2_RSTCAL  P    ADC_CR2_DMA  P    ADC_CR2_ALIGN  P    ADC_CR2_JEXTSEL A P    ADC_CR2_JEXTSEL_0  P    ADC_CR2_JEXTSEL_1  P    ADC_CR2_JEXTSEL_2  P    ADC_CR2_JEXTTRIG  P    ADC_CR2_EXTSEL  P    ADC_CR2_EXTSEL_0  P    ADC_CR2_EXTSEL_1  P    ADC_CR2_EXTSEL_2  P    ADC_CR2_EXTTRIG 9 P    ADC_CR2_JSWSTART  P    ADC_CR2_SWSTART ( P    ADC_CR2_TSVREFE A P    ADC_SMPR1_SMP10 c P    ADC_SMPR1_SMP10_0  P    ADC_SMPR1_SMP10_1  P    ADC_SMPR1_SMP10_2  P    ADC_SMPR1_SMP11 b P    ADC_SMPR1_SMP11_0  P    ADC_SMPR1_SMP11_1  P    ADC_SMPR1_SMP11_2  P    ADC_SMPR1_SMP12 a P    ADC_SMPR1_SMP12_0  P    ADC_SMPR1_SMP12_1  P    ADC_SMPR1_SMP12_2  P    ADC_SMPR1_SMP13 ` P    ADC_SMPR1_SMP13_0  P    ADC_SMPR1_SMP13_1  P    ADC_SMPR1_SMP13_2  P    ADC_SMPR1_SMP14 _ P    ADC_SMPR1_SMP14_0  P    ADC_SMPR1_SMP14_1  P    ADC_SMPR1_SMP14_2  P    ADC_SMPR1_SMP15 ^ P    ADC_SMPR1_SMP15_0  P    ADC_SMPR1_SMP15_1  P    ADC_SMPR1_SMP15_2  P    ADC_SMPR1_SMP16 ] P    ADC_SMPR1_SMP16_0  P    ADC_SMPR1_SMP16_1  P    ADC_SMPR1_SMP16_2  P    ADC_SMPR1_SMP17 \ P    ADC_SMPR1_SMP17_0  P    ADC_SMPR1_SMP17_1  P    ADC_SMPR1_SMP17_2  P    ADC_SMPR2_SMP0  P    ADC_SMPR2_SMP0_0  P    ADC_SMPR2_SMP0_1  P    ADC_SMPR2_SMP0_2   P    ADC_SMPR2_SMP1  P    ADC_SMPR2_SMP1_0  P    ADC_SMPR2_SMP1_1   P    ADC_SMPR2_SMP1_2  P    ADC_SMPR2_SMP2  P    ADC_SMPR2_SMP2_0   P    ADC_SMPR2_SMP2_1  P    ADC_SMPR2_SMP2_2  P    ADC_SMPR2_SMP3  P    ADC_SMPR2_SMP3_0  P    ADC_SMPR2_SMP3_1  P    ADC_SMPR2_SMP3_2  P    ADC_SMPR2_SMP4  P    ADC_SMPR2_SMP4_0  P    ADC_SMPR2_SMP4_1  P    ADC_SMPR2_SMP4_2  P    ADC_SMPR2_SMP5  P    ADC_SMPR2_SMP5_0  P    ADC_SMPR2_SMP5_1  P    ADC_SMPR2_SMP5_2  P    ADC_SMPR2_SMP6  P    ADC_SMPR2_SMP6_0  P    ADC_SMPR2_SMP6_1  P    ADC_SMPR2_SMP6_2  P    ADC_SMPR2_SMP7  P    ADC_SMPR2_SMP7_0  P    ADC_SMPR2_SMP7_1  P    ADC_SMPR2_SMP7_2  P    ADC_SMPR2_SMP8  P    ADC_SMPR2_SMP8_0  P    ADC_SMPR2_SMP8_1  P    ADC_SMPR2_SMP8_2  P    ADC_SMPR2_SMP9  P    ADC_SMPR2_SMP9_0  P    ADC_SMPR2_SMP9_1  P    ADC_SMPR2_SMP9_2  P    ADC_JOFR1_JOFFSET1 } P    ADC_JOFR2_JOFFSET2 { P    ADC_JOFR3_JOFFSET3 y P    ADC_JOFR4_JOFFSET4 w P    ADC_HTR_HT  P    ADC_LTR_LT  P    ADC_SQR1_SQ13  P    ADC_SQR1_SQ13_0 i P    ADC_SQR1_SQ13_1 h P    ADC_SQR1_SQ13_2 g P    ADC_SQR1_SQ13_3 f P    ADC_SQR1_SQ13_4 e P    ADC_SQR1_SQ14  P    ADC_SQR1_SQ14_0 h P    ADC_SQR1_SQ14_1 g P    ADC_SQR1_SQ14_2 f P    ADC_SQR1_SQ14_3 e P    ADC_SQR1_SQ14_4 d P    ADC_SQR1_SQ15  P    ADC_SQR1_SQ15_0 g P    ADC_SQR1_SQ15_1 f P    ADC_SQR1_SQ15_2 e P    ADC_SQR1_SQ15_3 d P    ADC_SQR1_SQ15_4 c P    ADC_SQR1_SQ16  P    ADC_SQR1_SQ16_0 f P    ADC_SQR1_SQ16_1 e P    ADC_SQR1_SQ16_2 d P    ADC_SQR1_SQ16_3 c P    ADC_SQR1_SQ16_4 b P    ADC_SQR1_L  P    ADC_SQR1_L_0 + P    ADC_SQR1_L_1 * P    ADC_SQR1_L_2 ) P    ADC_SQR1_L_3 ( P    ADC_SQR2_SQ7 * P    ADC_SQR2_SQ7_0  P    ADC_SQR2_SQ7_1  P    ADC_SQR2_SQ7_2  P    ADC_SQR2_SQ7_3  P    ADC_SQR2_SQ7_4  P    ADC_SQR2_SQ8 ) P    ADC_SQR2_SQ8_0  P    ADC_SQR2_SQ8_1  P    ADC_SQR2_SQ8_2  P    ADC_SQR2_SQ8_3  P    ADC_SQR2_SQ8_4  P    ADC_SQR2_SQ9 ( P    ADC_SQR2_SQ9_0  P    ADC_SQR2_SQ9_1  P    ADC_SQR2_SQ9_2  P    ADC_SQR2_SQ9_3  P    ADC_SQR2_SQ9_4  P    ADC_SQR2_SQ10  P    ADC_SQR2_SQ10_0 k P    ADC_SQR2_SQ10_1 j P    ADC_SQR2_SQ10_2 i P    ADC_SQR2_SQ10_3 h P    ADC_SQR2_SQ10_4 g P    ADC_SQR2_SQ11  P    ADC_SQR2_SQ11_0 j P    ADC_SQR2_SQ11_1 i P    ADC_SQR2_SQ11_2 h P    ADC_SQR2_SQ11_3 g P    ADC_SQR2_SQ11_4 f P    ADC_SQR2_SQ12  P    ADC_SQR2_SQ12_0 i P    ADC_SQR2_SQ12_1 h P    ADC_SQR2_SQ12_2 g P    ADC_SQR2_SQ12_3 f P    ADC_SQR2_SQ12_4 e P    ADC_SQR3_SQ1 / P    ADC_SQR3_SQ1_0  P    ADC_SQR3_SQ1_1  P    ADC_SQR3_SQ1_2  P    ADC_SQR3_SQ1_3  P    ADC_SQR3_SQ1_4  P    ADC_SQR3_SQ2 . P    ADC_SQR3_SQ2_0  P    ADC_SQR3_SQ2_1  P    ADC_SQR3_SQ2_2  P    ADC_SQR3_SQ2_3  P    ADC_SQR3_SQ2_4  P    ADC_SQR3_SQ3 - P    ADC_SQR3_SQ3_0  P    ADC_SQR3_SQ3_1  P    ADC_SQR3_SQ3_2  P    ADC_SQR3_SQ3_3  P    ADC_SQR3_SQ3_4  P    ADC_SQR3_SQ4 , P    ADC_SQR3_SQ4_0  P    ADC_SQR3_SQ4_1  P    ADC_SQR3_SQ4_2  P    ADC_SQR3_SQ4_3  P    ADC_SQR3_SQ4_4  P    ADC_SQR3_SQ5 + P    ADC_SQR3_SQ5_0  P    ADC_SQR3_SQ5_1  P    ADC_SQR3_SQ5_2  P    ADC_SQR3_SQ5_3  P    ADC_SQR3_SQ5_4  P    ADC_SQR3_SQ6 * P    ADC_SQR3_SQ6_0  P    ADC_SQR3_SQ6_1  P    ADC_SQR3_SQ6_2  P    ADC_SQR3_SQ6_3  P    ADC_SQR3_SQ6_4  P    ADC_JSQR_JSQ1  P    ADC_JSQR_JSQ1_0 9 P    ADC_JSQR_JSQ1_1 8 P    ADC_JSQR_JSQ1_2 7 P    ADC_JSQR_JSQ1_3 6 P    ADC_JSQR_JSQ1_4 5 P    ADC_JSQR_JSQ2  P    ADC_JSQR_JSQ2_0 8 P    ADC_JSQR_JSQ2_1 7 P    ADC_JSQR_JSQ2_2 6 P    ADC_JSQR_JSQ2_3 5 P    ADC_JSQR_JSQ2_4 4 P    ADC_JSQR_JSQ3  P    ADC_JSQR_JSQ3_0 7 P    ADC_JSQR_JSQ3_1 6 P    ADC_JSQR_JSQ3_2 5 P    ADC_JSQR_JSQ3_3 4 P    ADC_JSQR_JSQ3_4 3 P    ADC_JSQR_JSQ4  P    ADC_JSQR_JSQ4_0 6 P    ADC_JSQR_JSQ4_1 5 P    ADC_JSQR_JSQ4_2 4 P    ADC_JSQR_JSQ4_3 3 P    ADC_JSQR_JSQ4_4 2 P    ADC_JSQR_JL Y P    ADC_JSQR_JL_0  P    ADC_JSQR_JL_1  P    ADC_JDR1_JDATA  P    ADC_JDR2_JDATA  P    ADC_JDR3_JDATA  P    ADC_JDR4_JDATA  P    ADC_DR_DATA  P    ADC_DR_ADC2DATA } P    DAC_CR_EN1  P    DAC_CR_BOFF1 J P    DAC_CR_TEN1  P    DAC_CR_TSEL1 / P    DAC_CR_TSEL1_0  P    DAC_CR_TSEL1_1  P    DAC_CR_TSEL1_2  P    DAC_CR_WAVE1 4 P    DAC_CR_WAVE1_0  P    DAC_CR_WAVE1_1  P    DAC_CR_MAMP1 < P    DAC_CR_MAMP1_0  P    DAC_CR_MAMP1_1  P    DAC_CR_MAMP1_2  P    DAC_CR_MAMP1_3  P    DAC_CR_DMAEN1   P    DAC_CR_EN2  P    DAC_CR_BOFF2 I P    DAC_CR_TEN2  P    DAC_CR_TSEL2 . P    DAC_CR_TSEL2_0  P    DAC_CR_TSEL2_1  P    DAC_CR_TSEL2_2  P    DAC_CR_WAVE2 3 P    DAC_CR_WAVE2_0  P    DAC_CR_WAVE2_1  P    DAC_CR_MAMP2 ; P    DAC_CR_MAMP2_0  P    DAC_CR_MAMP2_1  P    DAC_CR_MAMP2_2  P    DAC_CR_MAMP2_3  P    DAC_CR_DMAEN2  P    DAC_SWTRIGR_SWTRIG1  P    DAC_SWTRIGR_SWTRIG2  P    DAC_DHR12R1_DACC1DHR ? P    DAC_DHR12L1_DACC1DHR E P    DAC_DHR8R1_DACC1DHR l P    DAC_DHR12R2_DACC2DHR = P    DAC_DHR12L2_DACC2DHR C P    DAC_DHR8R2_DACC2DHR j P    DAC_DHR12RD_DACC1DHR , P    DAC_DHR12RD_DACC2DHR + P    DAC_DHR12LD_DACC1DHR 2 P    DAC_DHR12LD_DACC2DHR 1 P    DAC_DHR8RD_DACC1DHR Y P    DAC_DHR8RD_DACC2DHR X P    DAC_DOR1_DACC1DOR  P    DAC_DOR2_DACC2DOR  P    DAC_SR_DMAUDR1  P    DAC_SR_DMAUDR2  P    CEC_CFGR_PE u P    CEC_CFGR_IE | P    CEC_CFGR_BTEM  P    CEC_CFGR_BPEM  P    CEC_OAR_OA  P    CEC_OAR_OA_0 ) P    CEC_OAR_OA_1 ( P    CEC_OAR_OA_2 ' P    CEC_OAR_OA_3 & P    CEC_PRES_PRES  P    CEC_ESR_BTE g P    CEC_ESR_BPE k P    CEC_ESR_RBTFE  P    CEC_ESR_SBE h P    CEC_ESR_ACKE , P    CEC_ESR_LINE  P    CEC_ESR_TBTFE  P    CEC_CSR_TSOM  P    CEC_CSR_TEOM  P    CEC_CSR_TERR  P    CEC_CSR_TBTRF  P    CEC_CSR_RSOM  P    CEC_CSR_REOM  P    CEC_CSR_RERR  P    CEC_CSR_RBTF  P    CEC_TXD_TXD L P    CEC_RXD_RXD P P    TIM_CR1_CEN q P    TIM_CR1_UDIS  P    TIM_CR1_URS M P    TIM_CR1_OPM [ P    TIM_CR1_DIR h P    TIM_CR1_CMS d P    TIM_CR1_CMS_0  P    TIM_CR1_CMS_1  P    TIM_CR1_ARPE  P    TIM_CR1_CKD u P    TIM_CR1_CKD_0  P    TIM_CR1_CKD_1  P    TIM_CR2_CCPC + P    TIM_CR2_CCUS  P    TIM_CR2_CCDS ' P    TIM_CR2_MMS Y P    TIM_CR2_MMS_0  P    TIM_CR2_MMS_1  P    TIM_CR2_MMS_2  P    TIM_CR2_TI1S # P    TIM_CR2_OIS1 ( P    TIM_CR2_OIS1N  P    TIM_CR2_OIS2 ' P    TIM_CR2_OIS2N  P    TIM_CR2_OIS3 & P    TIM_CR2_OIS3N  P    TIM_CR2_OIS4 % P    TIM_SMCR_SMS  P    TIM_SMCR_SMS_0 P P    TIM_SMCR_SMS_1 O P    TIM_SMCR_SMS_2 N P    TIM_SMCR_TS 1 P    TIM_SMCR_TS_0  P    TIM_SMCR_TS_1  P    TIM_SMCR_TS_2  P    TIM_SMCR_MSM  P    TIM_SMCR_ETF  P    TIM_SMCR_ETF_0 d P    TIM_SMCR_ETF_1 c P    TIM_SMCR_ETF_2 b P    TIM_SMCR_ETF_3 a P    TIM_SMCR_ETPS  P    TIM_SMCR_ETPS_0  P    TIM_SMCR_ETPS_1  P    TIM_SMCR_ECE 	 P    TIM_SMCR_ETP  P    TIM_DIER_UIE  P    TIM_DIER_CC1IE  P    TIM_DIER_CC2IE  P    TIM_DIER_CC3IE  P    TIM_DIER_CC4IE  P    TIM_DIER_COMIE v P    TIM_DIER_TIE  P    TIM_DIER_BIE  P    TIM_DIER_UDE 	 P    TIM_DIER_CC1DE  P    TIM_DIER_CC2DE  P    TIM_DIER_CC3DE  P    TIM_DIER_CC4DE  P    TIM_DIER_COMDE { P    TIM_DIER_TDE 
 P    TIM_SR_UIF  P    TIM_SR_CC1IF   P    TIM_SR_CC2IF  P    TIM_SR_CC3IF  P    TIM_SR_CC4IF  P    TIM_SR_COMIF  P    TIM_SR_TIF  P    TIM_SR_BIF  P    TIM_SR_CC1OF  P    TIM_SR_CC2OF  P    TIM_SR_CC3OF  P    TIM_SR_CC4OF  P    TIM_EGR_UG  P    TIM_EGR_CC1G / P    TIM_EGR_CC2G . P    TIM_EGR_CC3G - P    TIM_EGR_CC4G , P    TIM_EGR_COMG  P    TIM_EGR_TG  P    TIM_EGR_BG  P    TIM_CCMR1_CC1S  P    TIM_CCMR1_CC1S_0  P    TIM_CCMR1_CC1S_1  P    TIM_CCMR1_OC1FE a P    TIM_CCMR1_OC1PE W P    TIM_CCMR1_OC1M  P    TIM_CCMR1_OC1M_0  P    TIM_CCMR1_OC1M_1  P    TIM_CCMR1_OC1M_2  P    TIM_CCMR1_OC1CE d P    TIM_CCMR1_CC2S  P    TIM_CCMR1_CC2S_0  P    TIM_CCMR1_CC2S_1  P    TIM_CCMR1_OC2FE ` P    TIM_CCMR1_OC2PE V P    TIM_CCMR1_OC2M  P    TIM_CCMR1_OC2M_0  P    TIM_CCMR1_OC2M_1  P    TIM_CCMR1_OC2M_2  P    TIM_CCMR1_OC2CE c P    TIM_CCMR1_IC1PSC 
 P    TIM_CCMR1_IC1PSC_0 w P    TIM_CCMR1_IC1PSC_1 v P    TIM_CCMR1_IC1F  P    TIM_CCMR1_IC1F_0  P    TIM_CCMR1_IC1F_1  P    TIM_CCMR1_IC1F_2  P    TIM_CCMR1_IC1F_3  P    TIM_CCMR1_IC2PSC 	 P    TIM_CCMR1_IC2PSC_0 v P    TIM_CCMR1_IC2PSC_1 u P    TIM_CCMR1_IC2F  P    TIM_CCMR1_IC2F_0  P    TIM_CCMR1_IC2F_1  P    TIM_CCMR1_IC2F_2  P    TIM_CCMR1_IC2F_3  P    TIM_CCMR2_CC3S  P    TIM_CCMR2_CC3S_0  P    TIM_CCMR2_CC3S_1  P    TIM_CCMR2_OC3FE ^ P    TIM_CCMR2_OC3PE T P    TIM_CCMR2_OC3M  P    TIM_CCMR2_OC3M_0  P    TIM_CCMR2_OC3M_1 
 P    TIM_CCMR2_OC3M_2 	 P    TIM_CCMR2_OC3CE a P    TIM_CCMR2_CC4S  P    TIM_CCMR2_CC4S_0  P    TIM_CCMR2_CC4S_1  P    TIM_CCMR2_OC4FE ] P    TIM_CCMR2_OC4PE S P    TIM_CCMR2_OC4M  P    TIM_CCMR2_OC4M_0 
 P    TIM_CCMR2_OC4M_1 	 P    TIM_CCMR2_OC4M_2  P    TIM_CCMR2_OC4CE ` P    TIM_CCMR2_IC3PSC  P    TIM_CCMR2_IC3PSC_0 t P    TIM_CCMR2_IC3PSC_1 s P    TIM_CCMR2_IC3F  P    TIM_CCMR2_IC3F_0  P    TIM_CCMR2_IC3F_1  P    TIM_CCMR2_IC3F_2  P    TIM_CCMR2_IC3F_3  P    TIM_CCMR2_IC4PSC  P    TIM_CCMR2_IC4PSC_0 s P    TIM_CCMR2_IC4PSC_1 r P    TIM_CCMR2_IC4F  P    TIM_CCMR2_IC4F_0  P    TIM_CCMR2_IC4F_1  P    TIM_CCMR2_IC4F_2  P    TIM_CCMR2_IC4F_3  P    TIM_CCER_CC1E  P    TIM_CCER_CC1P  P    TIM_CCER_CC1NE  P    TIM_CCER_CC1NP  P    TIM_CCER_CC2E  P    TIM_CCER_CC2P  P    TIM_CCER_CC2NE  P    TIM_CCER_CC2NP  P    TIM_CCER_CC3E  P    TIM_CCER_CC3P  P    TIM_CCER_CC3NE  P    TIM_CCER_CC3NP  P    TIM_CCER_CC4E  P    TIM_CCER_CC4P  P    TIM_CCER_CC4NP  P    TIM_CNT_CNT C P    TIM_PSC_PSC A P    TIM_ARR_ARR C P    TIM_RCR_REP ? P    TIM_CCR1_CCR1  P    TIM_CCR2_CCR2  P    TIM_CCR3_CCR3  P    TIM_CCR4_CCR4  P    TIM_BDTR_DTG   P    TIM_BDTR_DTG_0 m P    TIM_BDTR_DTG_1 l P    TIM_BDTR_DTG_2 k P    TIM_BDTR_DTG_3 j P    TIM_BDTR_DTG_4 i P    TIM_BDTR_DTG_5 h P    TIM_BDTR_DTG_6 g P    TIM_BDTR_DTG_7 f P    TIM_BDTR_LOCK  P    TIM_BDTR_LOCK_0 ! P    TIM_BDTR_LOCK_1   P    TIM_BDTR_OSSI  P    TIM_BDTR_OSSR  P    TIM_BDTR_BKE  P    TIM_BDTR_BKP  P    TIM_BDTR_AOE 
 P    TIM_BDTR_MOE  P    TIM_DCR_DBA m P    TIM_DCR_DBA_0  P    TIM_DCR_DBA_1  P    TIM_DCR_DBA_2  P    TIM_DCR_DBA_3  P    TIM_DCR_DBA_4  P    TIM_DCR_DBL b P    TIM_DCR_DBL_0  P    TIM_DCR_DBL_1  P    TIM_DCR_DBL_2  P    TIM_DCR_DBL_3  P    TIM_DCR_DBL_4  P    TIM_DMAR_DMAB  P    RTC_CRH_SECIE  P    RTC_CRH_ALRIE  P    RTC_CRH_OWIE  P    RTC_CRL_SECF 
 P    RTC_CRL_ALRF  P    RTC_CRL_OWF A P    RTC_CRL_RSF B P    RTC_CRL_CNF V P    RTC_CRL_RTOFF  P    RTC_PRLH_PRL  P    RTC_PRLL_PRL  P    RTC_DIVH_RTC_DIV  P    RTC_DIVL_RTC_DIV  P    RTC_CNTH_RTC_CNT  P    RTC_CNTL_RTC_CNT  P    RTC_ALRH_RTC_ALR  P    RTC_ALRL_RTC_ALR  P    IWDG_KR_KEY F P    IWDG_PR_PR  P    IWDG_PR_PR_0  P    IWDG_PR_PR_1  P    IWDG_PR_PR_2  P    IWDG_RLR_RL > P    IWDG_SR_PVU , P    IWDG_SR_RVU * P    
WWDG_CR_T  P    WWDG_CR_T0  P    WWDG_CR_T1  P    WWDG_CR_T2  P    WWDG_CR_T3  P    WWDG_CR_T4  P    WWDG_CR_T5  P    WWDG_CR_T6  P    WWDG_CR_WDGA  P    WWDG_CFR_W  P    WWDG_CFR_W0 \ P    WWDG_CFR_W1 [ P    WWDG_CFR_W2 Z P    WWDG_CFR_W3 Y P    WWDG_CFR_W4 X P    WWDG_CFR_W5 W P    WWDG_CFR_W6 V P    WWDG_CFR_WDGTB e P    WWDG_CFR_WDGTB0 3 P    WWDG_CFR_WDGTB1 2 P    WWDG_CFR_EWI  P    WWDG_SR_EWIF  P    FSMC_BCR1_MBKEN Q P    FSMC_BCR1_MUXEN 1 P    FSMC_BCR1_MTYP v P    FSMC_BCR1_MTYP_0  P    FSMC_BCR1_MTYP_1  P    FSMC_BCR1_MWID  P    FSMC_BCR1_MWID_0  P    FSMC_BCR1_MWID_1  P    FSMC_BCR1_FACCEN  P    FSMC_BCR1_BURSTEN  P    FSMC_BCR1_WAITPOL  P    FSMC_BCR1_WRAPMOD  P    FSMC_BCR1_WAITCFG  P    FSMC_BCR1_WREN  P    FSMC_BCR1_WAITEN  P    FSMC_BCR1_EXTMOD  P    FSMC_BCR1_ASYNCWAIT  P    FSMC_BCR1_CBURSTRW < P    FSMC_BCR2_MBKEN P P    FSMC_BCR2_MUXEN 0 P    FSMC_BCR2_MTYP u P    FSMC_BCR2_MTYP_0  P    FSMC_BCR2_MTYP_1  P    FSMC_BCR2_MWID  P    FSMC_BCR2_MWID_0  P    FSMC_BCR2_MWID_1  P    FSMC_BCR2_FACCEN  P    FSMC_BCR2_BURSTEN  P    FSMC_BCR2_WAITPOL  P    FSMC_BCR2_WRAPMOD  P    FSMC_BCR2_WAITCFG  P    FSMC_BCR2_WREN  P    FSMC_BCR2_WAITEN  P    FSMC_BCR2_EXTMOD  P    FSMC_BCR2_ASYNCWAIT  P    FSMC_BCR2_CBURSTRW ; P    FSMC_BCR3_MBKEN O P    FSMC_BCR3_MUXEN / P    FSMC_BCR3_MTYP t P    FSMC_BCR3_MTYP_0  P    FSMC_BCR3_MTYP_1  P    FSMC_BCR3_MWID  P    FSMC_BCR3_MWID_0  P    FSMC_BCR3_MWID_1  P    FSMC_BCR3_FACCEN  P    FSMC_BCR3_BURSTEN  P    FSMC_BCR3_WAITPOL  P    FSMC_BCR3_WRAPMOD  P    FSMC_BCR3_WAITCFG  P    FSMC_BCR3_WREN  P    FSMC_BCR3_WAITEN  P    FSMC_BCR3_EXTMOD  P    FSMC_BCR3_ASYNCWAIT  P    FSMC_BCR3_CBURSTRW : P    FSMC_BCR4_MBKEN N P    FSMC_BCR4_MUXEN . P    FSMC_BCR4_MTYP s P    FSMC_BCR4_MTYP_0  P    FSMC_BCR4_MTYP_1  P    FSMC_BCR4_MWID  P    FSMC_BCR4_MWID_0  P    FSMC_BCR4_MWID_1  P    FSMC_BCR4_FACCEN  P    FSMC_BCR4_BURSTEN  P    FSMC_BCR4_WAITPOL  P    FSMC_BCR4_WRAPMOD  P    FSMC_BCR4_WAITCFG  P    FSMC_BCR4_WREN  P    FSMC_BCR4_WAITEN  P    FSMC_BCR4_EXTMOD  P    FSMC_BCR4_ASYNCWAIT   P    FSMC_BCR4_CBURSTRW 9 P    FSMC_BTR1_ADDSET  P    FSMC_BTR1_ADDSET_0 c P    FSMC_BTR1_ADDSET_1 b P    FSMC_BTR1_ADDSET_2 a P    FSMC_BTR1_ADDSET_3 ` P    FSMC_BTR1_ADDHLD 
 P    FSMC_BTR1_ADDHLD_0 w P    FSMC_BTR1_ADDHLD_1 v P    FSMC_BTR1_ADDHLD_2 u P    FSMC_BTR1_ADDHLD_3 t P    FSMC_BTR1_DATAST  P    FSMC_BTR1_DATAST_0 W P    FSMC_BTR1_DATAST_1 V P    FSMC_BTR1_DATAST_2 U P    FSMC_BTR1_DATAST_3 T P    FSMC_BTR1_BUSTURN v P    FSMC_BTR1_BUSTURN_0  P    FSMC_BTR1_BUSTURN_1  P    FSMC_BTR1_BUSTURN_2  P    FSMC_BTR1_BUSTURN_3  P    FSMC_BTR1_CLKDIV  P    FSMC_BTR1_CLKDIV_0 [ P    FSMC_BTR1_CLKDIV_1 Z P    FSMC_BTR1_CLKDIV_2 Y P    FSMC_BTR1_CLKDIV_3 X P    FSMC_BTR1_DATLAT  P    FSMC_BTR1_DATLAT_0 ^ P    FSMC_BTR1_DATLAT_1 ] P    FSMC_BTR1_DATLAT_2 \ P    FSMC_BTR1_DATLAT_3 [ P    FSMC_BTR1_ACCMOD  P    FSMC_BTR1_ACCMOD_0 q P    FSMC_BTR1_ACCMOD_1 p P    FSMC_BTR2_ADDSET  P    FSMC_BTR2_ADDSET_0 b P    FSMC_BTR2_ADDSET_1 a P    FSMC_BTR2_ADDSET_2 ` P    FSMC_BTR2_ADDSET_3 _ P    FSMC_BTR2_ADDHLD 	 P    FSMC_BTR2_ADDHLD_0 v P    FSMC_BTR2_ADDHLD_1 u P    FSMC_BTR2_ADDHLD_2 t P    FSMC_BTR2_ADDHLD_3 s P    FSMC_BTR2_DATAST  P    FSMC_BTR2_DATAST_0 V P    FSMC_BTR2_DATAST_1 U P    FSMC_BTR2_DATAST_2 T P    FSMC_BTR2_DATAST_3 S P    FSMC_BTR2_BUSTURN u P    FSMC_BTR2_BUSTURN_0  P    FSMC_BTR2_BUSTURN_1  P    FSMC_BTR2_BUSTURN_2  P    FSMC_BTR2_BUSTURN_3  P    FSMC_BTR2_CLKDIV  P    FSMC_BTR2_CLKDIV_0 Z P    FSMC_BTR2_CLKDIV_1 Y P    FSMC_BTR2_CLKDIV_2 X P    FSMC_BTR2_CLKDIV_3 W P    FSMC_BTR2_DATLAT  P    FSMC_BTR2_DATLAT_0 ] P    FSMC_BTR2_DATLAT_1 \ P    FSMC_BTR2_DATLAT_2 [ P    FSMC_BTR2_DATLAT_3 Z P    FSMC_BTR2_ACCMOD  P    FSMC_BTR2_ACCMOD_0 p P    FSMC_BTR2_ACCMOD_1 o P    FSMC_BTR3_ADDSET  P    FSMC_BTR3_ADDSET_0 a P    FSMC_BTR3_ADDSET_1 ` P    FSMC_BTR3_ADDSET_2 _ P    FSMC_BTR3_ADDSET_3 ^ P    FSMC_BTR3_ADDHLD  P    FSMC_BTR3_ADDHLD_0 u P    FSMC_BTR3_ADDHLD_1 t P    FSMC_BTR3_ADDHLD_2 s P    FSMC_BTR3_ADDHLD_3 r P    FSMC_BTR3_DATAST  P    FSMC_BTR3_DATAST_0 U P    FSMC_BTR3_DATAST_1 T P    FSMC_BTR3_DATAST_2 S P    FSMC_BTR3_DATAST_3 R P    FSMC_BTR3_BUSTURN t P    FSMC_BTR3_BUSTURN_0  P    FSMC_BTR3_BUSTURN_1  P    FSMC_BTR3_BUSTURN_2  P    FSMC_BTR3_BUSTURN_3  P    FSMC_BTR3_CLKDIV  P    FSMC_BTR3_CLKDIV_0 Y P    FSMC_BTR3_CLKDIV_1 X P    FSMC_BTR3_CLKDIV_2 W P    FSMC_BTR3_CLKDIV_3 V P    FSMC_BTR3_DATLAT  P    FSMC_BTR3_DATLAT_0 \ P    FSMC_BTR3_DATLAT_1 [ P    FSMC_BTR3_DATLAT_2 Z P    FSMC_BTR3_DATLAT_3 Y P    FSMC_BTR3_ACCMOD  P    FSMC_BTR3_ACCMOD_0 o P    FSMC_BTR3_ACCMOD_1 n P    FSMC_BTR4_ADDSET  P    FSMC_BTR4_ADDSET_0 ` P    FSMC_BTR4_ADDSET_1 _ P    FSMC_BTR4_ADDSET_2 ^ P    FSMC_BTR4_ADDSET_3 ] P    FSMC_BTR4_ADDHLD  P    FSMC_BTR4_ADDHLD_0 t P    FSMC_BTR4_ADDHLD_1 s P    FSMC_BTR4_ADDHLD_2 r P    FSMC_BTR4_ADDHLD_3 q P    FSMC_BTR4_DATAST  P    FSMC_BTR4_DATAST_0 T P    FSMC_BTR4_DATAST_1 S P    FSMC_BTR4_DATAST_2 R P    FSMC_BTR4_DATAST_3 Q P    FSMC_BTR4_BUSTURN s P    FSMC_BTR4_BUSTURN_0  P    FSMC_BTR4_BUSTURN_1  P    FSMC_BTR4_BUSTURN_2  P    FSMC_BTR4_BUSTURN_3  P    FSMC_BTR4_CLKDIV  P    FSMC_BTR4_CLKDIV_0 X P    FSMC_BTR4_CLKDIV_1 W P    FSMC_BTR4_CLKDIV_2 V P    FSMC_BTR4_CLKDIV_3 U P    FSMC_BTR4_DATLAT  P    FSMC_BTR4_DATLAT_0 [ P    FSMC_BTR4_DATLAT_1 Z P    FSMC_BTR4_DATLAT_2 Y P    FSMC_BTR4_DATLAT_3 X P    FSMC_BTR4_ACCMOD  P    FSMC_BTR4_ACCMOD_0 n P    FSMC_BTR4_ACCMOD_1 m P    FSMC_BWTR1_ADDSET  P    FSMC_BWTR1_ADDSET_0 
 P    FSMC_BWTR1_ADDSET_1 	 P    FSMC_BWTR1_ADDSET_2  P    FSMC_BWTR1_ADDSET_3  P    FSMC_BWTR1_ADDHLD  P    FSMC_BWTR1_ADDHLD_0  P    FSMC_BWTR1_ADDHLD_1  P    FSMC_BWTR1_ADDHLD_2  P    FSMC_BWTR1_ADDHLD_3  P    FSMC_BWTR1_DATAST  P    FSMC_BWTR1_DATAST_0  P    FSMC_BWTR1_DATAST_1  P    FSMC_BWTR1_DATAST_2  P    FSMC_BWTR1_DATAST_3  P    FSMC_BWTR1_CLKDIV  P    FSMC_BWTR1_CLKDIV_0  P    FSMC_BWTR1_CLKDIV_1  P    FSMC_BWTR1_CLKDIV_2   P    FSMC_BWTR1_CLKDIV_3  P    FSMC_BWTR1_DATLAT  P    FSMC_BWTR1_DATLAT_0  P    FSMC_BWTR1_DATLAT_1  P    FSMC_BWTR1_DATLAT_2  P    FSMC_BWTR1_DATLAT_3  P    FSMC_BWTR1_ACCMOD  P    FSMC_BWTR1_ACCMOD_0  P    FSMC_BWTR1_ACCMOD_1  P    FSMC_BWTR2_ADDSET  P    FSMC_BWTR2_ADDSET_0 	 P    FSMC_BWTR2_ADDSET_1  P    FSMC_BWTR2_ADDSET_2  P    FSMC_BWTR2_ADDSET_3  P    FSMC_BWTR2_ADDHLD  P    FSMC_BWTR2_ADDHLD_0  P    FSMC_BWTR2_ADDHLD_1  P    FSMC_BWTR2_ADDHLD_2  P    FSMC_BWTR2_ADDHLD_3  P    FSMC_BWTR2_DATAST  P    FSMC_BWTR2_DATAST_0  P    FSMC_BWTR2_DATAST_1  P    FSMC_BWTR2_DATAST_2  P    FSMC_BWTR2_DATAST_3  P    FSMC_BWTR2_CLKDIV  P    FSMC_BWTR2_CLKDIV_0  P    FSMC_BWTR2_CLKDIV_1   P    FSMC_BWTR2_CLKDIV_2  P    FSMC_BWTR2_CLKDIV_3  P    FSMC_BWTR2_DATLAT  P    FSMC_BWTR2_DATLAT_0  P    FSMC_BWTR2_DATLAT_1  P    FSMC_BWTR2_DATLAT_2  P    FSMC_BWTR2_DATLAT_3  P    FSMC_BWTR2_ACCMOD  P    FSMC_BWTR2_ACCMOD_0  P    FSMC_BWTR2_ACCMOD_1  P    FSMC_BWTR3_ADDSET  P    FSMC_BWTR3_ADDSET_0  P    FSMC_BWTR3_ADDSET_1  P    FSMC_BWTR3_ADDSET_2  P    FSMC_BWTR3_ADDSET_3  P    FSMC_BWTR3_ADDHLD  P    FSMC_BWTR3_ADDHLD_0  P    FSMC_BWTR3_ADDHLD_1  P    FSMC_BWTR3_ADDHLD_2  P    FSMC_BWTR3_ADDHLD_3  P    FSMC_BWTR3_DATAST  P    FSMC_BWTR3_DATAST_0  P    FSMC_BWTR3_DATAST_1  P    FSMC_BWTR3_DATAST_2  P    FSMC_BWTR3_DATAST_3  P    FSMC_BWTR3_CLKDIV  P    FSMC_BWTR3_CLKDIV_0   P    FSMC_BWTR3_CLKDIV_1  P    FSMC_BWTR3_CLKDIV_2  P    FSMC_BWTR3_CLKDIV_3  P    FSMC_BWTR3_DATLAT  P    FSMC_BWTR3_DATLAT_0  P    FSMC_BWTR3_DATLAT_1  P    FSMC_BWTR3_DATLAT_2  P    FSMC_BWTR3_DATLAT_3   P    FSMC_BWTR3_ACCMOD  P    FSMC_BWTR3_ACCMOD_0  P    FSMC_BWTR3_ACCMOD_1  P    FSMC_BWTR4_ADDSET  P    FSMC_BWTR4_ADDSET_0  P    FSMC_BWTR4_ADDSET_1  P    FSMC_BWTR4_ADDSET_2  P    FSMC_BWTR4_ADDSET_3  P    FSMC_BWTR4_ADDHLD  P    FSMC_BWTR4_ADDHLD_0  P    FSMC_BWTR4_ADDHLD_1  P    FSMC_BWTR4_ADDHLD_2  P    FSMC_BWTR4_ADDHLD_3  P    FSMC_BWTR4_DATAST  P    FSMC_BWTR4_DATAST_0  P    FSMC_BWTR4_DATAST_1  P    FSMC_BWTR4_DATAST_2  P    FSMC_BWTR4_DATAST_3  P    FSMC_BWTR4_CLKDIV  P    FSMC_BWTR4_CLKDIV_0  P    FSMC_BWTR4_CLKDIV_1  P    FSMC_BWTR4_CLKDIV_2  P    FSMC_BWTR4_CLKDIV_3  P    FSMC_BWTR4_DATLAT  P    FSMC_BWTR4_DATLAT_0  P    FSMC_BWTR4_DATLAT_1  P    FSMC_BWTR4_DATLAT_2   P    FSMC_BWTR4_DATLAT_3  P    FSMC_BWTR4_ACCMOD  P    FSMC_BWTR4_ACCMOD_0  P    FSMC_BWTR4_ACCMOD_1  P    FSMC_PCR2_PWAITEN  P    FSMC_PCR2_PBKEN ? P    FSMC_PCR2_PTYP d P    FSMC_PCR2_PWID } P    FSMC_PCR2_PWID_0  P    FSMC_PCR2_PWID_1  P    FSMC_PCR2_ECCEN Q P    FSMC_PCR2_TCLR | P    FSMC_PCR2_TCLR_0  P    FSMC_PCR2_TCLR_1  P    FSMC_PCR2_TCLR_2  P    FSMC_PCR2_TCLR_3  P    FSMC_PCR2_TAR  P    FSMC_PCR2_TAR_0 9 P    FSMC_PCR2_TAR_1 8 P    FSMC_PCR2_TAR_2 7 P    FSMC_PCR2_TAR_3 6 P    FSMC_PCR2_ECCPS A P    FSMC_PCR2_ECCPS_0  P    FSMC_PCR2_ECCPS_1  P    FSMC_PCR2_ECCPS_2  P    FSMC_PCR3_PWAITEN  P    FSMC_PCR3_PBKEN > P    FSMC_PCR3_PTYP c P    FSMC_PCR3_PWID | P    FSMC_PCR3_PWID_0  P    FSMC_PCR3_PWID_1  P    FSMC_PCR3_ECCEN P P    FSMC_PCR3_TCLR { P    FSMC_PCR3_TCLR_0  P    FSMC_PCR3_TCLR_1  P    FSMC_PCR3_TCLR_2  P    FSMC_PCR3_TCLR_3  P    FSMC_PCR3_TAR  P    FSMC_PCR3_TAR_0 8 P    FSMC_PCR3_TAR_1 7 P    FSMC_PCR3_TAR_2 6 P    FSMC_PCR3_TAR_3 5 P    FSMC_PCR3_ECCPS @ P    FSMC_PCR3_ECCPS_0  P    FSMC_PCR3_ECCPS_1  P    FSMC_PCR3_ECCPS_2  P    FSMC_PCR4_PWAITEN  P    FSMC_PCR4_PBKEN = P    FSMC_PCR4_PTYP b P    FSMC_PCR4_PWID { P    FSMC_PCR4_PWID_0  P    FSMC_PCR4_PWID_1  P    FSMC_PCR4_ECCEN O P    FSMC_PCR4_TCLR z P    FSMC_PCR4_TCLR_0  P    FSMC_PCR4_TCLR_1  P    FSMC_PCR4_TCLR_2  P    FSMC_PCR4_TCLR_3  P    FSMC_PCR4_TAR  P    FSMC_PCR4_TAR_0 7 P    FSMC_PCR4_TAR_1 6 P    FSMC_PCR4_TAR_2 5 P    FSMC_PCR4_TAR_3 4 P    FSMC_PCR4_ECCPS ? P    FSMC_PCR4_ECCPS_0  P    FSMC_PCR4_ECCPS_1  P    FSMC_PCR4_ECCPS_2  P    FSMC_SR2_IRS  P    FSMC_SR2_ILS  P    FSMC_SR2_IFS  P    FSMC_SR2_IREN  P    FSMC_SR2_ILEN  P    FSMC_SR2_IFEN  P    FSMC_SR2_FEMPT u P    FSMC_SR3_IRS  P    FSMC_SR3_ILS  P    FSMC_SR3_IFS  P    FSMC_SR3_IREN  P    FSMC_SR3_ILEN  P    FSMC_SR3_IFEN  P    FSMC_SR3_FEMPT t P    FSMC_SR4_IRS  P    FSMC_SR4_ILS  P    FSMC_SR4_IFS  P    FSMC_SR4_IREN  P    FSMC_SR4_ILEN  P    FSMC_SR4_IFEN  P    FSMC_SR4_FEMPT s P    FSMC_PMEM2_MEMSET2 b P    FSMC_PMEM2_MEMSET2_0  P    FSMC_PMEM2_MEMSET2_1  P    FSMC_PMEM2_MEMSET2_2  P    FSMC_PMEM2_MEMSET2_3  P    FSMC_PMEM2_MEMSET2_4  P    FSMC_PMEM2_MEMSET2_5  P    FSMC_PMEM2_MEMSET2_6  P    FSMC_PMEM2_MEMSET2_7  P    FSMC_PMEM2_MEMWAIT2  P    FSMC_PMEM2_MEMWAIT2_0  P    FSMC_PMEM2_MEMWAIT2_1  P    FSMC_PMEM2_MEMWAIT2_2  P    FSMC_PMEM2_MEMWAIT2_3  P    FSMC_PMEM2_MEMWAIT2_4  P    FSMC_PMEM2_MEMWAIT2_5  P    FSMC_PMEM2_MEMWAIT2_6 ~ P    FSMC_PMEM2_MEMWAIT2_7 } P    FSMC_PMEM2_MEMHOLD2 % P    FSMC_PMEM2_MEMHOLD2_0  P    FSMC_PMEM2_MEMHOLD2_1  P    FSMC_PMEM2_MEMHOLD2_2  P    FSMC_PMEM2_MEMHOLD2_3  P    FSMC_PMEM2_MEMHOLD2_4  P    FSMC_PMEM2_MEMHOLD2_5  P    FSMC_PMEM2_MEMHOLD2_6  P    FSMC_PMEM2_MEMHOLD2_7  P    FSMC_PMEM2_MEMHIZ2 c P    FSMC_PMEM2_MEMHIZ2_0  P    FSMC_PMEM2_MEMHIZ2_1  P    FSMC_PMEM2_MEMHIZ2_2  P    FSMC_PMEM2_MEMHIZ2_3  P    FSMC_PMEM2_MEMHIZ2_4  P    FSMC_PMEM2_MEMHIZ2_5  P    FSMC_PMEM2_MEMHIZ2_6  P    FSMC_PMEM2_MEMHIZ2_7  P    FSMC_PMEM3_MEMSET3 ` P    FSMC_PMEM3_MEMSET3_0  P    FSMC_PMEM3_MEMSET3_1  P    FSMC_PMEM3_MEMSET3_2  P    FSMC_PMEM3_MEMSET3_3  P    FSMC_PMEM3_MEMSET3_4  P    FSMC_PMEM3_MEMSET3_5  P    FSMC_PMEM3_MEMSET3_6  P    FSMC_PMEM3_MEMSET3_7  P    FSMC_PMEM3_MEMWAIT3  P    FSMC_PMEM3_MEMWAIT3_0  P    FSMC_PMEM3_MEMWAIT3_1  P    FSMC_PMEM3_MEMWAIT3_2  P    FSMC_PMEM3_MEMWAIT3_3  P    FSMC_PMEM3_MEMWAIT3_4 ~ P    FSMC_PMEM3_MEMWAIT3_5 } P    FSMC_PMEM3_MEMWAIT3_6 | P    FSMC_PMEM3_MEMWAIT3_7 { P    FSMC_PMEM3_MEMHOLD3 # P    FSMC_PMEM3_MEMHOLD3_0  P    FSMC_PMEM3_MEMHOLD3_1  P    FSMC_PMEM3_MEMHOLD3_2  P    FSMC_PMEM3_MEMHOLD3_3  P    FSMC_PMEM3_MEMHOLD3_4  P    FSMC_PMEM3_MEMHOLD3_5  P    FSMC_PMEM3_MEMHOLD3_6  P    FSMC_PMEM3_MEMHOLD3_7  P    FSMC_PMEM3_MEMHIZ3 a P    FSMC_PMEM3_MEMHIZ3_0  P    FSMC_PMEM3_MEMHIZ3_1  P    FSMC_PMEM3_MEMHIZ3_2  P    FSMC_PMEM3_MEMHIZ3_3  P    FSMC_PMEM3_MEMHIZ3_4  P    FSMC_PMEM3_MEMHIZ3_5  P    FSMC_PMEM3_MEMHIZ3_6  P    FSMC_PMEM3_MEMHIZ3_7  P    FSMC_PMEM4_MEMSET4 ^ P    FSMC_PMEM4_MEMSET4_0  P    FSMC_PMEM4_MEMSET4_1  P    FSMC_PMEM4_MEMSET4_2  P    FSMC_PMEM4_MEMSET4_3  P    FSMC_PMEM4_MEMSET4_4  P    FSMC_PMEM4_MEMSET4_5  P    FSMC_PMEM4_MEMSET4_6  P    FSMC_PMEM4_MEMSET4_7  P    FSMC_PMEM4_MEMWAIT4  P    FSMC_PMEM4_MEMWAIT4_0  P    FSMC_PMEM4_MEMWAIT4_1  P    FSMC_PMEM4_MEMWAIT4_2 ~ P    FSMC_PMEM4_MEMWAIT4_3 } P    FSMC_PMEM4_MEMWAIT4_4 | P    FSMC_PMEM4_MEMWAIT4_5 { P    FSMC_PMEM4_MEMWAIT4_6 z P    FSMC_PMEM4_MEMWAIT4_7 y P    FSMC_PMEM4_MEMHOLD4 ! P    FSMC_PMEM4_MEMHOLD4_0  P    FSMC_PMEM4_MEMHOLD4_1  P    FSMC_PMEM4_MEMHOLD4_2  P    FSMC_PMEM4_MEMHOLD4_3  P    FSMC_PMEM4_MEMHOLD4_4  P    FSMC_PMEM4_MEMHOLD4_5  P    FSMC_PMEM4_MEMHOLD4_6  P    FSMC_PMEM4_MEMHOLD4_7  P    FSMC_PMEM4_MEMHIZ4 _ P    FSMC_PMEM4_MEMHIZ4_0  P    FSMC_PMEM4_MEMHIZ4_1  P    FSMC_PMEM4_MEMHIZ4_2  P    FSMC_PMEM4_MEMHIZ4_3  P    FSMC_PMEM4_MEMHIZ4_4  P    FSMC_PMEM4_MEMHIZ4_5  P    FSMC_PMEM4_MEMHIZ4_6  P    FSMC_PMEM4_MEMHIZ4_7  P    FSMC_PATT2_ATTSET2 N P    FSMC_PATT2_ATTSET2_0  P    FSMC_PATT2_ATTSET2_1  P    FSMC_PATT2_ATTSET2_2  P    FSMC_PATT2_ATTSET2_3  P    FSMC_PATT2_ATTSET2_4  P    FSMC_PATT2_ATTSET2_5  P    FSMC_PATT2_ATTSET2_6  P    FSMC_PATT2_ATTSET2_7  P    FSMC_PATT2_ATTWAIT2  P    FSMC_PATT2_ATTWAIT2_0 p P    FSMC_PATT2_ATTWAIT2_1 o P    FSMC_PATT2_ATTWAIT2_2 n P    FSMC_PATT2_ATTWAIT2_3 m P    FSMC_PATT2_ATTWAIT2_4 l P    FSMC_PATT2_ATTWAIT2_5 k P    FSMC_PATT2_ATTWAIT2_6 j P    FSMC_PATT2_ATTWAIT2_7 i P    FSMC_PATT2_ATTHOLD2  P    FSMC_PATT2_ATTHOLD2_0 ~ P    FSMC_PATT2_ATTHOLD2_1 } P    FSMC_PATT2_ATTHOLD2_2 | P    FSMC_PATT2_ATTHOLD2_3 { P    FSMC_PATT2_ATTHOLD2_4 z P    FSMC_PATT2_ATTHOLD2_5 y P    FSMC_PATT2_ATTHOLD2_6 x P    FSMC_PATT2_ATTHOLD2_7 w P    FSMC_PATT2_ATTHIZ2 O P    FSMC_PATT2_ATTHIZ2_0  P    FSMC_PATT2_ATTHIZ2_1  P    FSMC_PATT2_ATTHIZ2_2  P    FSMC_PATT2_ATTHIZ2_3  P    FSMC_PATT2_ATTHIZ2_4  P    FSMC_PATT2_ATTHIZ2_5  P    FSMC_PATT2_ATTHIZ2_6  P    FSMC_PATT2_ATTHIZ2_7  P    FSMC_PATT3_ATTSET3 L P    FSMC_PATT3_ATTSET3_0  P    FSMC_PATT3_ATTSET3_1  P    FSMC_PATT3_ATTSET3_2  P    FSMC_PATT3_ATTSET3_3  P    FSMC_PATT3_ATTSET3_4  P    FSMC_PATT3_ATTSET3_5  P    FSMC_PATT3_ATTSET3_6  P    FSMC_PATT3_ATTSET3_7  P    FSMC_PATT3_ATTWAIT3  P    FSMC_PATT3_ATTWAIT3_0 n P    FSMC_PATT3_ATTWAIT3_1 m P    FSMC_PATT3_ATTWAIT3_2 l P    FSMC_PATT3_ATTWAIT3_3 k P    FSMC_PATT3_ATTWAIT3_4 j P    FSMC_PATT3_ATTWAIT3_5 i P    FSMC_PATT3_ATTWAIT3_6 h P    FSMC_PATT3_ATTWAIT3_7 g P    FSMC_PATT3_ATTHOLD3  P    FSMC_PATT3_ATTHOLD3_0 | P    FSMC_PATT3_ATTHOLD3_1 { P    FSMC_PATT3_ATTHOLD3_2 z P    FSMC_PATT3_ATTHOLD3_3 y P    FSMC_PATT3_ATTHOLD3_4 x P    FSMC_PATT3_ATTHOLD3_5 w P    FSMC_PATT3_ATTHOLD3_6 v P    FSMC_PATT3_ATTHOLD3_7 u P    FSMC_PATT3_ATTHIZ3 M P    FSMC_PATT3_ATTHIZ3_0  P    FSMC_PATT3_ATTHIZ3_1  P    FSMC_PATT3_ATTHIZ3_2  P    FSMC_PATT3_ATTHIZ3_3  P    FSMC_PATT3_ATTHIZ3_4  P    FSMC_PATT3_ATTHIZ3_5  P    FSMC_PATT3_ATTHIZ3_6  P    FSMC_PATT3_ATTHIZ3_7  P    FSMC_PATT4_ATTSET4 J P    FSMC_PATT4_ATTSET4_0  P    FSMC_PATT4_ATTSET4_1  P    FSMC_PATT4_ATTSET4_2  P    FSMC_PATT4_ATTSET4_3  P    FSMC_PATT4_ATTSET4_4  P    FSMC_PATT4_ATTSET4_5  P    FSMC_PATT4_ATTSET4_6  P    FSMC_PATT4_ATTSET4_7  P    FSMC_PATT4_ATTWAIT4  P    FSMC_PATT4_ATTWAIT4_0 l P    FSMC_PATT4_ATTWAIT4_1 k P    FSMC_PATT4_ATTWAIT4_2 j P    FSMC_PATT4_ATTWAIT4_3 i P    FSMC_PATT4_ATTWAIT4_4 h P    FSMC_PATT4_ATTWAIT4_5 g P    FSMC_PATT4_ATTWAIT4_6 f P    FSMC_PATT4_ATTWAIT4_7 e P    FSMC_PATT4_ATTHOLD4  P    FSMC_PATT4_ATTHOLD4_0 z P    FSMC_PATT4_ATTHOLD4_1 y P    FSMC_PATT4_ATTHOLD4_2 x P    FSMC_PATT4_ATTHOLD4_3 w P    FSMC_PATT4_ATTHOLD4_4 v P    FSMC_PATT4_ATTHOLD4_5 u P    FSMC_PATT4_ATTHOLD4_6 t P    FSMC_PATT4_ATTHOLD4_7 s P    FSMC_PATT4_ATTHIZ4 K P    FSMC_PATT4_ATTHIZ4_0  P    FSMC_PATT4_ATTHIZ4_1  P    FSMC_PATT4_ATTHIZ4_2  P    FSMC_PATT4_ATTHIZ4_3  P    FSMC_PATT4_ATTHIZ4_4  P    FSMC_PATT4_ATTHIZ4_5  P    FSMC_PATT4_ATTHIZ4_6  P    FSMC_PATT4_ATTHIZ4_7  P    FSMC_PIO4_IOSET4  P    FSMC_PIO4_IOSET4_0 ] P    FSMC_PIO4_IOSET4_1 \ P    FSMC_PIO4_IOSET4_2 [ P    FSMC_PIO4_IOSET4_3 Z P    FSMC_PIO4_IOSET4_4 Y P    FSMC_PIO4_IOSET4_5 X P    FSMC_PIO4_IOSET4_6 W P    FSMC_PIO4_IOSET4_7 V P    FSMC_PIO4_IOWAIT4  P    FSMC_PIO4_IOWAIT4_0  P    FSMC_PIO4_IOWAIT4_1  P    FSMC_PIO4_IOWAIT4_2  P    FSMC_PIO4_IOWAIT4_3  P    FSMC_PIO4_IOWAIT4_4  P    FSMC_PIO4_IOWAIT4_5  P    FSMC_PIO4_IOWAIT4_6  P    FSMC_PIO4_IOWAIT4_7  P    FSMC_PIO4_IOHOLD4  P    FSMC_PIO4_IOHOLD4_0   P    FSMC_PIO4_IOHOLD4_1  P    FSMC_PIO4_IOHOLD4_2  P    FSMC_PIO4_IOHOLD4_3  P    FSMC_PIO4_IOHOLD4_4  P    FSMC_PIO4_IOHOLD4_5  P    FSMC_PIO4_IOHOLD4_6  P    FSMC_PIO4_IOHOLD4_7  P    FSMC_PIO4_IOHIZ4  P    FSMC_PIO4_IOHIZ4_0 ^ P    FSMC_PIO4_IOHIZ4_1 ] P    FSMC_PIO4_IOHIZ4_2 \ P    FSMC_PIO4_IOHIZ4_3 [ P    FSMC_PIO4_IOHIZ4_4 Z P    FSMC_PIO4_IOHIZ4_5 Y P    FSMC_PIO4_IOHIZ4_6 X P    FSMC_PIO4_IOHIZ4_7 W P    FSMC_ECCR2_ECC2 z P    FSMC_ECCR3_ECC3 x P    SDIO_POWER_PWRCTRL  P    SDIO_POWER_PWRCTRL_0 l P    SDIO_POWER_PWRCTRL_1 k P    SDIO_CLKCR_CLKDIV  P    SDIO_CLKCR_CLKEN  P    SDIO_CLKCR_PWRSAV j P    SDIO_CLKCR_BYPASS { P    SDIO_CLKCR_WIDBUS  P    SDIO_CLKCR_WIDBUS_0  P    SDIO_CLKCR_WIDBUS_1  P    SDIO_CLKCR_NEGEDGE \ P    SDIO_CLKCR_HWFC_EN 1 P    SDIO_ARG_CMDARG 8 P    SDIO_CMD_CMDINDEX  P    SDIO_CMD_WAITRESP y P    SDIO_CMD_WAITRESP_0  P    SDIO_CMD_WAITRESP_1  P    SDIO_CMD_WAITINT  P    SDIO_CMD_WAITPEND  P    SDIO_CMD_CPSMEN & P    SDIO_CMD_SDIOSUSPEND  P    SDIO_CMD_ENCMDCOMPL  P    SDIO_CMD_NIEN  P    SDIO_CMD_CEATACMD  P    SDIO_RESPCMD_RESPCMD  P    SDIO_RESP0_CARDSTATUS0  P    SDIO_RESP1_CARDSTATUS1  P    SDIO_RESP2_CARDSTATUS2  P    SDIO_RESP3_CARDSTATUS3  P    SDIO_RESP4_CARDSTATUS4  P    SDIO_DTIMER_DATATIME  P    SDIO_DLEN_DATALENGTH  P    SDIO_DCTRL_DTEN  P    SDIO_DCTRL_DTDIR  P    SDIO_DCTRL_DTMODE  P    SDIO_DCTRL_DMAEN  P    SDIO_DCTRL_DBLOCKSIZE Q  P    SDIO_DCTRL_DBLOCKSIZE_0   P    SDIO_DCTRL_DBLOCKSIZE_1   P    SDIO_DCTRL_DBLOCKSIZE_2   P    SDIO_DCTRL_DBLOCKSIZE_3  P    SDIO_DCTRL_RWSTART 
 P    SDIO_DCTRL_RWSTOP T P    SDIO_DCTRL_RWMOD  P    SDIO_DCTRL_SDIOEN  P    SDIO_DCOUNT_DATACOUNT D P    SDIO_STA_CCRCFAIL  P    SDIO_STA_DCRCFAIL  P    SDIO_STA_CTIMEOUT j P    SDIO_STA_DTIMEOUT i P    SDIO_STA_TXUNDERR X P    SDIO_STA_RXOVERR  P    SDIO_STA_CMDREND  P    SDIO_STA_CMDSENT  P    SDIO_STA_DATAEND  P    SDIO_STA_STBITERR e P    SDIO_STA_DBCKEND  P    SDIO_STA_CMDACT , P    SDIO_STA_TXACT V P    SDIO_STA_RXACT X P    SDIO_STA_TXFIFOHE w P    SDIO_STA_RXFIFOHF x P    SDIO_STA_TXFIFOF  P    SDIO_STA_RXFIFOF  P    SDIO_STA_TXFIFOE  P    SDIO_STA_RXFIFOE  P    SDIO_STA_TXDAVL  P    SDIO_STA_RXDAVL  P    SDIO_STA_SDIOIT  P    SDIO_STA_CEATAEND  P    SDIO_ICR_CCRCFAILC b P    SDIO_ICR_DCRCFAILC a P    SDIO_ICR_CTIMEOUTC / P    SDIO_ICR_DTIMEOUTC . P    SDIO_ICR_TXUNDERRC  P    SDIO_ICR_RXOVERRC c P    SDIO_ICR_CMDRENDC  P    SDIO_ICR_CMDSENTC  P    SDIO_ICR_DATAENDC  P    SDIO_ICR_STBITERRC * P    SDIO_ICR_DBCKENDC  P    SDIO_ICR_SDIOITC  P    SDIO_ICR_CEATAENDC d P    SDIO_MASK_CCRCFAILIE  P    SDIO_MASK_DCRCFAILIE  P    SDIO_MASK_CTIMEOUTIE  P    SDIO_MASK_DTIMEOUTIE  P    SDIO_MASK_TXUNDERRIE  P    SDIO_MASK_RXOVERRIE  P    SDIO_MASK_CMDRENDIE  P    SDIO_MASK_CMDSENTIE  P    SDIO_MASK_DATAENDIE  P    SDIO_MASK_STBITERRIE  P    SDIO_MASK_DBCKENDIE  P    SDIO_MASK_CMDACTIE T P    SDIO_MASK_TXACTIE ~ P    SDIO_MASK_RXACTIE  P    SDIO_MASK_TXFIFOHEIE  P    SDIO_MASK_RXFIFOHFIE  P    SDIO_MASK_TXFIFOFIE  P    SDIO_MASK_RXFIFOFIE  P    SDIO_MASK_TXFIFOEIE  P    SDIO_MASK_RXFIFOEIE  P    SDIO_MASK_TXDAVLIE - P    SDIO_MASK_RXDAVLIE / P    SDIO_MASK_SDIOITIE 4 P    SDIO_MASK_CEATAENDIE  P    SDIO_FIFOCNT_FIFOCOUNT  P    SDIO_FIFO_FIFODATA X P    USB_EP0R_EA p P    USB_EP0R_STAT_TX  P    USB_EP0R_STAT_TX_0  P    USB_EP0R_STAT_TX_1  P    USB_EP0R_DTOG_TX  P    USB_EP0R_CTR_TX  P    USB_EP0R_EP_KIND  P    USB_EP0R_EP_TYPE  P    USB_EP0R_EP_TYPE_0 # P    USB_EP0R_EP_TYPE_1 " P    USB_EP0R_SETUP _ P    USB_EP0R_STAT_RX  P    USB_EP0R_STAT_RX_0  P    USB_EP0R_STAT_RX_1  P    USB_EP0R_DTOG_RX  P    USB_EP0R_CTR_RX  P    USB_EP1R_EA o P    USB_EP1R_STAT_TX  P    USB_EP1R_STAT_TX_0  P    USB_EP1R_STAT_TX_1  P    USB_EP1R_DTOG_TX  P    USB_EP1R_CTR_TX  P    USB_EP1R_EP_KIND  P    USB_EP1R_EP_TYPE  P    USB_EP1R_EP_TYPE_0 " P    USB_EP1R_EP_TYPE_1 ! P    USB_EP1R_SETUP ^ P    USB_EP1R_STAT_RX  P    USB_EP1R_STAT_RX_0  P    USB_EP1R_STAT_RX_1  P    USB_EP1R_DTOG_RX  P    USB_EP1R_CTR_RX  P    USB_EP2R_EA n P    USB_EP2R_STAT_TX  P    USB_EP2R_STAT_TX_0  P    USB_EP2R_STAT_TX_1  P    USB_EP2R_DTOG_TX  P    USB_EP2R_CTR_TX  P    USB_EP2R_EP_KIND  P    USB_EP2R_EP_TYPE  P    USB_EP2R_EP_TYPE_0 ! P    USB_EP2R_EP_TYPE_1   P    USB_EP2R_SETUP ] P    USB_EP2R_STAT_RX  P    USB_EP2R_STAT_RX_0  P    USB_EP2R_STAT_RX_1  P    USB_EP2R_DTOG_RX  P    USB_EP2R_CTR_RX  P    USB_EP3R_EA m P    USB_EP3R_STAT_TX  P    USB_EP3R_STAT_TX_0  P    USB_EP3R_STAT_TX_1  P    USB_EP3R_DTOG_TX  P    USB_EP3R_CTR_TX  P    USB_EP3R_EP_KIND  P    USB_EP3R_EP_TYPE  P    USB_EP3R_EP_TYPE_0   P    USB_EP3R_EP_TYPE_1  P    USB_EP3R_SETUP \ P    USB_EP3R_STAT_RX  P    USB_EP3R_STAT_RX_0  P    USB_EP3R_STAT_RX_1  P    USB_EP3R_DTOG_RX  P    USB_EP3R_CTR_RX  P    USB_EP4R_EA l P    USB_EP4R_STAT_TX  P    USB_EP4R_STAT_TX_0  P    USB_EP4R_STAT_TX_1  P    USB_EP4R_DTOG_TX  P    USB_EP4R_CTR_TX  P    USB_EP4R_EP_KIND  P    USB_EP4R_EP_TYPE  P    USB_EP4R_EP_TYPE_0  P    USB_EP4R_EP_TYPE_1  P    USB_EP4R_SETUP [ P    USB_EP4R_STAT_RX  P    USB_EP4R_STAT_RX_0  P    USB_EP4R_STAT_RX_1  P    USB_EP4R_DTOG_RX  P    USB_EP4R_CTR_RX  P    USB_EP5R_EA k P    USB_EP5R_STAT_TX  P    USB_EP5R_STAT_TX_0  P    USB_EP5R_STAT_TX_1  P    USB_EP5R_DTOG_TX  P    USB_EP5R_CTR_TX  P    USB_EP5R_EP_KIND  P    USB_EP5R_EP_TYPE  P    USB_EP5R_EP_TYPE_0  P    USB_EP5R_EP_TYPE_1  P    USB_EP5R_SETUP Z P    USB_EP5R_STAT_RX  P    USB_EP5R_STAT_RX_0  P    USB_EP5R_STAT_RX_1  P    USB_EP5R_DTOG_RX  P    USB_EP5R_CTR_RX  P    USB_EP6R_EA j P    USB_EP6R_STAT_TX  P    USB_EP6R_STAT_TX_0  P    USB_EP6R_STAT_TX_1  P    USB_EP6R_DTOG_TX  P    USB_EP6R_CTR_TX  P    USB_EP6R_EP_KIND  P    USB_EP6R_EP_TYPE  P    USB_EP6R_EP_TYPE_0  P    USB_EP6R_EP_TYPE_1  P    USB_EP6R_SETUP Y P    USB_EP6R_STAT_RX  P    USB_EP6R_STAT_RX_0  P    USB_EP6R_STAT_RX_1  P    USB_EP6R_DTOG_RX  P    USB_EP6R_CTR_RX  P    USB_EP7R_EA i P    USB_EP7R_STAT_TX  P    USB_EP7R_STAT_TX_0  P    USB_EP7R_STAT_TX_1 
 P    USB_EP7R_DTOG_TX  P    USB_EP7R_CTR_TX  P    USB_EP7R_EP_KIND  P    USB_EP7R_EP_TYPE  P    USB_EP7R_EP_TYPE_0  P    USB_EP7R_EP_TYPE_1  P    USB_EP7R_SETUP X P    USB_EP7R_STAT_RX  P    USB_EP7R_STAT_RX_0  P    USB_EP7R_STAT_RX_1  P    USB_EP7R_DTOG_RX  P    USB_EP7R_CTR_RX  P    USB_CNTR_FRES  P    USB_CNTR_PDWN  P    USB_CNTR_LP_MODE  P    USB_CNTR_FSUSP ? P    USB_CNTR_RESUME  P    USB_CNTR_ESOFM V P    USB_CNTR_SOFM  P    USB_CNTR_RESETM  P    USB_CNTR_SUSPM 8 P    USB_CNTR_WKUPM < P    USB_CNTR_ERRM  P    USB_CNTR_PMAOVRM  P    USB_CNTR_CTRM  P    USB_ISTR_EP_ID D P    USB_ISTR_DIR  P    USB_ISTR_ESOF  P    USB_ISTR_SOF  P    USB_ISTR_RESET B P    USB_ISTR_SUSP | P    USB_ISTR_WKUP  P    USB_ISTR_ERR  P    USB_ISTR_PMAOVR  P    USB_ISTR_CTR  P    USB_FNR_FN  P    USB_FNR_LSOF  P    USB_FNR_LCK M P    USB_FNR_RXDM  P    USB_FNR_RXDP  P    USB_DADDR_ADD  P    USB_DADDR_ADD0  P    USB_DADDR_ADD1  P    USB_DADDR_ADD2  P    USB_DADDR_ADD3  P    USB_DADDR_ADD4  P    USB_DADDR_ADD5  P    USB_DADDR_ADD6  P    USB_DADDR_EF ! P    USB_BTABLE_BTABLE  P    USB_ADDR0_TX_ADDR0_TX M P    USB_ADDR1_TX_ADDR1_TX K P    USB_ADDR2_TX_ADDR2_TX I P    USB_ADDR3_TX_ADDR3_TX G P    USB_ADDR4_TX_ADDR4_TX E P    USB_ADDR5_TX_ADDR5_TX C P    USB_ADDR6_TX_ADDR6_TX A P    USB_ADDR7_TX_ADDR7_TX ?  P    USB_COUNT0_TX_COUNT0_TX m  P    USB_COUNT1_TX_COUNT1_TX k  P    USB_COUNT2_TX_COUNT2_TX i  P    USB_COUNT3_TX_COUNT3_TX g  P    USB_COUNT4_TX_COUNT4_TX e  P    USB_COUNT5_TX_COUNT5_TX c  P    USB_COUNT6_TX_COUNT6_TX a  P    USB_COUNT7_TX_COUNT7_TX _$ P    USB_COUNT0_TX_0_COUNT0_TX_0 G$ P    USB_COUNT0_TX_1_COUNT0_TX_1 E$ P    USB_COUNT1_TX_0_COUNT1_TX_0 E$ P    USB_COUNT1_TX_1_COUNT1_TX_1 C$ P    USB_COUNT2_TX_0_COUNT2_TX_0 C$ P    USB_COUNT2_TX_1_COUNT2_TX_1 A$ P    USB_COUNT3_TX_0_COUNT3_TX_0 A$ P    USB_COUNT3_TX_1_COUNT3_TX_1 ?$ P    USB_COUNT4_TX_0_COUNT4_TX_0 ?$ P    USB_COUNT4_TX_1_COUNT4_TX_1 =$ P    USB_COUNT5_TX_0_COUNT5_TX_0 =$ P    USB_COUNT5_TX_1_COUNT5_TX_1 ;$ P    USB_COUNT6_TX_0_COUNT6_TX_0 ;$ P    USB_COUNT6_TX_1_COUNT6_TX_1 9$ P    USB_COUNT7_TX_0_COUNT7_TX_0 9$ P    USB_COUNT7_TX_1_COUNT7_TX_1 7 P    USB_ADDR0_RX_ADDR0_RX Q P    USB_ADDR1_RX_ADDR1_RX O P    USB_ADDR2_RX_ADDR2_RX M P    USB_ADDR3_RX_ADDR3_RX K P    USB_ADDR4_RX_ADDR4_RX I P    USB_ADDR5_RX_ADDR5_RX G P    USB_ADDR6_RX_ADDR6_RX E P    USB_ADDR7_RX_ADDR7_RX C  P    USB_COUNT0_RX_COUNT0_RX q  P    USB_COUNT0_RX_NUM_BLOCK y" P    USB_COUNT0_RX_NUM_BLOCK_0 " P    USB_COUNT0_RX_NUM_BLOCK_1 " P    USB_COUNT0_RX_NUM_BLOCK_2 " P    USB_COUNT0_RX_NUM_BLOCK_3 " P    USB_COUNT0_RX_NUM_BLOCK_4  P    USB_COUNT0_RX_BLSIZE p  P    USB_COUNT1_RX_COUNT1_RX o  P    USB_COUNT1_RX_NUM_BLOCK x" P    USB_COUNT1_RX_NUM_BLOCK_0 " P    USB_COUNT1_RX_NUM_BLOCK_1 " P    USB_COUNT1_RX_NUM_BLOCK_2 " P    USB_COUNT1_RX_NUM_BLOCK_3 " P    USB_COUNT1_RX_NUM_BLOCK_4  P    USB_COUNT1_RX_BLSIZE o  P    USB_COUNT2_RX_COUNT2_RX m  P    USB_COUNT2_RX_NUM_BLOCK w" P    USB_COUNT2_RX_NUM_BLOCK_0 " P    USB_COUNT2_RX_NUM_BLOCK_1 " P    USB_COUNT2_RX_NUM_BLOCK_2 " P    USB_COUNT2_RX_NUM_BLOCK_3 " P    USB_COUNT2_RX_NUM_BLOCK_4  P    USB_COUNT2_RX_BLSIZE n  P    USB_COUNT3_RX_COUNT3_RX k  P    USB_COUNT3_RX_NUM_BLOCK v" P    USB_COUNT3_RX_NUM_BLOCK_0 " P    USB_COUNT3_RX_NUM_BLOCK_1 " P    USB_COUNT3_RX_NUM_BLOCK_2 " P    USB_COUNT3_RX_NUM_BLOCK_3 " P    USB_COUNT3_RX_NUM_BLOCK_4  P    USB_COUNT3_RX_BLSIZE m  P    USB_COUNT4_RX_COUNT4_RX i  P    USB_COUNT4_RX_NUM_BLOCK u" P    USB_COUNT4_RX_NUM_BLOCK_0 " P    USB_COUNT4_RX_NUM_BLOCK_1 " P    USB_COUNT4_RX_NUM_BLOCK_2 " P    USB_COUNT4_RX_NUM_BLOCK_3 " P    USB_COUNT4_RX_NUM_BLOCK_4  P    USB_COUNT4_RX_BLSIZE l  P    USB_COUNT5_RX_COUNT5_RX g  P    USB_COUNT5_RX_NUM_BLOCK t" P    USB_COUNT5_RX_NUM_BLOCK_0 " P    USB_COUNT5_RX_NUM_BLOCK_1 " P    USB_COUNT5_RX_NUM_BLOCK_2 " P    USB_COUNT5_RX_NUM_BLOCK_3 " P    USB_COUNT5_RX_NUM_BLOCK_4  P    USB_COUNT5_RX_BLSIZE k  P    USB_COUNT6_RX_COUNT6_RX e  P    USB_COUNT6_RX_NUM_BLOCK s" P    USB_COUNT6_RX_NUM_BLOCK_0 " P    USB_COUNT6_RX_NUM_BLOCK_1 " P    USB_COUNT6_RX_NUM_BLOCK_2 " P    USB_COUNT6_RX_NUM_BLOCK_3 " P    USB_COUNT6_RX_NUM_BLOCK_4  P    USB_COUNT6_RX_BLSIZE j  P    USB_COUNT7_RX_COUNT7_RX c  P    USB_COUNT7_RX_NUM_BLOCK r" P    USB_COUNT7_RX_NUM_BLOCK_0 " P    USB_COUNT7_RX_NUM_BLOCK_1 " P    USB_COUNT7_RX_NUM_BLOCK_2 " P    USB_COUNT7_RX_NUM_BLOCK_3 " P    USB_COUNT7_RX_NUM_BLOCK_4  P    USB_COUNT7_RX_BLSIZE i$ P    USB_COUNT0_RX_0_COUNT0_RX_0 K$ P    USB_COUNT0_RX_0_NUM_BLOCK_0 S& P    USB_COUNT0_RX_0_NUM_BLOCK_0_0 & P    USB_COUNT0_RX_0_NUM_BLOCK_0_1 & P    USB_COUNT0_RX_0_NUM_BLOCK_0_2 & P    USB_COUNT0_RX_0_NUM_BLOCK_0_3 & P    USB_COUNT0_RX_0_NUM_BLOCK_0_4 ! P    USB_COUNT0_RX_0_BLSIZE_0 J$ P    USB_COUNT0_RX_1_COUNT0_RX_1 I$ P    USB_COUNT0_RX_1_NUM_BLOCK_1 Q& P    USB_COUNT0_RX_1_NUM_BLOCK_1_0 & P    USB_COUNT0_RX_1_NUM_BLOCK_1_1 & P    USB_COUNT0_RX_1_NUM_BLOCK_1_2 & P    USB_COUNT0_RX_1_NUM_BLOCK_1_3 & P    USB_COUNT0_RX_1_NUM_BLOCK_1_4 ! P    USB_COUNT0_RX_1_BLSIZE_1 H$ P    USB_COUNT1_RX_0_COUNT1_RX_0 I$ P    USB_COUNT1_RX_0_NUM_BLOCK_0 R& P    USB_COUNT1_RX_0_NUM_BLOCK_0_0 & P    USB_COUNT1_RX_0_NUM_BLOCK_0_1 & P    USB_COUNT1_RX_0_NUM_BLOCK_0_2 & P    USB_COUNT1_RX_0_NUM_BLOCK_0_3 & P    USB_COUNT1_RX_0_NUM_BLOCK_0_4 ! P    USB_COUNT1_RX_0_BLSIZE_0 I$ P    USB_COUNT1_RX_1_COUNT1_RX_1 G$ P    USB_COUNT1_RX_1_NUM_BLOCK_1 P& P    USB_COUNT1_RX_1_NUM_BLOCK_1_0 & P    USB_COUNT1_RX_1_NUM_BLOCK_1_1 & P    USB_COUNT1_RX_1_NUM_BLOCK_1_2 & P    USB_COUNT1_RX_1_NUM_BLOCK_1_3 & P    USB_COUNT1_RX_1_NUM_BLOCK_1_4 ! P    USB_COUNT1_RX_1_BLSIZE_1 G$ P    USB_COUNT2_RX_0_COUNT2_RX_0 G$ P    USB_COUNT2_RX_0_NUM_BLOCK_0 Q& P    USB_COUNT2_RX_0_NUM_BLOCK_0_0 & P    USB_COUNT2_RX_0_NUM_BLOCK_0_1 & P    USB_COUNT2_RX_0_NUM_BLOCK_0_2 & P    USB_COUNT2_RX_0_NUM_BLOCK_0_3 & P    USB_COUNT2_RX_0_NUM_BLOCK_0_4 ! P    USB_COUNT2_RX_0_BLSIZE_0 H$ P    USB_COUNT2_RX_1_COUNT2_RX_1 E$ P    USB_COUNT2_RX_1_NUM_BLOCK_1 O& P    USB_COUNT2_RX_1_NUM_BLOCK_1_0 & P    USB_COUNT2_RX_1_NUM_BLOCK_1_1 & P    USB_COUNT2_RX_1_NUM_BLOCK_1_2 & P    USB_COUNT2_RX_1_NUM_BLOCK_1_3 & P    USB_COUNT2_RX_1_NUM_BLOCK_1_4 ! P    USB_COUNT2_RX_1_BLSIZE_1 F$ P    USB_COUNT3_RX_0_COUNT3_RX_0 E$ P    USB_COUNT3_RX_0_NUM_BLOCK_0 P& P    USB_COUNT3_RX_0_NUM_BLOCK_0_0 & P    USB_COUNT3_RX_0_NUM_BLOCK_0_1 & P    USB_COUNT3_RX_0_NUM_BLOCK_0_2 & P    USB_COUNT3_RX_0_NUM_BLOCK_0_3 & P    USB_COUNT3_RX_0_NUM_BLOCK_0_4 ! P    USB_COUNT3_RX_0_BLSIZE_0 G$ P    USB_COUNT3_RX_1_COUNT3_RX_1 C$ P    USB_COUNT3_RX_1_NUM_BLOCK_1 N& P    USB_COUNT3_RX_1_NUM_BLOCK_1_0 & P    USB_COUNT3_RX_1_NUM_BLOCK_1_1 & P    USB_COUNT3_RX_1_NUM_BLOCK_1_2 & P    USB_COUNT3_RX_1_NUM_BLOCK_1_3 & P    USB_COUNT3_RX_1_NUM_BLOCK_1_4 ! P    USB_COUNT3_RX_1_BLSIZE_1 E$ P    USB_COUNT4_RX_0_COUNT4_RX_0 C$ P    USB_COUNT4_RX_0_NUM_BLOCK_0 O& P    USB_COUNT4_RX_0_NUM_BLOCK_0_0 & P    USB_COUNT4_RX_0_NUM_BLOCK_0_1 & P    USB_COUNT4_RX_0_NUM_BLOCK_0_2 & P    USB_COUNT4_RX_0_NUM_BLOCK_0_3 & P    USB_COUNT4_RX_0_NUM_BLOCK_0_4 ! P    USB_COUNT4_RX_0_BLSIZE_0 F$ P    USB_COUNT4_RX_1_COUNT4_RX_1 A$ P    USB_COUNT4_RX_1_NUM_BLOCK_1 M& P    USB_COUNT4_RX_1_NUM_BLOCK_1_0 & P    USB_COUNT4_RX_1_NUM_BLOCK_1_1 & P    USB_COUNT4_RX_1_NUM_BLOCK_1_2 & P    USB_COUNT4_RX_1_NUM_BLOCK_1_3 & P    USB_COUNT4_RX_1_NUM_BLOCK_1_4 ! P    USB_COUNT4_RX_1_BLSIZE_1 D$ P    USB_COUNT5_RX_0_COUNT5_RX_0 A$ P    USB_COUNT5_RX_0_NUM_BLOCK_0 N& P    USB_COUNT5_RX_0_NUM_BLOCK_0_0 & P    USB_COUNT5_RX_0_NUM_BLOCK_0_1 & P    USB_COUNT5_RX_0_NUM_BLOCK_0_2 & P    USB_COUNT5_RX_0_NUM_BLOCK_0_3 & P    USB_COUNT5_RX_0_NUM_BLOCK_0_4 ! P    USB_COUNT5_RX_0_BLSIZE_0 E$ P    USB_COUNT5_RX_1_COUNT5_RX_1 ?$ P    USB_COUNT5_RX_1_NUM_BLOCK_1 L& P    USB_COUNT5_RX_1_NUM_BLOCK_1_0 & P    USB_COUNT5_RX_1_NUM_BLOCK_1_1 & P    USB_COUNT5_RX_1_NUM_BLOCK_1_2 & P    USB_COUNT5_RX_1_NUM_BLOCK_1_3 & P    USB_COUNT5_RX_1_NUM_BLOCK_1_4 ! P    USB_COUNT5_RX_1_BLSIZE_1 C$ P    USB_COUNT6_RX_0_COUNT6_RX_0 ?$ P    USB_COUNT6_RX_0_NUM_BLOCK_0 M& P    USB_COUNT6_RX_0_NUM_BLOCK_0_0 & P    USB_COUNT6_RX_0_NUM_BLOCK_0_1 & P    USB_COUNT6_RX_0_NUM_BLOCK_0_2 & P    USB_COUNT6_RX_0_NUM_BLOCK_0_3 & P    USB_COUNT6_RX_0_NUM_BLOCK_0_4 ! P    USB_COUNT6_RX_0_BLSIZE_0 D$ P    USB_COUNT6_RX_1_COUNT6_RX_1 =$ P    USB_COUNT6_RX_1_NUM_BLOCK_1 K& P    USB_COUNT6_RX_1_NUM_BLOCK_1_0 & P    USB_COUNT6_RX_1_NUM_BLOCK_1_1 & P    USB_COUNT6_RX_1_NUM_BLOCK_1_2 & P    USB_COUNT6_RX_1_NUM_BLOCK_1_3 & P    USB_COUNT6_RX_1_NUM_BLOCK_1_4 ! P    USB_COUNT6_RX_1_BLSIZE_1 B$ P    USB_COUNT7_RX_0_COUNT7_RX_0 =$ P    USB_COUNT7_RX_0_NUM_BLOCK_0 L& P    USB_COUNT7_RX_0_NUM_BLOCK_0_0 & P    USB_COUNT7_RX_0_NUM_BLOCK_0_1 & P    USB_COUNT7_RX_0_NUM_BLOCK_0_2 & P    USB_COUNT7_RX_0_NUM_BLOCK_0_3 & P    USB_COUNT7_RX_0_NUM_BLOCK_0_4 ! P    USB_COUNT7_RX_0_BLSIZE_0 C$ P    USB_COUNT7_RX_1_COUNT7_RX_1 ;$ P    USB_COUNT7_RX_1_NUM_BLOCK_1 J& P    USB_COUNT7_RX_1_NUM_BLOCK_1_0 & P    USB_COUNT7_RX_1_NUM_BLOCK_1_1 & P    USB_COUNT7_RX_1_NUM_BLOCK_1_2 & P    USB_COUNT7_RX_1_NUM_BLOCK_1_3 & P    USB_COUNT7_RX_1_NUM_BLOCK_1_4 ! P    USB_COUNT7_RX_1_BLSIZE_1 A P    CAN_MCR_INRQ  P    CAN_MCR_SLEEP  P    CAN_MCR_TXFP  P    CAN_MCR_RFLM  P    CAN_MCR_NART  P    CAN_MCR_AWUM  P    CAN_MCR_ABOM " P    CAN_MCR_TTCM 	 P    CAN_MCR_RESET  P    CAN_MSR_INAK  P    CAN_MSR_SLAK  P    CAN_MSR_ERRI  P    CAN_MSR_WKUI  P    CAN_MSR_SLAKI  P    CAN_MSR_TXM : P    CAN_MSR_RXM < P    CAN_MSR_SAMP   P    CAN_MSR_RX  P    CAN_TSR_RQCP0  P    CAN_TSR_TXOK0  P    CAN_TSR_ALST0  P    CAN_TSR_TERR0  P    CAN_TSR_ABRQ0  P    CAN_TSR_RQCP1  P    CAN_TSR_TXOK1  P    CAN_TSR_ALST1  P    CAN_TSR_TERR1  P    CAN_TSR_ABRQ1  P    CAN_TSR_RQCP2  P    CAN_TSR_TXOK2  P    CAN_TSR_ALST2  P    CAN_TSR_TERR2  P    CAN_TSR_ABRQ2  P    CAN_TSR_CODE  P    CAN_TSR_TME F P    CAN_TSR_TME0  P    CAN_TSR_TME1  P    CAN_TSR_TME2  P    CAN_TSR_LOW : P    CAN_TSR_LOW0  P    CAN_TSR_LOW1  P    CAN_TSR_LOW2  P    CAN_RF0R_FMP0  P    CAN_RF0R_FULL0  P    CAN_RF0R_FOVR0  P    CAN_RF0R_RFOM0  P    CAN_RF1R_FMP1  P    CAN_RF1R_FULL1  P    CAN_RF1R_FOVR1  P    CAN_RF1R_RFOM1  P    CAN_IER_TMEIE  P    CAN_IER_FMPIE0  P    CAN_IER_FFIE0  P    CAN_IER_FOVIE0  P    CAN_IER_FMPIE1  P    CAN_IER_FFIE1  P    CAN_IER_FOVIE1  P    CAN_IER_EWGIE  P    CAN_IER_EPVIE  P    CAN_IER_BOFIE  P    CAN_IER_LECIE  P    CAN_IER_ERRIE  P    CAN_IER_WKUIE  P    CAN_IER_SLKIE  P    CAN_ESR_EWGF  P    CAN_ESR_EPVF  P    CAN_ESR_BOFF  P    CAN_ESR_LEC g P    CAN_ESR_LEC_0  P    CAN_ESR_LEC_1  P    CAN_ESR_LEC_2  P    CAN_ESR_TEC _ P    CAN_ESR_REC a P    CAN_BTR_BRP Y P    CAN_BTR_TS1 e P    CAN_BTR_TS2 d P    CAN_BTR_SJW I P    CAN_BTR_LBKM  P    CAN_BTR_SILM  P    CAN_TI0R_TXRQ  P    CAN_TI0R_RTR  P    CAN_TI0R_IDE 2 P    CAN_TI0R_EXID  P    CAN_TI0R_STID  P    CAN_TDT0R_DLC  P    CAN_TDT0R_TGT  P    CAN_TDT0R_TIME  P    CAN_TDL0R_DATA0 m P    CAN_TDL0R_DATA1 l P    CAN_TDL0R_DATA2 k P    CAN_TDL0R_DATA3 j P    CAN_TDH0R_DATA4 m P    CAN_TDH0R_DATA5 l P    CAN_TDH0R_DATA6 k P    CAN_TDH0R_DATA7 j P    CAN_TI1R_TXRQ  P    CAN_TI1R_RTR  P    CAN_TI1R_IDE 1 P    CAN_TI1R_EXID  P    CAN_TI1R_STID  P    CAN_TDT1R_DLC  P    CAN_TDT1R_TGT  P    CAN_TDT1R_TIME  P    CAN_TDL1R_DATA0 l P    CAN_TDL1R_DATA1 k P    CAN_TDL1R_DATA2 j P    CAN_TDL1R_DATA3 i P    CAN_TDH1R_DATA4 l P    CAN_TDH1R_DATA5 k P    CAN_TDH1R_DATA6 j P    CAN_TDH1R_DATA7 i P    CAN_TI2R_TXRQ  P    CAN_TI2R_RTR 
 P    CAN_TI2R_IDE 0 P    CAN_TI2R_EXID  P    CAN_TI2R_STID  P    CAN_TDT2R_DLC  P    CAN_TDT2R_TGT  P    CAN_TDT2R_TIME  P    CAN_TDL2R_DATA0 k P    CAN_TDL2R_DATA1 j P    CAN_TDL2R_DATA2 i P    CAN_TDL2R_DATA3 h P    CAN_TDH2R_DATA4 k P    CAN_TDH2R_DATA5 j P    CAN_TDH2R_DATA6 i P    CAN_TDH2R_DATA7 h P    CAN_RI0R_RTR  P    CAN_RI0R_IDE 4 P    CAN_RI0R_EXID  P    CAN_RI0R_STID  P    CAN_RDT0R_DLC  P    CAN_RDT0R_FMI  P    CAN_RDT0R_TIME  P    CAN_RDL0R_DATA0 o P    CAN_RDL0R_DATA1 n P    CAN_RDL0R_DATA2 m P    CAN_RDL0R_DATA3 l P    CAN_RDH0R_DATA4 o P    CAN_RDH0R_DATA5 n P    CAN_RDH0R_DATA6 m P    CAN_RDH0R_DATA7 l P    CAN_RI1R_RTR  P    CAN_RI1R_IDE 3 P    CAN_RI1R_EXID  P    CAN_RI1R_STID  P    CAN_RDT1R_DLC  P    CAN_RDT1R_FMI  P    CAN_RDT1R_TIME  P    CAN_RDL1R_DATA0 n P    CAN_RDL1R_DATA1 m P    CAN_RDL1R_DATA2 l P    CAN_RDL1R_DATA3 k P    CAN_RDH1R_DATA4 n P    CAN_RDH1R_DATA5 m P    CAN_RDH1R_DATA6 l P    CAN_RDH1R_DATA7 k P    CAN_FMR_FINIT  P    CAN_FM1R_FBM 8 P    CAN_FM1R_FBM0  P    CAN_FM1R_FBM1  P    CAN_FM1R_FBM2  P    CAN_FM1R_FBM3  P    CAN_FM1R_FBM4  P    CAN_FM1R_FBM5  P    CAN_FM1R_FBM6   P    CAN_FM1R_FBM7  P    CAN_FM1R_FBM8  P    CAN_FM1R_FBM9  P    CAN_FM1R_FBM10  P    CAN_FM1R_FBM11  P    CAN_FM1R_FBM12  P    CAN_FM1R_FBM13  P    CAN_FS1R_FSC + P    CAN_FS1R_FSC0  P    CAN_FS1R_FSC1  P    CAN_FS1R_FSC2  P    CAN_FS1R_FSC3  P    CAN_FS1R_FSC4  P    CAN_FS1R_FSC5  P    CAN_FS1R_FSC6  P    CAN_FS1R_FSC7  P    CAN_FS1R_FSC8  P    CAN_FS1R_FSC9  P    CAN_FS1R_FSC10  P    CAN_FS1R_FSC11  P    CAN_FS1R_FSC12  P    CAN_FS1R_FSC13  P    CAN_FFA1R_FFA  P    CAN_FFA1R_FFA0  P    CAN_FFA1R_FFA1  P    CAN_FFA1R_FFA2  P    CAN_FFA1R_FFA3  P    CAN_FFA1R_FFA4  P    CAN_FFA1R_FFA5  P    CAN_FFA1R_FFA6  P    CAN_FFA1R_FFA7  P    CAN_FFA1R_FFA8  P    CAN_FFA1R_FFA9  P    CAN_FFA1R_FFA10  P    CAN_FFA1R_FFA11  P    CAN_FFA1R_FFA12  P    CAN_FFA1R_FFA13  P    CAN_FA1R_FACT  P    CAN_FA1R_FACT0  P    CAN_FA1R_FACT1  P    CAN_FA1R_FACT2  P    CAN_FA1R_FACT3  P    CAN_FA1R_FACT4  P    CAN_FA1R_FACT5  P    CAN_FA1R_FACT6  P    CAN_FA1R_FACT7  P    CAN_FA1R_FACT8  P    CAN_FA1R_FACT9  P    CAN_FA1R_FACT10  P    CAN_FA1R_FACT11  P    CAN_FA1R_FACT12  P    CAN_FA1R_FACT13  P    CAN_F0R1_FB0 r P    CAN_F0R1_FB1 q P    CAN_F0R1_FB2 p P    CAN_F0R1_FB3 o P    CAN_F0R1_FB4 n P    CAN_F0R1_FB5 m P    CAN_F0R1_FB6 l P    CAN_F0R1_FB7 k P    CAN_F0R1_FB8 j P    CAN_F0R1_FB9 i P    CAN_F0R1_FB10 ? P    CAN_F0R1_FB11 > P    CAN_F0R1_FB12 = P    CAN_F0R1_FB13 < P    CAN_F0R1_FB14 ; P    CAN_F0R1_FB15 : P    CAN_F0R1_FB16 9 P    CAN_F0R1_FB17 8 P    CAN_F0R1_FB18 7 P    CAN_F0R1_FB19 6 P    CAN_F0R1_FB20 > P    CAN_F0R1_FB21 = P    CAN_F0R1_FB22 < P    CAN_F0R1_FB23 ; P    CAN_F0R1_FB24 : P    CAN_F0R1_FB25 9 P    CAN_F0R1_FB26 8 P    CAN_F0R1_FB27 7 P    CAN_F0R1_FB28 6 P    CAN_F0R1_FB29 5 P    CAN_F0R1_FB30 = P    CAN_F0R1_FB31 < P    CAN_F1R1_FB0 q P    CAN_F1R1_FB1 p P    CAN_F1R1_FB2 o P    CAN_F1R1_FB3 n P    CAN_F1R1_FB4 m P    CAN_F1R1_FB5 l P    CAN_F1R1_FB6 k P    CAN_F1R1_FB7 j P    CAN_F1R1_FB8 i P    CAN_F1R1_FB9 h P    CAN_F1R1_FB10 > P    CAN_F1R1_FB11 = P    CAN_F1R1_FB12 < P    CAN_F1R1_FB13 ; P    CAN_F1R1_FB14 : P    CAN_F1R1_FB15 9 P    CAN_F1R1_FB16 8 P    CAN_F1R1_FB17 7 P    CAN_F1R1_FB18 6 P    CAN_F1R1_FB19 5 P    CAN_F1R1_FB20 = P    CAN_F1R1_FB21 < P    CAN_F1R1_FB22 ; P    CAN_F1R1_FB23 : P    CAN_F1R1_FB24 9 P    CAN_F1R1_FB25 8 P    CAN_F1R1_FB26 7 P    CAN_F1R1_FB27 6 P    CAN_F1R1_FB28 5 P    CAN_F1R1_FB29 4 P    CAN_F1R1_FB30 < P    CAN_F1R1_FB31 ; P    CAN_F2R1_FB0 p P    CAN_F2R1_FB1 o P    CAN_F2R1_FB2 n P    CAN_F2R1_FB3 m P    CAN_F2R1_FB4 l P    CAN_F2R1_FB5 k P    CAN_F2R1_FB6 j P    CAN_F2R1_FB7 i P    CAN_F2R1_FB8 h P    CAN_F2R1_FB9 g P    CAN_F2R1_FB10 = P    CAN_F2R1_FB11 < P    CAN_F2R1_FB12 ; P    CAN_F2R1_FB13 : P    CAN_F2R1_FB14 9 P    CAN_F2R1_FB15 8 P    CAN_F2R1_FB16 7 P    CAN_F2R1_FB17 6 P    CAN_F2R1_FB18 5 P    CAN_F2R1_FB19 4 P    CAN_F2R1_FB20 < P    CAN_F2R1_FB21 ; P    CAN_F2R1_FB22 : P    CAN_F2R1_FB23 9 P    CAN_F2R1_FB24 8 P    CAN_F2R1_FB25 7 P    CAN_F2R1_FB26 6 P    CAN_F2R1_FB27 5 P    CAN_F2R1_FB28 4 P    CAN_F2R1_FB29 3 P    CAN_F2R1_FB30 ; P    CAN_F2R1_FB31 : P    CAN_F3R1_FB0 o P    CAN_F3R1_FB1 n P    CAN_F3R1_FB2 m P    CAN_F3R1_FB3 l P    CAN_F3R1_FB4 k P    CAN_F3R1_FB5 j P    CAN_F3R1_FB6 i P    CAN_F3R1_FB7 h P    CAN_F3R1_FB8 g P    CAN_F3R1_FB9 f P    CAN_F3R1_FB10 < P    CAN_F3R1_FB11 ; P    CAN_F3R1_FB12 : P    CAN_F3R1_FB13 9 P    CAN_F3R1_FB14 8 P    CAN_F3R1_FB15 7 P    CAN_F3R1_FB16 6 P    CAN_F3R1_FB17 5 P    CAN_F3R1_FB18 4 P    CAN_F3R1_FB19 3 P    CAN_F3R1_FB20 ; P    CAN_F3R1_FB21 : P    CAN_F3R1_FB22 9 P    CAN_F3R1_FB23 8 P    CAN_F3R1_FB24 7 P    CAN_F3R1_FB25 6 P    CAN_F3R1_FB26 5 P    CAN_F3R1_FB27 4 P    CAN_F3R1_FB28 3 P    CAN_F3R1_FB29 2 P    CAN_F3R1_FB30 : P    CAN_F3R1_FB31 9 P    CAN_F4R1_FB0 n P    CAN_F4R1_FB1 m P    CAN_F4R1_FB2 l P    CAN_F4R1_FB3 k P    CAN_F4R1_FB4 j P    CAN_F4R1_FB5 i P    CAN_F4R1_FB6 h P    CAN_F4R1_FB7 g P    CAN_F4R1_FB8 f P    CAN_F4R1_FB9 e P    CAN_F4R1_FB10 ; P    CAN_F4R1_FB11 : P    CAN_F4R1_FB12 9 P    CAN_F4R1_FB13 8 P    CAN_F4R1_FB14 7 P    CAN_F4R1_FB15 6 P    CAN_F4R1_FB16 5 P    CAN_F4R1_FB17 4 P    CAN_F4R1_FB18 3 P    CAN_F4R1_FB19 2 P    CAN_F4R1_FB20 : P    CAN_F4R1_FB21 9 P    CAN_F4R1_FB22 8 P    CAN_F4R1_FB23 7 P    CAN_F4R1_FB24 6 P    CAN_F4R1_FB25 5 P    CAN_F4R1_FB26 4 P    CAN_F4R1_FB27 3 P    CAN_F4R1_FB28 2 P    CAN_F4R1_FB29 1 P    CAN_F4R1_FB30 9 P    CAN_F4R1_FB31 8 P    CAN_F5R1_FB0 m P    CAN_F5R1_FB1 l P    CAN_F5R1_FB2 k P    CAN_F5R1_FB3 j P    CAN_F5R1_FB4 i P    CAN_F5R1_FB5 h P    CAN_F5R1_FB6 g P    CAN_F5R1_FB7 f P    CAN_F5R1_FB8 e P    CAN_F5R1_FB9 d P    CAN_F5R1_FB10 : P    CAN_F5R1_FB11 9 P    CAN_F5R1_FB12 8 P    CAN_F5R1_FB13 7 P    CAN_F5R1_FB14 6 P    CAN_F5R1_FB15 5 P    CAN_F5R1_FB16 4 P    CAN_F5R1_FB17 3 P    CAN_F5R1_FB18 2 P    CAN_F5R1_FB19 1 P    CAN_F5R1_FB20 9 P    CAN_F5R1_FB21 8 P    CAN_F5R1_FB22 7 P    CAN_F5R1_FB23 6 P    CAN_F5R1_FB24 5 P    CAN_F5R1_FB25 4 P    CAN_F5R1_FB26 3 P    CAN_F5R1_FB27 2 P    CAN_F5R1_FB28 1 P    CAN_F5R1_FB29 0 P    CAN_F5R1_FB30 8 P    CAN_F5R1_FB31 7 P    CAN_F6R1_FB0 l P    CAN_F6R1_FB1 k P    CAN_F6R1_FB2 j P    CAN_F6R1_FB3 i P    CAN_F6R1_FB4 h P    CAN_F6R1_FB5 g P    CAN_F6R1_FB6 f P    CAN_F6R1_FB7 e P    CAN_F6R1_FB8 d P    CAN_F6R1_FB9 c P    CAN_F6R1_FB10 9 P    CAN_F6R1_FB11 8 P    CAN_F6R1_FB12 7 P    CAN_F6R1_FB13 6 P    CAN_F6R1_FB14 5 P    CAN_F6R1_FB15 4 P    CAN_F6R1_FB16 3 P    CAN_F6R1_FB17 2 P    CAN_F6R1_FB18 1 P    CAN_F6R1_FB19 0 P    CAN_F6R1_FB20 8 P    CAN_F6R1_FB21 7 P    CAN_F6R1_FB22 6 P    CAN_F6R1_FB23 5 P    CAN_F6R1_FB24 4 P    CAN_F6R1_FB25 3 P    CAN_F6R1_FB26 2 P    CAN_F6R1_FB27 1 P    CAN_F6R1_FB28 0 P    CAN_F6R1_FB29 / P    CAN_F6R1_FB30 7 P    CAN_F6R1_FB31 6 P    CAN_F7R1_FB0 k P    CAN_F7R1_FB1 j P    CAN_F7R1_FB2 i P    CAN_F7R1_FB3 h P    CAN_F7R1_FB4 g P    CAN_F7R1_FB5 f P    CAN_F7R1_FB6 e P    CAN_F7R1_FB7 d P    CAN_F7R1_FB8 c P    CAN_F7R1_FB9 b P    CAN_F7R1_FB10 8 P    CAN_F7R1_FB11 7 P    CAN_F7R1_FB12 6 P    CAN_F7R1_FB13 5 P    CAN_F7R1_FB14 4 P    CAN_F7R1_FB15 3 P    CAN_F7R1_FB16 2 P    CAN_F7R1_FB17 1 P    CAN_F7R1_FB18 0 P    CAN_F7R1_FB19 / P    CAN_F7R1_FB20 7 P    CAN_F7R1_FB21 6 P    CAN_F7R1_FB22 5 P    CAN_F7R1_FB23 4 P    CAN_F7R1_FB24 3 P    CAN_F7R1_FB25 2 P    CAN_F7R1_FB26 1 P    CAN_F7R1_FB27 0 P    CAN_F7R1_FB28 / P    CAN_F7R1_FB29 . P    CAN_F7R1_FB30 6 P    CAN_F7R1_FB31 5 P    CAN_F8R1_FB0 j P    CAN_F8R1_FB1 i P    CAN_F8R1_FB2 h P    CAN_F8R1_FB3 g P    CAN_F8R1_FB4 f P    CAN_F8R1_FB5 e P    CAN_F8R1_FB6 d P    CAN_F8R1_FB7 c P    CAN_F8R1_FB8 b P    CAN_F8R1_FB9 a P    CAN_F8R1_FB10 7 P    CAN_F8R1_FB11 6 P    CAN_F8R1_FB12 5 P    CAN_F8R1_FB13 4 P    CAN_F8R1_FB14 3 P    CAN_F8R1_FB15 2 P    CAN_F8R1_FB16 1 P    CAN_F8R1_FB17 0 P    CAN_F8R1_FB18 / P    CAN_F8R1_FB19 . P    CAN_F8R1_FB20 6 P    CAN_F8R1_FB21 5 P    CAN_F8R1_FB22 4 P    CAN_F8R1_FB23 3 P    CAN_F8R1_FB24 2 P    CAN_F8R1_FB25 1 P    CAN_F8R1_FB26 0 P    CAN_F8R1_FB27 / P    CAN_F8R1_FB28 . P    CAN_F8R1_FB29 - P    CAN_F8R1_FB30 5 P    CAN_F8R1_FB31 4 P    CAN_F9R1_FB0 i P    CAN_F9R1_FB1 h P    CAN_F9R1_FB2 g P    CAN_F9R1_FB3 f P    CAN_F9R1_FB4 e P    CAN_F9R1_FB5 d P    CAN_F9R1_FB6 c P    CAN_F9R1_FB7 b P    CAN_F9R1_FB8 a P    CAN_F9R1_FB9 ` P    CAN_F9R1_FB10 6 P    CAN_F9R1_FB11 5 P    CAN_F9R1_FB12 4 P    CAN_F9R1_FB13 3 P    CAN_F9R1_FB14 2 P    CAN_F9R1_FB15 1 P    CAN_F9R1_FB16 0 P    CAN_F9R1_FB17 / P    CAN_F9R1_FB18 . P    CAN_F9R1_FB19 - P    CAN_F9R1_FB20 5 P    CAN_F9R1_FB21 4 P    CAN_F9R1_FB22 3 P    CAN_F9R1_FB23 2 P    CAN_F9R1_FB24 1 P    CAN_F9R1_FB25 0 P    CAN_F9R1_FB26 / P    CAN_F9R1_FB27 . P    CAN_F9R1_FB28 - P    CAN_F9R1_FB29 , P    CAN_F9R1_FB30 4 P    CAN_F9R1_FB31 3 P    CAN_F10R1_FB0 ? P    CAN_F10R1_FB1 > P    CAN_F10R1_FB2 = P    CAN_F10R1_FB3 < P    CAN_F10R1_FB4 ; P    CAN_F10R1_FB5 : P    CAN_F10R1_FB6 9 P    CAN_F10R1_FB7 8 P    CAN_F10R1_FB8 7 P    CAN_F10R1_FB9 6 P    CAN_F10R1_FB10  P    CAN_F10R1_FB11  P    CAN_F10R1_FB12 
 P    CAN_F10R1_FB13 	 P    CAN_F10R1_FB14  P    CAN_F10R1_FB15  P    CAN_F10R1_FB16  P    CAN_F10R1_FB17  P    CAN_F10R1_FB18  P    CAN_F10R1_FB19  P    CAN_F10R1_FB20  P    CAN_F10R1_FB21 
 P    CAN_F10R1_FB22 	 P    CAN_F10R1_FB23  P    CAN_F10R1_FB24  P    CAN_F10R1_FB25  P    CAN_F10R1_FB26  P    CAN_F10R1_FB27  P    CAN_F10R1_FB28  P    CAN_F10R1_FB29  P    CAN_F10R1_FB30 
 P    CAN_F10R1_FB31 	 P    CAN_F11R1_FB0 > P    CAN_F11R1_FB1 = P    CAN_F11R1_FB2 < P    CAN_F11R1_FB3 ; P    CAN_F11R1_FB4 : P    CAN_F11R1_FB5 9 P    CAN_F11R1_FB6 8 P    CAN_F11R1_FB7 7 P    CAN_F11R1_FB8 6 P    CAN_F11R1_FB9 5 P    CAN_F11R1_FB10  P    CAN_F11R1_FB11 
 P    CAN_F11R1_FB12 	 P    CAN_F11R1_FB13  P    CAN_F11R1_FB14  P    CAN_F11R1_FB15  P    CAN_F11R1_FB16  P    CAN_F11R1_FB17  P    CAN_F11R1_FB18  P    CAN_F11R1_FB19  P    CAN_F11R1_FB20 
 P    CAN_F11R1_FB21 	 P    CAN_F11R1_FB22  P    CAN_F11R1_FB23  P    CAN_F11R1_FB